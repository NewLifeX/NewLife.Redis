<?xml version="1.0"?>
<doc>
    <assembly>
        <name>NewLife.Core</name>
    </assembly>
    <members>
        <member name="T:NewLife.Agent.AgentService">
            <summary>代理服务例子。自定义服务程序可参照该类实现。</summary>
        </member>
        <member name="M:NewLife.Agent.AgentService.#ctor">
            <summary>实例化一个代理服务</summary>
        </member>
        <member name="M:NewLife.Agent.AgentService.Work(System.Int32)">
            <summary>核心工作方法。调度线程会定期调用该方法</summary>
            <param name="index">线程序号</param>
            <returns>是否立即开始下一步工作。某些任务能达到满负荷，线程可以不做等待</returns>
        </member>
        <member name="T:NewLife.Agent.AgentJob">
            <summary>计划任务例子</summary>
        </member>
        <member name="M:NewLife.Agent.AgentJob.Execute(NewLife.Agent.JobContext)">
            <summary>执行任务</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Agent.AgentServiceBase`1">
            <summary>服务程序基类</summary>
            <typeparam name="TService">服务类型</typeparam>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.#ctor">
            <summary>实例化，读取配置</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.ServiceMain">
            <summary>服务主函数</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.ShowStatus">
            <summary>显示状态</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.ShowMenu">
            <summary>显示菜单</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.AddMenu(System.Char,System.String,System.Action)">
            <summary>添加菜单</summary>
            <param name="key"></param>
            <param name="name"></param>
            <param name="callbak"></param>
        </member>
        <member name="P:NewLife.Agent.AgentServiceBase`1.Items">
            <summary>任务项</summary>
        </member>
        <member name="P:NewLife.Agent.AgentServiceBase`1.Schedule">
            <summary>任务调度器</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.StartWork(System.String)">
            <summary>开始工作</summary>
            <param name="reason"></param>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.Work(System.Int32)">
            <summary>核心工作方法。调度线程会定期调用该方法</summary>
            <param name="index">线程序号</param>
            <returns>是否立即开始下一步工作。某些任务能达到满负荷，线程可以不做等待</returns>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.StopWork(System.String)">
            <summary>停止服务</summary>
            <param name="reason"></param>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.Wake(System.Int32)">
            <summary>唤醒指定任务马上开始处理任务</summary>
            <param name="index"></param>
        </member>
        <member name="F:NewLife.Agent.AgentServiceBase`1.ManagerThread">
            <summary>服务管理线程</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.StartManagerThread">
            <summary>开始服务管理线程</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.StopManagerThread">
            <summary>停止服务管理线程</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.ManagerThreadWaper(System.Object)">
            <summary>服务管理线程封装</summary>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.CheckActive">
            <summary>检查是否有工作线程死亡</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.CheckMemory">
            <summary>检查内存是否超标</summary>
            <returns>是否超标重启</returns>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.CheckThread">
            <summary>检查服务进程的总线程数是否超标</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.CheckHandle">
            <summary>检查服务进程的句柄数是否超标</summary>
            <returns></returns>
        </member>
        <member name="F:NewLife.Agent.AgentServiceBase`1.Start">
            <summary>服务开始时间</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.CheckAutoRestart">
            <summary>检查自动重启</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.Restart(System.String)">
            <summary>重启服务</summary>
            <param name="reason"></param>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.OnStart(System.String[])">
            <summary>服务启动事件</summary>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.OnStop">
            <summary>服务停止事件</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.OnPause">
            <summary>暂停命令发送到服务的服务控制管理器 (SCM) 时执行。 指定当服务就会暂停时要执行的操作。</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.OnContinue">
            <summary>继续命令发送到服务的服务控制管理器 (SCM) 运行。 指定当某个服务后继续正常工作正在暂停时要执行的操作。</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.OnShutdown">
            <summary>在系统关闭时执行。 指定在系统关闭之前应该发生什么。</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.OnPowerEvent(System.ServiceProcess.PowerBroadcastStatus)">
            <summary>在计算机的电源状态已发生更改时执行。 这适用于便携式计算机，当他们进入挂起模式，这不是系统关闭相同。</summary>
            <param name="powerStatus"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.OnSessionChange(System.ServiceProcess.SessionChangeDescription)">
            <summary>在终端服务器会话中接收的更改事件时执行</summary>
            <param name="changeDescription"></param>
        </member>
        <member name="P:NewLife.Agent.AgentServiceBase`1.WatchDogs">
            <summary>看门狗要保护的服务</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase`1.CheckWatchDog">
            <summary>检查看门狗。</summary>
            <remarks>
            XAgent看门狗功能由管理线程完成，每分钟一次。
            检查指定的任务是否已经停止，如果已经停止，则启动它。
            </remarks>
        </member>
        <member name="T:NewLife.Agent.AgentServiceBase">
            <summary>服务程序基类</summary>
        </member>
        <member name="P:NewLife.Agent.AgentServiceBase.DisplayName">
            <summary>显示名</summary>
        </member>
        <member name="P:NewLife.Agent.AgentServiceBase.Description">
            <summary>描述</summary>
        </member>
        <member name="P:NewLife.Agent.AgentServiceBase.ThreadCount">
            <summary>线程数</summary>
        </member>
        <member name="P:NewLife.Agent.AgentServiceBase.ThreadNames">
            <summary>线程名</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="F:NewLife.Agent.AgentServiceBase._Instance">
            <summary></summary>
        </member>
        <member name="P:NewLife.Agent.AgentServiceBase.Instance">
            <summary>服务实例。每个应用程序域只有一个服务实例</summary>
        </member>
        <member name="P:NewLife.Agent.AgentServiceBase.Intervals">
            <summary>间隔数组。默认60秒</summary>
        </member>
        <member name="P:NewLife.Agent.AgentServiceBase.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Agent.AgentServiceBase.WriteLine(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Agent.IAgentService">
            <summary>代理服务接口</summary>
        </member>
        <member name="P:NewLife.Agent.IAgentService.ServiceName">
            <summary>服务名</summary>
        </member>
        <member name="P:NewLife.Agent.IAgentService.DisplayName">
            <summary>显示名</summary>
        </member>
        <member name="P:NewLife.Agent.IAgentService.Description">
            <summary>服务描述</summary>
        </member>
        <member name="M:NewLife.Agent.IAgentService.Stop">
            <summary>停止</summary>
        </member>
        <member name="M:NewLife.Agent.IAgentService.Restart(System.String)">
            <summary>重启服务</summary>
            <param name="reason"></param>
        </member>
        <member name="T:NewLife.Agent.IJob">
            <summary>任务接口</summary>
        </member>
        <member name="M:NewLife.Agent.IJob.Execute(NewLife.Agent.JobContext)">
            <summary>执行一次任务</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Agent.JobBase">
            <summary>工作任务基类</summary>
        </member>
        <member name="M:NewLife.Agent.JobBase.Execute(NewLife.Agent.JobContext)">
            <param name="context"></param>
        </member>
        <member name="P:NewLife.Agent.JobBase.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Agent.JobBase.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Agent.JobContext">
            <summary>任务上下文</summary>
        </member>
        <member name="P:NewLife.Agent.JobContext.Item(System.String)">
            <summary>用户数据</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Agent.JobSchedule">
            <summary>任务调度器</summary>
        </member>
        <member name="P:NewLife.Agent.JobSchedule.Jobs">
            <summary>任务集合</summary>
        </member>
        <member name="P:NewLife.Agent.JobSchedule.Count">
            <summary>任务个数</summary>
        </member>
        <member name="M:NewLife.Agent.JobSchedule.Add(NewLife.Agent.IJob)">
            <summary>向任务调度器添加任务</summary>
            <param name="job"></param>
        </member>
        <member name="T:NewLife.Agent.ServiceControl">
            <summary>
            服务控制器
            </summary>
        </member>
        <member name="M:NewLife.Agent.ServiceControl.Install(System.Boolean,System.String,System.String,System.String,System.String)">
            <summary>安装、卸载 服务</summary>
            <param name="isinstall">是否安装</param>
            <param name="exeName"></param>
            <param name="displayName"></param>
            <param name="description"></param>
            <param name="dir"></param>
        </member>
        <member name="M:NewLife.Agent.ServiceControl.ControlService(System.Boolean,System.String)">
            <summary>启动、停止 服务</summary>
            <param name="isstart"></param>
            <param name="serviceName"></param>
        </member>
        <member name="M:NewLife.Agent.ServiceControl.RunCmd(System.String,System.Boolean,System.Boolean)">
            <summary>执行一个命令</summary>
            <param name="cmd"></param>
            <param name="showWindow"></param>
            <param name="waitForExit"></param>
        </member>
        <member name="M:NewLife.Agent.ServiceControl.RunSC(System.String)">
            <summary>执行SC命令</summary>
            <param name="cmd"></param>
        </member>
        <member name="M:NewLife.Agent.ServiceControl.GetDependentServices(System.String)">
            <summary>获取依赖于<paramref name="serviceName"/>实例的服务</summary>
            <param name="serviceName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Agent.ServiceControl.GetDependentServiceNames(System.String)">
            <summary>获取依赖于<paramref name="serviceName"/>实例的服务名称</summary>
            <param name="serviceName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Agent.ServiceControl.WriteLine(System.String)">
            <summary>写日志</summary>
            <param name="msg"></param>
        </member>
        <member name="T:NewLife.Agent.ServiceHelper">
            <summary>服务助手</summary>
        </member>
        <member name="P:NewLife.Agent.ServiceHelper.ExeName">
            <summary>Exe程序名</summary>
        </member>
        <member name="M:NewLife.Agent.ServiceHelper.Install(NewLife.Agent.IAgentService,System.Boolean)">
            <summary>安装、卸载 服务</summary>
            <param name="service">服务对象</param>
            <param name="isinstall">是否安装</param>
        </member>
        <member name="M:NewLife.Agent.ServiceHelper.ControlService(NewLife.Agent.IAgentService,System.Boolean)">
            <summary>启动、停止 服务</summary>
            <param name="service">服务对象</param>
            <param name="isstart"></param>
        </member>
        <member name="M:NewLife.Agent.ServiceHelper.RunCmd(System.String,System.Boolean,System.Boolean)">
            <summary>执行一个命令</summary>
            <param name="cmd"></param>
            <param name="showWindow"></param>
            <param name="waitForExit"></param>
        </member>
        <member name="M:NewLife.Agent.ServiceHelper.RunSC(System.String)">
            <summary>执行SC命令</summary>
            <param name="cmd"></param>
        </member>
        <member name="M:NewLife.Agent.ServiceHelper.IsInstalled(NewLife.Agent.IAgentService)">
            <summary>是否已安装</summary>
        </member>
        <member name="M:NewLife.Agent.ServiceHelper.IsRunning(NewLife.Agent.IAgentService)">
            <summary>是否已启动</summary>
        </member>
        <member name="M:NewLife.Agent.ServiceHelper.GetService(System.String)">
            <summary>取得服务</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Agent.ServiceHelper.IsServiceInstalled(System.String)">
            <summary>是否已安装</summary>
        </member>
        <member name="M:NewLife.Agent.ServiceHelper.IsServiceRunning(System.String)">
            <summary>是否已启动</summary>
        </member>
        <member name="M:NewLife.Agent.ServiceHelper.PreStartWork(NewLife.Agent.IAgentService)">
            <summary>启动服务准备工作</summary>
        </member>
        <member name="M:NewLife.Agent.ServiceHelper.WriteLine(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Agent.ServiceItem">
            <summary>服务工作项</summary>
        </member>
        <member name="P:NewLife.Agent.ServiceItem.Index">
            <summary>服务项索引</summary>
        </member>
        <member name="P:NewLife.Agent.ServiceItem.Name">
            <summary>线程名称</summary>
        </member>
        <member name="P:NewLife.Agent.ServiceItem.Callback">
            <summary>任务委托</summary>
        </member>
        <member name="P:NewLife.Agent.ServiceItem.Job">
            <summary>工作任务</summary>
        </member>
        <member name="P:NewLife.Agent.ServiceItem.Thread">
            <summary>线程</summary>
        </member>
        <member name="P:NewLife.Agent.ServiceItem.Interval">
            <summary>间隔</summary>
        </member>
        <member name="P:NewLife.Agent.ServiceItem.Active">
            <summary>可用</summary>
        </member>
        <member name="P:NewLife.Agent.ServiceItem.LastActive">
            <summary>最后活跃时间</summary>
        </member>
        <member name="P:NewLife.Agent.ServiceItem.Event">
            <summary>阻塞任务用的自动事件量</summary>
        </member>
        <member name="M:NewLife.Agent.ServiceItem.#ctor(System.Int32,System.String,System.Int32)">
            <summary>实例化一个服务工作项</summary>
            <param name="index"></param>
            <param name="name"></param>
            <param name="interval"></param>
        </member>
        <member name="M:NewLife.Agent.ServiceItem.Start(System.String)">
            <summary>启动工作项</summary>
        </member>
        <member name="M:NewLife.Agent.ServiceItem.Stop(System.String)">
            <summary>停止工作项</summary>
        </member>
        <member name="M:NewLife.Agent.ServiceItem.WorkWaper(System.Object)">
            <summary>线程包装</summary>
            <param name="data">线程序号</param>
        </member>
        <member name="M:NewLife.Agent.ServiceItem.CheckActive">
            <summary>检查是否有工作线程死亡</summary>
        </member>
        <member name="M:NewLife.Agent.ServiceItem.WriteLine(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Agent.Setting">
            <summary>服务设置</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.Debug">
            <summary>是否启用全局调试。默认为不启用</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.ServiceName">
            <summary>服务名</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.DisplayName">
            <summary>显示名</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.Description">
            <summary>服务描述</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.Intervals">
            <summary>工作线程间隔，单位：秒。不同工作线程的时间间隔用逗号或分号隔开。可以通过设置任务的时间间隔小于0来关闭指定任务</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.MaxActive">
            <summary>最大活动时间，单位：秒。超过最大活动时间都还没有响应的线程将会被重启，防止线程执行时间过长。默认0秒，表示无限</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.MaxMemory">
            <summary>最大占用内存，单位： M。超过最大占用时，整个服务进程将会重启，以释放资源。默认0秒，表示无限</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.MaxThread">
            <summary>最大线程数，单位：个。超过最大占用时，整个服务进程将会重启，以释放资源。默认0个，表示无限</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.MaxHandle">
            <summary>最大句柄数，单位：个。超过最大占用时，整个服务进程将会重启，以释放资源。默认0个，表示无限</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.AutoRestart">
            <summary>自动重启时间，单位：分。到达自动重启时间时，整个服务进程将会重启，以释放资源。默认0分，表示无限</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.WaitForExit">
            <summary>等待退出。停止服务时，等待每个线程完成当前工作的退出时间，默认5000ms</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.WatchDog">
            <summary>看门狗，保护其它服务，每分钟检查一次。多个服务名逗号分隔</summary>
        </member>
        <member name="P:NewLife.Agent.Setting.ServicesDependedOn">
            <summary>依赖服务</summary>
        </member>
        <member name="M:NewLife.Agent.Setting.OnNew">
            <summary>新建时调用</summary>
        </member>
        <member name="T:NewLife.IP.Ip">
            <summary>IP搜索</summary>
        </member>
        <member name="P:NewLife.IP.Ip.DbFile">
            <summary>数据文件</summary>
        </member>
        <member name="M:NewLife.IP.Ip.GetAddress(System.String)">
            <summary>获取IP地址</summary>
            <param name="ip"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IP.Ip.GetAddress(System.Net.IPAddress)">
            <summary>获取IP地址</summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.IP.Zip.Stream">
            <summary>数据流</summary>
        </member>
        <member name="M:NewLife.IP.Zip.Finalize">
            <summary>析构</summary>
        </member>
        <member name="M:NewLife.IP.Zip.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="T:NewLife.IP.Zip.IndexInfo">
            <summary>索引结构</summary>
        </member>
        <member name="T:NewLife.Caching.Cache">
            <summary>缓存</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Default">
            <summary>默认缓存</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Expire">
            <summary>默认缓存时间。默认0秒表示不过期</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Item(System.String)">
            <summary>获取和设置缓存，永不过期</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.Cache.Count">
            <summary>缓存个数</summary>
        </member>
        <member name="P:NewLife.Caching.Cache.Keys">
            <summary>所有键</summary>
        </member>
        <member name="M:NewLife.Caching.Cache.#ctor">
            <summary>构造函数</summary>
        </member>
        <member name="M:NewLife.Caching.Cache.Init(System.String)">
            <summary>初始化配置</summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Caching.Cache.ContainsKey(System.String)">
            <summary>是否包含缓存项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Set``1(System.String,``0,System.Int32)">
            <summary>设置缓存项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Set``1(System.String,``0,System.TimeSpan)">
            <summary>设置缓存项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Get``1(System.String)">
            <summary>获取缓存项</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Remove(System.String[])">
            <summary>批量移除缓存项</summary>
            <param name="keys">键集合</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.SetExpire(System.String,System.TimeSpan)">
            <summary>设置缓存项有效期</summary>
            <param name="key">键</param>
            <param name="expire">过期时间，秒</param>
        </member>
        <member name="M:NewLife.Caching.Cache.GetExpire(System.String)">
            <summary>获取缓存项有效期</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetAll``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>批量获取缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.SetAll``1(System.Collections.Generic.IDictionary{System.String,``0},System.Int32)">
            <summary>批量设置缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
        </member>
        <member name="M:NewLife.Caching.Cache.GetList``1(System.String)">
            <summary>获取列表</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetDictionary``1(System.String)">
            <summary>获取哈希</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.GetQueue``1(System.String)">
            <summary>获取队列</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Add``1(System.String,``0,System.Int32)">
            <summary>添加，已存在时不更新</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Replace``1(System.String,``0)">
            <summary>设置新值并获取旧值，原子操作</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Increment(System.String,System.Int64)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Increment(System.String,System.Double)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Decrement(System.String,System.Int64)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Decrement(System.String,System.Double)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.AcquireLock(System.String,System.Int32)">
            <summary>申请分布式锁</summary>
            <param name="key"></param>
            <param name="msTimeout"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Cache.Bench(System.Boolean)">
            <summary>多线程性能测试</summary>
            <param name="rand">随机读写</param>
            <remarks>
            Memory性能测试[顺序]，逻辑处理器 32 个 2,000MHz Intel(R) Xeon(R) CPU E5-2640 v2 @ 2.00GHz
            
            测试 10,000,000 项，  1 线程
            赋值 10,000,000 项，  1 线程，耗时   3,764ms 速度 2,656,748 ops
            读取 10,000,000 项，  1 线程，耗时   1,296ms 速度 7,716,049 ops
            删除 10,000,000 项，  1 线程，耗时   1,230ms 速度 8,130,081 ops
            
            测试 20,000,000 项，  2 线程
            赋值 20,000,000 项，  2 线程，耗时   3,088ms 速度 6,476,683 ops
            读取 20,000,000 项，  2 线程，耗时   1,051ms 速度 19,029,495 ops
            删除 20,000,000 项，  2 线程，耗时   1,011ms 速度 19,782,393 ops
            
            测试 40,000,000 项，  4 线程
            赋值 40,000,000 项，  4 线程，耗时   3,060ms 速度 13,071,895 ops
            读取 40,000,000 项，  4 线程，耗时   1,023ms 速度 39,100,684 ops
            删除 40,000,000 项，  4 线程，耗时     994ms 速度 40,241,448 ops
            
            测试 80,000,000 项，  8 线程
            赋值 80,000,000 项，  8 线程，耗时   3,124ms 速度 25,608,194 ops
            读取 80,000,000 项，  8 线程，耗时   1,171ms 速度 68,317,677 ops
            删除 80,000,000 项，  8 线程，耗时   1,199ms 速度 66,722,268 ops
            
            测试 320,000,000 项， 32 线程
            赋值 320,000,000 项， 32 线程，耗时  13,857ms 速度 23,093,021 ops
            读取 320,000,000 项， 32 线程，耗时   1,950ms 速度 164,102,564 ops
            删除 320,000,000 项， 32 线程，耗时   3,359ms 速度 95,266,448 ops
            
            测试 320,000,000 项， 64 线程
            赋值 320,000,000 项， 64 线程，耗时   9,648ms 速度 33,167,495 ops
            读取 320,000,000 项， 64 线程，耗时   1,974ms 速度 162,107,396 ops
            删除 320,000,000 项， 64 线程，耗时   1,907ms 速度 167,802,831 ops
            
            测试 320,000,000 项，256 线程
            赋值 320,000,000 项，256 线程，耗时  12,429ms 速度 25,746,238 ops
            读取 320,000,000 项，256 线程，耗时   1,907ms 速度 167,802,831 ops
            删除 320,000,000 项，256 线程，耗时   2,350ms 速度 136,170,212 ops
            </remarks>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchOne(System.Int64,System.Int32,System.Boolean)">
            <summary>使用指定线程测试指定次数</summary>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchGet(System.String,System.Int64,System.Int32,System.Boolean)">
            <summary>读取测试</summary>
            <param name="key">键</param>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchSet(System.String,System.Int64,System.Int32,System.Boolean)">
            <summary>赋值测试</summary>
            <param name="key">键</param>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
        </member>
        <member name="M:NewLife.Caching.Cache.BenchRemove(System.String,System.Int64,System.Int32,System.Boolean)">
            <summary>删除测试</summary>
            <param name="key">键</param>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
        </member>
        <member name="M:NewLife.Caching.Cache.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.ICache">
            <summary>缓存接口</summary>
        </member>
        <member name="P:NewLife.Caching.ICache.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Caching.ICache.Expire">
            <summary>默认缓存时间。默认0秒表示不过期</summary>
        </member>
        <member name="P:NewLife.Caching.ICache.Item(System.String)">
            <summary>获取和设置缓存，永不过期</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.ICache.Count">
            <summary>缓存个数</summary>
        </member>
        <member name="P:NewLife.Caching.ICache.Keys">
            <summary>所有键</summary>
        </member>
        <member name="M:NewLife.Caching.ICache.ContainsKey(System.String)">
            <summary>是否包含缓存项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Set``1(System.String,``0,System.Int32)">
            <summary>设置缓存项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.ICache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Set``1(System.String,``0,System.TimeSpan)">
            <summary>设置缓存项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Get``1(System.String)">
            <summary>获取缓存项</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Remove(System.String[])">
            <summary>批量移除缓存项</summary>
            <param name="keys">键集合</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.SetExpire(System.String,System.TimeSpan)">
            <summary>设置缓存项有效期</summary>
            <param name="key">键</param>
            <param name="expire">过期时间</param>
        </member>
        <member name="M:NewLife.Caching.ICache.GetExpire(System.String)">
            <summary>获取缓存项有效期</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetAll``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>批量获取缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.SetAll``1(System.Collections.Generic.IDictionary{System.String,``0},System.Int32)">
            <summary>批量设置缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.ICache.Expire"/></param>
        </member>
        <member name="M:NewLife.Caching.ICache.GetList``1(System.String)">
            <summary>获取列表</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetDictionary``1(System.String)">
            <summary>获取哈希</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.GetQueue``1(System.String)">
            <summary>获取队列</summary>
            <typeparam name="T">元素类型</typeparam>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Add``1(System.String,``0,System.Int32)">
            <summary>添加，已存在时不更新</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Replace``1(System.String,``0)">
            <summary>设置新值并获取旧值，原子操作</summary>
            <remarks>
            常常配合Increment使用，用于累加到一定数后重置归零，又避免多线程冲突。
            </remarks>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Increment(System.String,System.Int64)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Increment(System.String,System.Double)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Decrement(System.String,System.Int64)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Decrement(System.String,System.Double)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.AcquireLock(System.String,System.Int32)">
            <summary>申请分布式锁</summary>
            <param name="key">要锁定的key</param>
            <param name="msTimeout"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.ICache.Bench(System.Boolean)">
            <summary>多线程性能测试</summary>
            <param name="rand">随机读写</param>
        </member>
        <member name="T:NewLife.Caching.IProducerConsumer`1">
            <summary>生产者消费者接口</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>生产添加</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.IProducerConsumer`1.Take(System.Int32)">
            <summary>消费获取</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.MemoryCache">
            <summary>默认字典缓存</summary>
        </member>
        <member name="F:NewLife.Caching.MemoryCache._cache">
            <summary>缓存核心</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Capacity">
            <summary>容量。容量超标时，采用LRU机制删除，默认100_000</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Period">
            <summary>定时清理时间，默认60秒</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.#ctor">
            <summary>实例化一个内存字典缓存</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Count">
            <summary>缓存项。原子计数</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.Keys">
            <summary>所有键。实际返回只读列表新实例，数据量较大时注意性能</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Init(System.String)">
            <summary>初始化配置</summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetOrAdd``1(System.String,``0,System.Int32)">
            <summary>获取或添加缓存项</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.ContainsKey(System.String)">
            <summary>是否包含缓存项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Set``1(System.String,``0,System.Int32)">
            <summary>添加缓存项，已存在时更新</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Get``1(System.String)">
            <summary>获取缓存项，不存在时返回默认值</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Remove(System.String[])">
            <summary>批量移除缓存项</summary>
            <param name="keys">键集合</param>
            <returns>实际移除个数</returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.SetExpire(System.String,System.TimeSpan)">
            <summary>设置缓存项有效期</summary>
            <param name="key">键</param>
            <param name="expire">过期时间</param>
            <returns>设置是否成功</returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetExpire(System.String)">
            <summary>获取缓存项有效期，不存在时返回Zero</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Add``1(System.String,``0,System.Int32)">
            <summary>添加，已存在时不更新，常用于锁争夺</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Replace``1(System.String,``0)">
            <summary>设置新值并获取旧值，原子操作</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Increment(System.String,System.Int64)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Increment(System.String,System.Double)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Decrement(System.String,System.Int64)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.Decrement(System.String,System.Double)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetList``1(System.String)">
            <summary>获取列表</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetDictionary``1(System.String)">
            <summary>获取哈希</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetQueue``1(System.String)">
            <summary>获取队列</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.GetOrAddItem(System.String,System.Func{System.String,System.Object})">
            <summary>获取 或 添加 缓存项</summary>
            <param name="key"></param>
            <param name="valueFactory"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.MemoryCache.CacheItem">
            <summary>缓存项</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.CacheItem.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.CacheItem.ExpiredTime">
            <summary>过期时间</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.CacheItem.Expired">
            <summary>是否过期</summary>
        </member>
        <member name="P:NewLife.Caching.MemoryCache.CacheItem.VisitTime">
            <summary>访问时间</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.#ctor(System.Object,System.Int32)">
            <summary>构造缓存项</summary>
            <param name="value"></param>
            <param name="expire"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Set(System.Object,System.Int32)">
            <summary>设置数值和过期时间</summary>
            <param name="value"></param>
            <param name="expire"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Visit">
            <summary>更新访问时间并返回数值</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.SetExpire(System.Int32)">
            <summary>设置过期时间</summary>
            <param name="expire"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Inc(System.Object)">
            <summary>递增</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.CacheItem.Dec(System.Object)">
            <summary>递减</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="F:NewLife.Caching.MemoryCache.clearTimer">
            <summary>清理会话计时器</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.RemoveNotAlive(System.Object)">
            <summary>移除过期的缓存项</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryCache.BenchOne(System.Int64,System.Int32,System.Boolean)">
            <summary>使用指定线程测试指定次数</summary>
            <param name="times">次数</param>
            <param name="threads">线程</param>
            <param name="rand">随机读写</param>
        </member>
        <member name="T:NewLife.Caching.MemoryQueue`1">
            <summary>生产者消费者</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.#ctor">
            <summary>实例化内存队列</summary>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.#ctor(System.Collections.Concurrent.IProducerConsumerCollection{`0})">
            <summary>实例化内存队列</summary>
            <param name="collection"></param>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>生产添加</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.MemoryQueue`1.Take(System.Int32)">
            <summary>消费获取</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.Redis">
            <summary>Redis缓存</summary>
        </member>
        <member name="M:NewLife.Caching.Redis.Create(System.String,System.Int32)">
            <summary>创建</summary>
            <param name="server"></param>
            <param name="db"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.Redis.Server">
            <summary>服务器</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Password">
            <summary>密码</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Db">
            <summary>目标数据库。默认0</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Retry">
            <summary>出错重试次数。如果出现协议解析错误，可以重试的次数，默认0</summary>
        </member>
        <member name="M:NewLife.Caching.Redis.Init(System.String)">
            <summary>初始化</summary>
            <param name="config"></param>
        </member>
        <member name="M:NewLife.Caching.Redis.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Caching.Redis.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.CreateSub(System.Int32)">
            <summary>为同一服务器创建不同Db的子级库</summary>
            <param name="db"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.Redis.Pool">
            <summary>连接池</summary>
        </member>
        <member name="M:NewLife.Caching.Redis.Execute``1(System.Func{NewLife.Caching.RedisClient,``0})">
            <summary>执行命令</summary>
            <typeparam name="T"></typeparam>
            <param name="func"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.Redis.Count">
            <summary>缓存个数</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Keys">
            <summary>所有键</summary>
        </member>
        <member name="M:NewLife.Caching.Redis.Set``1(System.String,``0,System.Int32)">
            <summary>单个实体项</summary>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
        </member>
        <member name="M:NewLife.Caching.Redis.Get``1(System.String)">
            <summary>获取单体</summary>
            <param name="key">键</param>
        </member>
        <member name="M:NewLife.Caching.Redis.Remove(System.String[])">
            <summary>批量移除缓存项</summary>
            <param name="keys">键集合</param>
        </member>
        <member name="M:NewLife.Caching.Redis.ContainsKey(System.String)">
            <summary>是否存在</summary>
            <param name="key">键</param>
        </member>
        <member name="M:NewLife.Caching.Redis.SetExpire(System.String,System.TimeSpan)">
            <summary>设置缓存项有效期</summary>
            <param name="key">键</param>
            <param name="expire">过期时间</param>
        </member>
        <member name="M:NewLife.Caching.Redis.GetExpire(System.String)">
            <summary>获取缓存项有效期</summary>
            <param name="key">键</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.GetAll``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>批量获取缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.SetAll``1(System.Collections.Generic.IDictionary{System.String,``0},System.Int32)">
            <summary>批量设置缓存项</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
        </member>
        <member name="M:NewLife.Caching.Redis.GetQueue``1(System.String)">
            <summary>获取队列</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Add``1(System.String,``0,System.Int32)">
            <summary>添加，已存在时不更新</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <param name="expire">过期时间，秒。小于0时采用默认缓存时间<seealso cref="P:NewLife.Caching.Cache.Expire"/></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Replace``1(System.String,``0)">
            <summary>设置新值并获取旧值，原子操作</summary>
            <typeparam name="T">值类型</typeparam>
            <param name="key">键</param>
            <param name="value">值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Increment(System.String,System.Int64)">
            <summary>累加，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Increment(System.String,System.Double)">
            <summary>累加，原子操作，乘以100后按整数操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Decrement(System.String,System.Int64)">
            <summary>递减，原子操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Decrement(System.String,System.Double)">
            <summary>递减，原子操作，乘以100后按整数操作</summary>
            <param name="key">键</param>
            <param name="value">变化量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.Redis.Bench(System.Boolean)">
            <summary>性能测试</summary>
            <param name="rand">随机读写</param>
        </member>
        <member name="M:NewLife.Caching.Redis.Test">
            <summary>测试</summary>
        </member>
        <member name="P:NewLife.Caching.Redis.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Caching.Redis.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Caching.RedisQueue`1">
            <summary>生产者消费者</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Caching.RedisQueue`1.Add(System.Collections.Generic.IEnumerable{`0})">
            <summary>生产添加</summary>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisQueue`1.Take(System.Int32)">
            <summary>消费获取</summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Caching.RedisClient">
            <summary>Redis客户端</summary>
            <remarks>
            以极简原则进行设计，每个客户端不支持并行命令处理，可通过多客户端多线程解决。
            收发共用64k缓冲区，所以命令请求和响应不能超过64k。
            </remarks>
        </member>
        <member name="P:NewLife.Caching.RedisClient.Client">
            <summary>客户端</summary>
        </member>
        <member name="P:NewLife.Caching.RedisClient.Server">
            <summary>内容类型</summary>
        </member>
        <member name="P:NewLife.Caching.RedisClient.Password">
            <summary>密码</summary>
        </member>
        <member name="P:NewLife.Caching.RedisClient.Logined">
            <summary>是否已登录</summary>
        </member>
        <member name="P:NewLife.Caching.RedisClient.LoginTime">
            <summary>登录时间</summary>
        </member>
        <member name="P:NewLife.Caching.RedisClient.Busy">
            <summary>是否正在处理命令</summary>
        </member>
        <member name="M:NewLife.Caching.RedisClient.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Caching.RedisClient.GetStream(System.Boolean)">
            <summary>异步请求</summary>
            <param name="create">新建连接</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.SendCommand(System.String,NewLife.Data.Packet[])">
            <summary>异步发出请求，并接收响应</summary>
            <param name="cmd"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Execute(System.String,System.Object[])">
            <summary>执行命令。返回字符串、Packet、Packet[]</summary>
            <param name="cmd"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Execute``1(System.String,System.Object[])">
            <summary>执行命令。返回基本类型、对象、对象数组</summary>
            <param name="cmd"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Ping">
            <summary>心跳</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Select(System.Int32)">
            <summary>选择Db</summary>
            <param name="db"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Auth(System.String)">
            <summary>验证密码</summary>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Quit">
            <summary>退出</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.GetInfo">
            <summary>获取信息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Set``1(System.String,``0,System.Int32)">
            <summary>设置</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <param name="value"></param>
            <param name="secTimeout">超时时间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.Get``1(System.String)">
            <summary>读取</summary>
            <typeparam name="T"></typeparam>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.SetAll``1(System.Collections.Generic.IDictionary{System.String,``0})">
            <summary>批量设置</summary>
            <typeparam name="T"></typeparam>
            <param name="values"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.GetAll``1(System.Collections.Generic.IEnumerable{System.String})">
            <summary>批量获取</summary>
            <typeparam name="T"></typeparam>
            <param name="keys"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.ToBytes(System.Object)">
            <summary>数值转字节数组</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.FromBytes(NewLife.Data.Packet,System.Type)">
            <summary>字节数组转对象</summary>
            <param name="pk"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.FromBytes``1(NewLife.Data.Packet)">
            <summary>字节数组转对象</summary>
            <typeparam name="T"></typeparam>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.RedisClient.GetHeaderBytes(System.String,System.Int32)">
            <summary>获取命令对应的字节数组，全局缓存</summary>
            <param name="cmd"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Caching.RedisClient.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Caching.RedisClient.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Caching.CacheLock">
            <summary>分布式锁</summary>
        </member>
        <member name="P:NewLife.Caching.CacheLock.Key">
            <summary>键</summary>
        </member>
        <member name="M:NewLife.Caching.CacheLock.#ctor(NewLife.Caching.ICache,System.String)">
            <summary>实例化</summary>
            <param name="client"></param>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Caching.CacheLock.Acquire(System.Int32)">
            <summary>申请锁</summary>
            <param name="msTimeout"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Caching.CacheLock.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="T:NewLife.Collections.ConcurrentHashSet`1">
            <summary>并行哈希集合</summary>
            <remarks>
            主要用于频繁添加删除而又要遍历的场合
            </remarks>
        </member>
        <member name="M:NewLife.Collections.ConcurrentHashSet`1.#ctor">
            <summary>实例化一个并行哈希集合</summary>
        </member>
        <member name="P:NewLife.Collections.ConcurrentHashSet`1.IsEmpty">
            <summary>是否空集合</summary>
        </member>
        <member name="P:NewLife.Collections.ConcurrentHashSet`1.Count">
            <summary>元素个数</summary>
        </member>
        <member name="M:NewLife.Collections.ConcurrentHashSet`1.Contain(`0)">
            <summary>是否包含元素</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ConcurrentHashSet`1.TryAdd(`0)">
            <summary>尝试添加</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ConcurrentHashSet`1.TryRemove(`0)">
            <summary>尝试删除</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.DictionaryCache`2">
            <summary>字典缓存。当指定键的缓存项不存在时，调用委托获取值，并写入缓存。</summary>
            <remarks>常用匿名函数或者Lambda表达式作为委托。</remarks>
            <typeparam name="TKey">键类型</typeparam>
            <typeparam name="TValue">值类型</typeparam>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Expire">
            <summary>过期时间。单位是秒，默认0秒，表示永不过期</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Period">
            <summary>定时清理时间，默认0秒，表示不清理过期项</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Capacity">
            <summary>容量。容量超标时，采用LRU机制删除，默认10_000</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.AllowNull">
            <summary>是否允许缓存控制，避免缓存穿透。默认false</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.FindMethod">
            <summary>查找数据的方法</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.#ctor">
            <summary>实例化一个字典缓存</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>实例化一个字典缓存</summary>
            <param name="comparer"></param>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.#ctor(System.Func{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>实例化一个字典缓存</summary>
            <param name="findMethod"></param>
            <param name="comparer"></param>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="T:NewLife.Collections.DictionaryCache`2.CacheItem">
            <summary>缓存项</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.CacheItem.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.CacheItem.ExpiredTime">
            <summary>过期时间</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.CacheItem.Expired">
            <summary>是否过期</summary>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.CacheItem.VisitTime">
            <summary>访问时间</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.CacheItem.Visit">
            <summary>更新访问时间并返回数值</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Item(`0)">
            <summary>重写索引器。取值时如果没有该项则返回默认值；赋值时如果已存在该项则覆盖，否则添加。</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetOrAdd(`0)">
            <summary>获取 GetOrAdd</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Get(`0)">
            <summary>获取 GetOrAdd</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Set(`0,`1)">
            <summary>设置 AddOrUpdate</summary>
            <param name="key"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.TryAdd(`0,`1,System.Boolean,`1@)">
            <summary>尝试添加，或返回旧值</summary>
            <param name="key"></param>
            <param name="value"></param>
            <param name="updateIfExists"></param>
            <param name="resultingValue"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetItem(`0,System.Func{`0,`1})">
            <summary>扩展获取数据项，当数据项不存在时，通过调用委托获取数据项。线程安全。</summary>
            <param name="key">键</param>
            <param name="func">获取值的委托，该委托以键作为参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.Remove(`0)">
            <summary>移除指定缓存项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.DictionaryCache`2.Count">
            <summary>缓存项。原子计数</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.ContainsKey(`0)">
            <summary>是否包含指定键</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.CopyTo(NewLife.Collections.DictionaryCache{`0,`1})">
            <summary>赋值到目标缓存</summary>
            <param name="cache"></param>
        </member>
        <member name="F:NewLife.Collections.DictionaryCache`2._timer">
            <summary>清理会话计时器</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.RemoveNotAlive(System.Object)">
            <summary>移除过期的缓存项</summary>
        </member>
        <member name="M:NewLife.Collections.DictionaryCache`2.GetEnumerator">
            <summary>枚举</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.IPool`1">
            <summary>对象池接口</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.IPool`1.Max">
            <summary>对象池大小</summary>
        </member>
        <member name="M:NewLife.Collections.IPool`1.Get">
            <summary>获取</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.IPool`1.Put(`0)">
            <summary>归还</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.IPool`1.Clear">
            <summary>清空</summary>
        </member>
        <member name="T:NewLife.Collections.Pool">
            <summary>对象池扩展</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.StringBuilder">
            <summary>字符串构建器池</summary>
        </member>
        <member name="M:NewLife.Collections.Pool.Put(System.Text.StringBuilder,System.Boolean)">
            <summary>归还一个字符串构建器到对象池</summary>
            <param name="sb"></param>
            <param name="requireResult">是否需要返回结果</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.Pool.StringBuilderPool">
            <summary>字符串构建器池</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.StringBuilderPool.InitialCapacity">
            <summary>初始容量。默认100个</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.StringBuilderPool.MaximumCapacity">
            <summary>最大容量。超过该大小时不进入池内，默认4k</summary>
        </member>
        <member name="M:NewLife.Collections.Pool.StringBuilderPool.OnCreate">
            <summary>创建</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool.StringBuilderPool.Put(System.Text.StringBuilder)">
            <summary>归还</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.Pool.MemoryStream">
            <summary>内存流池</summary>
        </member>
        <member name="M:NewLife.Collections.Pool.Put(System.IO.MemoryStream,System.Boolean)">
            <summary>归还一个内存流到对象池</summary>
            <param name="ms"></param>
            <param name="requireResult">是否需要返回结果</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.Pool.MemoryStreamPool">
            <summary>内存流池</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.MemoryStreamPool.InitialCapacity">
            <summary>初始容量。默认100个</summary>
        </member>
        <member name="P:NewLife.Collections.Pool.MemoryStreamPool.MaximumCapacity">
            <summary>最大容量。超过该大小时不进入池内，默认4k</summary>
        </member>
        <member name="M:NewLife.Collections.Pool.MemoryStreamPool.OnCreate">
            <summary>创建</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool.MemoryStreamPool.Put(System.IO.MemoryStream)">
            <summary>归还</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.NullableDictionary`2">
            <summary>可空字典。获取数据时如果指定键不存在可返回空而不是抛出异常</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:NewLife.Collections.NullableDictionary`2.#ctor">
            <summary>实例化一个可空字典</summary>
        </member>
        <member name="M:NewLife.Collections.NullableDictionary`2.#ctor(System.Collections.Generic.IEqualityComparer{`0})">
            <summary>指定比较器实例化一个可空字典</summary>
            <param name="comparer"></param>
        </member>
        <member name="M:NewLife.Collections.NullableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1},System.Collections.Generic.IEqualityComparer{`0})">
            <summary>实例化一个可空字典</summary>
            <param name="dic"></param>
            <param name="comparer"></param>
        </member>
        <member name="P:NewLife.Collections.NullableDictionary`2.Item(`0)">
            <summary>获取或设置与指定的属性是否有脏数据。</summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Collections.ObjectPool`1">
            <summary>资源池。支持空闲释放，主要用于数据库连接池和网络连接池</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.FreeCount">
            <summary>空闲个数</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.BusyCount">
            <summary>繁忙个数</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Max">
            <summary>最大个数。默认100</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Min">
            <summary>最小个数。默认1</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.IdleTime">
            <summary>空闲清理时间。最小个数之上的资源超过空闲时间时被清理，默认10s</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.AllIdleTime">
            <summary>完全空闲清理时间。最小个数之下的资源超过空闲时间时被清理，默认0s永不清理</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._free">
            <summary>基础空闲集合。只保存最小个数，最热部分</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._free2">
            <summary>扩展空闲集合。保存最小个数以外部分</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1._busy">
            <summary>借出去的放在这</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.#ctor">
            <summary>实例化一个资源池</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Item.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Item.LastTime">
            <summary>过期时间</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Get">
            <summary>借出</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.GetItem">
            <summary>申请资源包装项，Dispose时自动归还到池中</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Put(`0)">
            <summary>归还</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.Clear">
            <summary>清空已有对象</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.OnCreate">
            <summary>创建实例</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Total">
            <summary>总请求数</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Success">
            <summary>成功数</summary>
        </member>
        <member name="F:NewLife.Collections.ObjectPool`1.Cost">
            <summary>平均耗时。单位ms</summary>
        </member>
        <member name="P:NewLife.Collections.ObjectPool`1.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Collections.ObjectPool`1.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Collections.PoolItem`1">
            <summary>资源池包装项，自动归还资源到池中</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.PoolItem`1.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Collections.PoolItem`1.Pool">
            <summary>池</summary>
        </member>
        <member name="M:NewLife.Collections.PoolItem`1.#ctor(NewLife.Collections.IPool{`0},`0)">
            <summary>包装项</summary>
            <param name="pool"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Collections.PoolItem`1.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="T:NewLife.Collections.Pool`1">
            <summary>轻量级对象池。数组无锁实现，高性能</summary>
            <remarks>
            内部 1+N 的存储结果，保留最热的一个对象在外层，便于快速存取。
            数组具有极快的查找速度，结构体确保没有GC操作。
            </remarks>
            <typeparam name="T"></typeparam>
        </member>
        <member name="P:NewLife.Collections.Pool`1.Max">
            <summary>对象池大小。默认CPU*2，初始化后改变无效</summary>
        </member>
        <member name="M:NewLife.Collections.Pool`1.#ctor(System.Int32)">
            <summary>实例化对象池。默认大小CPU*2</summary>
            <param name="max"></param>
        </member>
        <member name="M:NewLife.Collections.Pool`1.Get">
            <summary>获取</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool`1.Put(`0)">
            <summary>归还</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool`1.Clear">
            <summary>清空</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Collections.Pool`1.OnCreate">
            <summary>创建实例</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.CombGuid">
            <summary>COMB 类型 GUID，要存储在数据库中或要从数据库中检索的 GUID。</summary>
            <remarks>COMB 类型 GUID 是由Jimmy Nilsson在他的“The Cost of GUIDs as Primary Keys(http://www.informit.com/articles/article.aspx?p=25862)”一文中设计出来的。
            <para>基本设计思路是这样的：既然GUID数据因毫无规律可言造成索引效率低下，影响了系统的性能，那么能不能通过组合的方式，
            保留GUID的前10个字节，用后6个字节表示GUID生成的时间（DateTime），这样我们将时间信息与GUID组合起来，
            在保留GUID的唯一性的同时增加了有序性，以此来提高索引效率。</para>
            <para>也许有人会担心GUID减少到10字节会造成数据出现重复，其实不用担心，
            后6字节的时间精度可以达到 1/10000 秒，两个COMB类型数据完全相同的可能性是在这 1/10000 秒内生成的两个GUID前10个字节完全相同，这几乎是不可能的！</para>
            <para>理论上一天之内允许生成 864000000 个不重复的CombGuid；如果当天生成的个数大于 864000000 ，会一直累加 1 直到 2147483647 ，
            也就是说实际一天之内能生成 2147483647 个不重复的CombGuid。</para>
            <para>COMB 类型 GUID 性能可以参考：GUIDs as fast primary keys under multiple databases
            (http://www.codeproject.com/Articles/388157/GUIDs-as-fast-primary-keys-under-multiple-database)</para>
            
            作者：海洋饼干
            
            时间：2014-11-09 21:29
            </remarks>
        </member>
        <member name="F:NewLife.CombGuid.Null">
            <summary>CombGuid 结构的只读实例，其值空。</summary>
        </member>
        <member name="F:NewLife.CombGuid.Empty">
            <summary>CombGuid 结构的只读实例，其值均为零。</summary>
        </member>
        <member name="P:NewLife.CombGuid.Value">
            <summary>获取 CombGuid 结构的值。 此属性为只读。</summary>
        </member>
        <member name="P:NewLife.CombGuid.DateTime">
            <summary>获取 CombGuid 结构的日期时间属性。
            <para>如果同一时间批量生成了大量的 CombGuid 时，返回的日期时间是不准确的！</para>
            </summary>
        </member>
        <member name="M:NewLife.CombGuid.#ctor(System.Boolean)">
            <summary>实例化一个空 CombGuid 结构</summary>
        </member>
        <member name="M:NewLife.CombGuid.#ctor(System.Byte[],NewLife.CombGuidSequentialSegmentType,System.Boolean)">
            <summary>使用指定的字节数组初始化 CombGuid 结构的新实例。</summary>
            <param name="value">包含初始化 CombGuid 的值的 16 元素字节数组。</param>
            <param name="sequentialType">指示字节数组中标识顺序的 6 位字节的位置</param>
            <param name="isOwner">指示使用指定的字节数组初始化 CombGuid 结构的新实例是否拥有此字节数组。</param>
        </member>
        <member name="M:NewLife.CombGuid.#ctor(System.String,NewLife.CombGuidSequentialSegmentType)">
            <summary>使用指定字符串所表示的值初始化 CombGuid 结构的新实例。</summary>
            <param name="comb">包含下面任一格式的 CombGuid 的字符串（“d”表示忽略大小写的十六进制数字）：
            <para>32 个连续的数字 dddddddddddddddddddddddddddddddd </para>
            <para>- 或 CombGuid 格式字符串 - </para>
            <para>12 和 4、4、4、8 位数字的分组，各组之间有连线符，dddddddddddd-dddd-dddd-dddd-dddddddd</para>
            <para>- 或 Guid 格式字符串 - </para>
            <para>8、4、4、4 和 12 位数字的分组，各组之间有连线符，dddddddd-dddd-dddd-dddd-dddddddddddd</para>
            </param>
            <param name="sequentialType">指示字符串中标识顺序的 12 位字符串的位置</param>
        </member>
        <member name="M:NewLife.CombGuid.#ctor(System.Guid)">
            <summary>使用指定的 Guid 参数初始化 CombGuid 结构的新实例。</summary>
            <param name="g">一个 Guid</param>
        </member>
        <member name="M:NewLife.CombGuid.#ctor(System.Int32,System.Int16,System.Int16,System.Byte[])">
            <summary>使用指定的整数和字节数组初始化 CombGuid 类的新实例。</summary>
            <param name="a">CombGuid 的开头四个字节。</param>
            <param name="b">CombGuid 的下两个字节。</param>
            <param name="c">CombGuid 的下两个字节。</param>
            <param name="d">CombGuid 的其余 8 个字节</param>
        </member>
        <member name="M:NewLife.CombGuid.#ctor(System.Int32,System.Int16,System.Int16,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte,System.Byte)">
            <summary>使用指定的值初始化 CombGuid 结构的新实例。</summary>
            <param name="a">CombGuid 的开头四个字节。</param>
            <param name="b">CombGuid 的下两个字节。</param>
            <param name="c">CombGuid 的下两个字节。</param>
            <param name="d">CombGuid 的下一个字节。</param>
            <param name="e">CombGuid 的下一个字节。</param>
            <param name="f">CombGuid 的下一个字节。</param>
            <param name="g">CombGuid 的下一个字节。</param>
            <param name="h">CombGuid 的下一个字节。</param>
            <param name="i">CombGuid 的下一个字节。</param>
            <param name="j">CombGuid 的下一个字节。</param>
            <param name="k">CombGuid 的下一个字节。</param>
        </member>
        <member name="M:NewLife.CombGuid.ToByteArray(NewLife.CombGuidSequentialSegmentType)">
            <summary>将此 CombGuid 结构转换为字节数组，如果此 CombGuid 结构值为空，抛出异常。</summary>
            <param name="sequentialType">指示生成的字节数组中标识顺序的 6 位字节的位置</param>
            <returns>16 元素字节数组。</returns>
        </member>
        <member name="M:NewLife.CombGuid.GetByteArray(NewLife.CombGuidSequentialSegmentType)">
            <summary>直接获取此 CombGuid 结构内部的字节数组，如果此 CombGuid 结构值为空，抛出异常。
            <para>调用此方法后，不要对获取的字节数组做任何改变！！！</para>
            </summary>
            <param name="sequentialType">指示生成的字节数组中标识顺序的 6 位字节的位置</param>
            <returns>16 元素字节数组 或 null。</returns>
        </member>
        <member name="M:NewLife.CombGuid.ToString">
            <summary>已重载，将此 CombGuid 结构转换为字符串，如果此 CombGuid 结构值为空，则返回表示空值的字符串。</summary>
            <returns>返回该 CombGuid 结构的字符串表示形式。</returns>
        </member>
        <member name="M:NewLife.CombGuid.ToString(NewLife.CombGuidFormatStringType)">
            <summary>根据所提供的格式方式，返回此 CombGuid 实例值的字符串表示形式，如果此 CombGuid 结构值为空，则返回表示空值的字符串。</summary>
            <param name="formatType">格式化方式，它指示如何格式化此 CombGuid 的值。</param>
            <returns>此 CombGuid 的值，用一系列指定格式的小写十六进制位表示</returns>
        </member>
        <member name="M:NewLife.CombGuid.GetChars(NewLife.CombGuidFormatStringType)">
            <summary>根据所提供的格式方式，返回此 CombGuid 实例值的字符数组，如果此 CombGuid 结构值为空，抛出异常。</summary>
            <param name="formatType">格式化方式，它指示如何格式化此 CombGuid 的值。</param>
            <returns>此 CombGuid 的字符数组，包含一系列指定格式的小写十六进制位字符</returns>
        </member>
        <member name="M:NewLife.CombGuid.GetChars(NewLife.CombGuidSplitPartType,System.Boolean)">
            <summary>获取 CombGuid 结构字符串指定区域的无序字符（小写十六进制位），每个区域只允许获取 1 或 2 个字符，
            如果此 CombGuid 结构值为空，抛出异常。</summary>
            <remarks>以 CombGuid 结构作为主键，可用于多级（最多四级）目录结构附件存储，或变相用于实现Hash方式分表分库；单个字符 16 种组合方式，两个字符 256 中组合方式</remarks>
            <param name="partType">截取区域</param>
            <param name="isSingleCharacter">是否获取单个字符</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.CombGuid.GetHexChars(NewLife.CombGuidSequentialSegmentType)">
            <summary>根据所提供的格式方式，返回此 CombGuid 实例值的字符数组，如果此 CombGuid 结构值为空，抛出异常。</summary>
            <param name="sequentialType">指示生成的字符数组中标识顺序的 6 位字节的位置。</param>
            <returns>此 CombGuid 的字符数组，包含一系列指定格式的小写十六进制位字符</returns>
        </member>
        <member name="M:NewLife.CombGuid.ToHex(NewLife.CombGuidSequentialSegmentType)">
            <summary>根据所提供的格式方式，把此 CombGuid 编码为十六进制字符串，如果此 CombGuid 结构值为空，抛出异常。</summary>
            <param name="sequentialType">指示生成的字符数组中标识顺序的 6 位字节的位置。</param>
            <returns></returns>
        </member>
        <member name="F:NewLife.CombGuid._MaxTenthMilliseconds">
            <summary>一天时间，单位：100 纳秒</summary>
        </member>
        <member name="F:NewLife.CombGuid._BaseDate">
            <summary>基准日期</summary>
        </member>
        <member name="M:NewLife.CombGuid.NewComb">
            <summary>初始化 CombGuid 结构的新实例。</summary>
            <returns>一个新的 CombGuid 对象。</returns>
        </member>
        <member name="M:NewLife.CombGuid.NewComb(System.DateTime)">
            <summary>初始化 CombGuid 结构的新实例。</summary>
            <param name="endTime">用于生成 CombGuid 日期时间</param>
            <returns>一个新的 CombGuid 对象。</returns>
        </member>
        <member name="M:NewLife.CombGuid.SaveConfig">
            <summary>保存配置</summary>
        </member>
        <member name="M:NewLife.CombGuid.Parse(System.String,NewLife.CombGuidSequentialSegmentType)">
            <summary>将 CombGuid 的字符串表示形式转换为等效的 CombGuid 结构。</summary>
            <param name="s">包含下面任一格式的 CombGuid 的字符串（“d”表示忽略大小写的十六进制数字）：
            <para>32 个连续的数字 dddddddddddddddddddddddddddddddd </para>
            <para>- 或 CombGuid 格式字符串 - </para>
            <para>12 和 4、4、4、8 位数字的分组，各组之间有连线符，dddddddddddd-dddd-dddd-dddd-dddddddd</para>
            <para>- 或 Guid 格式字符串 - </para>
            <para>8、4、4、4 和 12 位数字的分组，各组之间有连线符，dddddddd-dddd-dddd-dddd-dddddddddddd</para>
            </param>
            <param name="sequentialType">指示字符串中标识顺序的 12 位字符串的位置</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.CombGuid.TryParse(System.String,NewLife.CombGuidSequentialSegmentType,NewLife.CombGuid@)">
            <summary>将 CombGuid 的字符串表示形式转换为等效的 CombGuid 结构。</summary>
            <param name="comb">包含下面任一格式的 CombGuid 的字符串（“d”表示忽略大小写的十六进制数字）：
            <para>32 个连续的数字 dddddddddddddddddddddddddddddddd </para>
            <para>- 或 CombGuid 格式字符串 - </para>
            <para>12 和 4、4、4、8 位数字的分组，各组之间有连线符，dddddddddddd-dddd-dddd-dddd-dddddddd</para>
            <para>- 或 Guid 格式字符串 - </para>
            <para>8、4、4、4 和 12 位数字的分组，各组之间有连线符，dddddddd-dddd-dddd-dddd-dddddddddddd</para>
            </param>
            <param name="sequentialType">指示字符串中标识顺序的 12 位字符串的位置</param>
            <param name="result">将包含已分析的值的结构。 如果此方法返回 true，result 包含有效的 CombGuid。 如果此方法返回 false，result 等于 CombGuid.Null。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.CombGuid.TryParse(System.Object,NewLife.CombGuidSequentialSegmentType,NewLife.CombGuid@)">
            <summary>将 CombGuid 的字符串表示形式转换为等效的 CombGuid 结构。</summary>
            <param name="value">Guid结构、CombGuid结构、16 元素字节数组 或 包含下面任一格式的 CombGuid 的字符串（“d”表示忽略大小写的十六进制数字）：
            <para>32 个连续的数字 dddddddddddddddddddddddddddddddd </para>
            <para>- 或 CombGuid 格式字符串 - </para>
            <para>12 和 4、4、4、8 位数字的分组，各组之间有连线符，dddddddddddd-dddd-dddd-dddd-dddddddd</para>
            <para>- 或 Guid 格式字符串 - </para>
            <para>8、4、4、4 和 12 位数字的分组，各组之间有连线符，dddddddd-dddd-dddd-dddd-dddddddddddd</para>
            </param>
            <param name="sequentialType"></param>
            <param name="result">将包含已分析的值的结构。 如果此方法返回 true，result 包含有效的 CombGuid。 如果此方法返回 false，result 等于 CombGuid.Null。</param>
            <remarks>如果传入的 value 为字节数组时，解析生成的 CombGuid 结构实例将拥有此字节数组。</remarks>
            <returns></returns>
        </member>
        <member name="M:NewLife.CombGuid.op_Implicit(System.Guid)~NewLife.CombGuid">
            <summary>定义从 Guid 对象到 CombGuid 对象的隐式转换。</summary>
            <param name="x">一个 Guid</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.CombGuid.op_Explicit(NewLife.CombGuid)~System.Guid">
            <summary>定义从 CombGuid 对象到 Guid 对象的隐式转换。</summary>
            <param name="x">一个 CombGuid</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.CombGuid.Compare(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>Comparison operators</summary>
            <param name="x"></param>
            <param name="y"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.CombGuid.op_Equality(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>对两个 CombGuid 结构执行逻辑比较，以确定它们是否相等</summary>
            <param name="x">一个 CombGuid 结构</param>
            <param name="y">一个 CombGuid 结构</param>
            <returns>它在两个 CombGuid 结构相等时为 True，在两个实例不等时为 False。</returns>
        </member>
        <member name="M:NewLife.CombGuid.op_Inequality(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>对两个 CombGuid 结构执行逻辑比较，以确定它们是否不相等。</summary>
            <param name="x">一个 CombGuid 结构</param>
            <param name="y">一个 CombGuid 结构</param>
            <returns>它在两个 CombGuid 结构不等时为 True，在两个实例相等时为 False。</returns>
        </member>
        <member name="M:NewLife.CombGuid.op_LessThan(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>对 CombGuid 结构的两个实例进行比较，以确定第一个实例是否小于第二个实例。</summary>
            <param name="x">一个 CombGuid 结构</param>
            <param name="y">一个 CombGuid 结构</param>
            <returns>如果第一个实例小于第二个实例，则它为 True。 否则为 False。</returns>
        </member>
        <member name="M:NewLife.CombGuid.op_GreaterThan(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>对 CombGuid 结构的两个实例进行比较，以确定第一个实例是否大于第二个实例。</summary>
            <param name="x">一个 CombGuid 结构</param>
            <param name="y">一个 CombGuid 结构</param>
            <returns>如果第一个实例大于第二个实例，则它为 True。 否则为 False。</returns>
        </member>
        <member name="M:NewLife.CombGuid.op_LessThanOrEqual(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>对 CombGuid 结构的两个实例进行比较，以确定第一个实例是否小于或等于第二个实例。</summary>
            <param name="x">一个 CombGuid 结构</param>
            <param name="y">一个 CombGuid 结构</param>
            <returns>如果第一个实例小于或等于第二个实例，则它为 True。 否则为 False。</returns>
        </member>
        <member name="M:NewLife.CombGuid.op_GreaterThanOrEqual(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>对 CombGuid 结构的两个实例进行比较，以确定第一个实例是否大于或等于第二个实例。</summary>
            <param name="x">一个 CombGuid 结构</param>
            <param name="y">一个 CombGuid 结构</param>
            <returns>如果第一个实例大于或等于第二个实例，则为 True。 否则为 False。</returns>
        </member>
        <member name="M:NewLife.CombGuid.Equals(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>对两个 CombGuid 结构执行逻辑比较，以确定它们是否相等</summary>
            <param name="x">一个 CombGuid 结构</param>
            <param name="y">一个 CombGuid 结构</param>
            <returns>它在两个 CombGuid 结构相等时为 True，在两个实例不等时为 False。</returns>
        </member>
        <member name="M:NewLife.CombGuid.NotEquals(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>对两个 CombGuid 结构执行逻辑比较，以确定它们是否不相等。</summary>
            <param name="x">一个 CombGuid 结构</param>
            <param name="y">一个 CombGuid 结构</param>
            <returns>它在两个 CombGuid 结构不等时为 True，在两个实例相等时为 False。</returns>
        </member>
        <member name="M:NewLife.CombGuid.LessThan(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>对 CombGuid 结构的两个实例进行比较，以确定第一个实例是否小于第二个实例。</summary>
            <param name="x">一个 CombGuid 结构</param>
            <param name="y">一个 CombGuid 结构</param>
            <returns>如果第一个实例小于第二个实例，则它为 True。 否则为 False。</returns>
        </member>
        <member name="M:NewLife.CombGuid.GreaterThan(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>对 CombGuid 结构的两个实例进行比较，以确定第一个实例是否大于第二个实例。</summary>
            <param name="x">一个 CombGuid 结构</param>
            <param name="y">一个 CombGuid 结构</param>
            <returns>如果第一个实例大于第二个实例，则它为 True。 否则为 False。</returns>
        </member>
        <member name="M:NewLife.CombGuid.LessThanOrEqual(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>对 CombGuid 结构的两个实例进行比较，以确定第一个实例是否小于或等于第二个实例。</summary>
            <param name="x">一个 CombGuid 结构</param>
            <param name="y">一个 CombGuid 结构</param>
            <returns>如果第一个实例小于或等于第二个实例，则它为 True。 否则为 False。</returns>
        </member>
        <member name="M:NewLife.CombGuid.GreaterThanOrEqual(NewLife.CombGuid,NewLife.CombGuid)">
            <summary>对 CombGuid 结构的两个实例进行比较，以确定第一个实例是否大于或等于第二个实例。</summary>
            <param name="x">一个 CombGuid 结构</param>
            <param name="y">一个 CombGuid 结构</param>
            <returns>如果第一个实例大于或等于第二个实例，则为 True。 否则为 False。</returns>
        </member>
        <member name="M:NewLife.CombGuid.Equals(System.Object)">
            <summary>已重载，判断两个 CombGuid 结构是否相等</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.CombGuid.Equals(NewLife.CombGuid)">
            <summary>判断两个 CombGuid 结构是否相等</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.CombGuid.GetHashCode">
            <summary>已重载，获取该 CombGuid 结构的哈希代码</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.CombGuid.IsNull">
            <summary>获取一个布尔值，该值指示此 CombGuid 结构是否为 null。</summary>
        </member>
        <member name="P:NewLife.CombGuid.IsNullOrEmpty">
            <summary>获取一个布尔值，该值指示此 CombGuid 结构值是否为空或其值均为零。</summary>
        </member>
        <member name="M:NewLife.CombGuid.CompareTo(System.Object)">
            <summary>将此 CombGuid 结构与所提供的对象进行比较，并返回其相对值的指示。 不仅仅是比较最后 6 个字节，但会将最后 6 个字节视为比较中最重要的字节。</summary>
            <param name="value">要比较的对象</param>
            <returns>一个有符号的数字，它指示该实例和对象的相对值。
            <para>小于零，此实例小于对象。</para>
            <para>零，此实例等于对象。</para>
            <para>大于零，此实例大于对象；或对象是 null 引用 (Nothing)</para>
            </returns>
        </member>
        <member name="M:NewLife.CombGuid.CompareTo(NewLife.CombGuid)">
            <summary>将此 CombGuid 结构与所提供的 CombGuid 结构进行比较，并返回其相对值的指示。 不仅仅是比较最后 6 个字节，但会将最后 6 个字节视为比较中最重要的字节。</summary>
            <param name="value">要比较的 CombGuid 结构</param>
            <returns>一个有符号的数字，它指示该实例和对象的相对值。
            <para>小于零，此实例小于对象。</para>
            <para>零，此实例等于对象。</para>
            <para>大于零，此实例大于对象；或对象是 null 引用 (Nothing)</para>
            </returns>
        </member>
        <member name="M:NewLife.CombGuid.System#Xml#Serialization#IXmlSerializable#ReadXml(System.Xml.XmlReader)">
            <summary>从 CombGuid 结构的 XML 表示形式生成该对象</summary>
            <param name="reader"></param>
        </member>
        <member name="M:NewLife.CombGuid.System#Xml#Serialization#IXmlSerializable#WriteXml(System.Xml.XmlWriter)">
            <summary>将该 CombGuid 结构转换为其 XML 表示形式</summary>
            <param name="writer"></param>
        </member>
        <member name="M:NewLife.CombGuid.GetXsdType(System.Xml.Schema.XmlSchemaSet)">
            <summary></summary>
            <param name="schemaSet"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.CombGuidSplitPartType">
            <summary>组成 CombGuid 结构字符串四个数据块</summary>
        </member>
        <member name="F:NewLife.CombGuidSplitPartType.PartOne">
            <summary>CombGuid 格式字符串第一部分。</summary>
        </member>
        <member name="F:NewLife.CombGuidSplitPartType.PartTwo">
            <summary>CombGuid 格式字符串第二部分。</summary>
        </member>
        <member name="F:NewLife.CombGuidSplitPartType.PartThree">
            <summary>CombGuid 格式字符串第三部分。</summary>
        </member>
        <member name="F:NewLife.CombGuidSplitPartType.PartFour">
            <summary>CombGuid 格式字符串第四部分。</summary>
        </member>
        <member name="T:NewLife.CombGuidSequentialSegmentType">
            <summary>指示 CombGuid 结构中标识顺序的 6 位字节的位置</summary>
            <remarks>格式化为 CombGuid 格式字节数组，字节数组的排列顺序与传统 GUID 字节数组不同，是为了兼容微软体系数据库与非微软体系数据库进行数据迁移时，
            数据表中的数据保持相同的排序顺序；同时也确保在 .Net FX 中集合的排序规则与数据表的排序规则一致。</remarks>
        </member>
        <member name="F:NewLife.CombGuidSequentialSegmentType.Guid">
            <summary>Guid 格式，顺序字节（6位）在尾部，适用于微软体系数据库。</summary>
        </member>
        <member name="F:NewLife.CombGuidSequentialSegmentType.Comb">
            <summary>CombGuid 格式，顺序字节（6位）在头部，适用于非微软体系数据库。</summary>
        </member>
        <member name="T:NewLife.CombGuidFormatStringType">
            <summary>CombGuid 结构格式化字符串方式</summary>
            <remarks>格式化为 CombGuid 格式字符串时，字符串的排列顺序与传统 GUID 字符串不同，是为了兼容微软体系数据库与非微软体系数据库进行数据迁移时，
            数据表中的数据保持相同的排序顺序；同时也确保在 .Net FX 中集合的排序规则与数据表的排序规则一致。</remarks>
        </member>
        <member name="F:NewLife.CombGuidFormatStringType.Guid">
            <summary>Guid 格式字符串，用一系列指定格式的小写十六进制位表示，由连字符("-")分隔的 32 位数字，这些十六进制位分别以 8 个、4 个、4 个、4 个和 12 个位为一组并由连字符分隔开。
            <para>顺序字节（6位）在尾部，适用于微软体系数据库。</para>
            </summary>
        </member>
        <member name="F:NewLife.CombGuidFormatStringType.Guid32Digits">
            <summary>Guid 格式字符串，用一系列指定格式的小写十六进制位表示，32 位数字，这些十六进制位分别以 8 个、4 个、4 个、4 个和 12 个位为一组合并而成。
            <para>顺序字节（6位）在尾部，适用于微软体系数据库。</para>
            </summary>
        </member>
        <member name="F:NewLife.CombGuidFormatStringType.Comb">
            <summary>CombGuid 格式字符串，用一系列指定格式的小写十六进制位表示，由连字符("-")分隔的 32 位数字，这些十六进制位分别以 12 个和 4 个、4 个、4 个、8 个位为一组并由连字符分隔开。
            <para>顺序字节（6位）在头部，适用于非微软体系数据库。</para>
            </summary>
        </member>
        <member name="F:NewLife.CombGuidFormatStringType.Comb32Digits">
            <summary>CombGuid 格式字符串，用一系列指定格式的小写十六进制位表示，32 位数字，这些十六进制位分别以 12 个和 4 个、4 个、4 个、8 个位为一组合并而成。
            <para>顺序字节（6位）在头部，适用于非微软体系数据库。</para>
            </summary>
        </member>
        <member name="T:NewLife.Common.PinYin">
            <summary>汉字拼音转换类</summary>
        </member>
        <member name="M:NewLife.Common.PinYin.GetFirst(System.Char)">
            <summary>取拼音第一个字段</summary>        
            <param name="ch"></param>        
            <returns></returns>        
        </member>
        <member name="M:NewLife.Common.PinYin.GetFirst(System.String)">
            <summary>取拼音第一个字段</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.PinYin.GetFirstOne(System.String)">
            <summary>取拼音第一个字段</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.PinYin.Get(System.Char)">
            <summary>获取单字拼音</summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.PinYin.GetMulti(System.Char)">
            <summary>获取多音节拼音</summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.PinYin.Get(System.String)">
            <summary>把汉字转换成拼音(全拼)</summary>
            <param name="str">汉字字符串</param>
            <returns>转换后的拼音(全拼)字符串</returns>
        </member>
        <member name="M:NewLife.Common.PinYin.GetPinYinByMS(System.Char)">
            <summary>从微软拼音库获取拼音，包括音调</summary>
            <param name="chr"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Common.SysConfig">
            <summary>系统设置。提供系统名称、版本等基本设置。</summary>
        </member>
        <member name="T:NewLife.Common.SysConfig`1">
            <summary>系统设置。提供系统名称、版本等基本设置。泛型基类，可继承扩展。</summary>
            <typeparam name="TSetting"></typeparam>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.Name">
            <summary>系统名称</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.Version">
            <summary>系统版本</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.DisplayName">
            <summary>显示名称</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.Company">
            <summary>公司</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.Develop">
            <summary>开发者模式</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.Enable">
            <summary>启用</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.InstallTime">
            <summary>安装时间</summary>
        </member>
        <member name="M:NewLife.Common.SysConfig`1.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Common.SysConfig`1.OnNew">
            <summary>新建配置</summary>
        </member>
        <member name="P:NewLife.Common.SysConfig`1.SysAssembly">
            <summary>系统主程序集</summary>
        </member>
        <member name="T:NewLife.Common.IdentityCard">
            <summary>身份证</summary>
        </member>
        <member name="P:NewLife.Common.IdentityCard.Birthday">
            <summary>生日</summary>
        </member>
        <member name="T:NewLife.Common.IdentityCard.SexType">
            <summary>性别</summary>
        </member>
        <member name="F:NewLife.Common.IdentityCard.SexType.Man">
            <summary>男</summary>
        </member>
        <member name="F:NewLife.Common.IdentityCard.SexType.Woman">
            <summary>女</summary>
        </member>
        <member name="P:NewLife.Common.IdentityCard.Sex">
            <summary>性别</summary>
        </member>
        <member name="P:NewLife.Common.IdentityCard.IsOld">
            <summary>是否15位旧卡</summary>
        </member>
        <member name="P:NewLife.Common.IdentityCard.AreaNum">
            <summary>地区编码</summary>
        </member>
        <member name="M:NewLife.Common.IdentityCard.Valid(System.String)">
            <summary>验证身份证是否合法</summary>
            <param name="card"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Common.IdentityCard.Parse(System.String)">
            <summary>使用身份证号码初始化</summary>
            <param name="card"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Runtime">
            <summary>运行时</summary>
        </member>
        <member name="P:NewLife.Runtime.IsConsole">
            <summary>是否控制台。用于判断是否可以执行一些控制台操作。</summary>
        </member>
        <member name="P:NewLife.Runtime.IsWeb">
            <summary>是否Web环境</summary>
        </member>
        <member name="P:NewLife.Runtime.Mono">
            <summary>是否Mono环境</summary>
        </member>
        <member name="P:NewLife.Runtime.Linux">
            <summary>是否Linux环境</summary>
        </member>
        <member name="P:NewLife.Runtime.OSX">
            <summary>是否OSX环境</summary>
        </member>
        <member name="T:NewLife.Compression.SevenZip">
            <summary>7Zip</summary>
        </member>
        <member name="M:NewLife.Compression.SevenZip.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Compression.SevenZip.Compress(System.String,System.String)">
            <summary>压缩文件</summary>
            <param name="path"></param>
            <param name="destFile"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Compression.SevenZip.Extract(System.String,System.String,System.Boolean)">
            <summary>解压缩文件</summary>
            <param name="file"></param>
            <param name="destDir"></param>
            <param name="overwrite">是否覆盖目标同名文件</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Compression.SevenZip.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Compression.SevenZip.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Configuration.CombConfig">
            <summary>CombGuid 配置</summary>
        </member>
        <member name="P:NewLife.Configuration.CombConfig.LastDays">
            <summary>上次系统生成CombGuid时的天数</summary>
        </member>
        <member name="P:NewLife.Configuration.CombConfig.LastTenthMilliseconds">
            <summary>上次系统生成CombGuid时的时间，单位：100纳秒</summary>
        </member>
        <member name="M:NewLife.Configuration.CombConfig.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="T:NewLife.Configuration.Config">
            <summary>通用配置辅助类</summary>
            <remarks>
            一定要注意的是：ConfigurationManager.AppSettings会获取当前应用的设置，如果子目录里面的web.config有设置，则会获取最近的设置。
            </remarks>
        </member>
        <member name="P:NewLife.Configuration.Config.AppSettings">
            <summary>应用设置</summary>
        </member>
        <member name="P:NewLife.Configuration.Config.ConnectionStrings">
            <summary>连接字符串设置</summary>
        </member>
        <member name="M:NewLife.Configuration.Config.Contain(System.String)">
            <summary>是否包含指定项的设置</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetMutilConfig``1(``0,System.String[])">
            <summary>依次尝试获取一批设置项，直到找到第一个为止</summary>
            <typeparam name="T"></typeparam>
            <param name="defaultValue"></param>
            <param name="names"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.TryGetMutilConfig``1(``0@,System.String[])">
            <summary>依次尝试获取一批设置项，直到找到第一个为止</summary>
            <typeparam name="T"></typeparam>
            <param name="value">数值</param>
            <param name="names"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfig``1(System.String)">
            <summary>取得指定名称的设置项，并转为指定类型</summary>
            <typeparam name="T"></typeparam>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfig``1(System.String,``0)">
            <summary>取得指定名称的设置项，并转为指定类型。如果设置不存在，则返回默认值</summary>
            <typeparam name="T"></typeparam>
            <param name="name">名称</param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.TryGetConfig``1(System.String,``0@)">
            <summary>尝试获取指定名称的设置项</summary>
            <typeparam name="T"></typeparam>
            <param name="name">名称</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.TryGetConfig(System.String,System.Type,System.Object@)">
            <summary>尝试获取指定名称的设置项</summary>
            <param name="name">名称</param>
            <param name="type">类型</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfigByPrefix(System.String)">
            <summary>根据指定前缀，获取设置项。其中key不包含前缀</summary>
            <param name="prefix"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfigSplit``1(System.String,System.String)">
            <summary>取得指定名称的设置项，并分割为指定类型数组</summary>
            <typeparam name="T"></typeparam>
            <param name="name">名称</param>
            <param name="split"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.GetConfigSplit``1(System.String,System.String,``0[])">
            <summary>取得指定名称的设置项，并分割为指定类型数组</summary>
            <typeparam name="T"></typeparam>
            <param name="name">名称</param>
            <param name="split"></param>
            <param name="defaultValue"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Configuration.Config.SetConfig``1(System.String,``0)">
            <summary>设置配置文件参数</summary>
            <typeparam name="T"></typeparam>
            <param name="name">名称</param>
            <param name="defaultValue"></param>
        </member>
        <member name="M:NewLife.Configuration.Config.SetConfig(System.String,System.String)">
            <summary>设置配置文件参数</summary>
            <param name="name">名称</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Configuration.Config.AppSettingsKeyExists(System.String,System.Configuration.Configuration)">
            <summary>判断appSettings中是否有此项</summary>
        </member>
        <member name="M:NewLife.Configuration.Config.UpdateConfig(System.String,System.String)">
            <summary>设置配置文件参数</summary>
            <param name="name">名称</param>
            <param name="value">数值</param>
        </member>
        <member name="T:NewLife.Data.BinaryTree">
            <summary>二叉树</summary>
        </member>
        <member name="M:NewLife.Data.BinaryTree.GetAll(System.Int32)">
            <summary>遍历所有二叉树</summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.BinaryTree.Build(NewLife.Data.BinaryTree.Node,System.Double[],System.Collections.Generic.List{System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression}},System.Collections.Generic.List{System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression}})">
            <summary>构建表达式树</summary>
            <param name="node"></param>
            <param name="numbers"></param>
            <param name="ops"></param>
            <param name="sops"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.BinaryTree.FullPermute``1(``0[])">
            <summary>遍历全排列</summary>
            <typeparam name="T"></typeparam>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.BinaryTree.OperatorPermute(System.Collections.Generic.List{System.Func{System.Linq.Expressions.Expression,System.Linq.Expressions.Expression,System.Linq.Expressions.Expression}},System.Int32)">
            <summary>从4种运算符中挑选3个运算符</summary>
            <param name="operators"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.BinaryTree.Cbrt(System.Double)">
            <summary>立方根</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.BinaryTree.Execute(System.Double[],System.Double)">
            <summary>数学运算</summary>
            <param name="numbers"></param>
            <param name="result"></param>
        </member>
        <member name="T:NewLife.Data.DbRow">
            <summary>数据行</summary>
        </member>
        <member name="P:NewLife.Data.DbRow.Table">
            <summary>数据表</summary>
        </member>
        <member name="P:NewLife.Data.DbRow.Index">
            <summary>行索引</summary>
        </member>
        <member name="M:NewLife.Data.DbRow.#ctor(NewLife.Data.DbTable,System.Int32)">
            <summary>构造数据行</summary>
            <param name="table"></param>
            <param name="index"></param>
        </member>
        <member name="P:NewLife.Data.DbRow.Item(System.Int32)">
            <summary>基于列索引访问</summary>
            <param name="column"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Data.DbRow.Item(System.String)">
            <summary>基于列名访问</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbRow.Get``1(System.String)">
            <summary>读取指定行的字段值</summary>
            <typeparam name="T"></typeparam>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.DbTable">
            <summary>数据表</summary>
        </member>
        <member name="P:NewLife.Data.DbTable.Columns">
            <summary>数据列</summary>
        </member>
        <member name="P:NewLife.Data.DbTable.Types">
            <summary>数据列类型</summary>
        </member>
        <member name="P:NewLife.Data.DbTable.Rows">
            <summary>数据行</summary>
        </member>
        <member name="M:NewLife.Data.DbTable.Read(System.Data.IDataReader)">
            <summary>读取数据</summary>
            <param name="dr"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.Read(System.IO.Stream)">
            <summary>从数据流读取</summary>
            <param name="ms"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.Write(System.IO.Stream)">
            <summary>写入数据流</summary>
            <param name="ms"></param>
        </member>
        <member name="M:NewLife.Data.DbTable.Read(NewLife.Data.Packet)">
            <summary>读取</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.ToPacket">
            <summary>转数据包</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.Get``1(System.Int32,System.String)">
            <summary>读取指定行的字段值</summary>
            <typeparam name="T"></typeparam>
            <param name="row"></param>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.TryGet``1(System.Int32,System.String,``0@)">
            <summary>尝试读取指定行的字段值</summary>
            <typeparam name="T"></typeparam>
            <param name="row"></param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.GetColumn(System.String)">
            <summary>根据名称找字段序号</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.ToString">
            <summary>数据集</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.DbTable.GetEnumerator">
            <summary>获取枚举</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.GeoArea">
            <summary>地理区域</summary>
        </member>
        <member name="P:NewLife.Data.GeoArea.Code">
            <summary>编码</summary>
        </member>
        <member name="P:NewLife.Data.GeoArea.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Data.GeoArea.ParentCode">
            <summary>父级</summary>
        </member>
        <member name="P:NewLife.Data.GeoArea.Center">
            <summary>中心</summary>
        </member>
        <member name="P:NewLife.Data.GeoArea.Polyline">
            <summary>边界</summary>
        </member>
        <member name="P:NewLife.Data.GeoArea.Level">
            <summary>级别</summary>
        </member>
        <member name="M:NewLife.Data.GeoArea.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.GeoAddress">
            <summary>地理地址</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Location">
            <summary>坐标</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Address">
            <summary>地址</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Code">
            <summary>行政区域编码</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Country">
            <summary>国家</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Province">
            <summary>省份</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.City">
            <summary>城市</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.District">
            <summary>区县</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Township">
            <summary>乡镇</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Towncode">
            <summary>乡镇编码</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Street">
            <summary>街道</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.StreetNumber">
            <summary></summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Level">
            <summary>级别</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Precise">
            <summary>精确打点</summary>
        </member>
        <member name="P:NewLife.Data.GeoAddress.Confidence">
            <summary>可信度。[0-100]</summary>
        </member>
        <member name="M:NewLife.Data.GeoAddress.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.GeoPoint">
            <summary>经纬度坐标</summary>
        </member>
        <member name="P:NewLife.Data.GeoPoint.Longitude">
            <summary>经度</summary>
        </member>
        <member name="P:NewLife.Data.GeoPoint.Latitude">
            <summary>纬度</summary>
        </member>
        <member name="M:NewLife.Data.GeoPoint.#ctor">
            <summary>经纬度坐标</summary>
        </member>
        <member name="M:NewLife.Data.GeoPoint.#ctor(System.String)">
            <summary>经纬度坐标</summary>
            <param name="location"></param>
        </member>
        <member name="M:NewLife.Data.GeoPoint.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.IData">
            <summary>数据帧接口</summary>
        </member>
        <member name="P:NewLife.Data.IData.Packet">
            <summary>数据包</summary>
        </member>
        <member name="P:NewLife.Data.IData.Remote">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Data.IData.Message">
            <summary>消息</summary>
        </member>
        <member name="P:NewLife.Data.IData.UserState">
            <summary>用户数据</summary>
        </member>
        <member name="T:NewLife.Data.IExtend">
            <summary>具有扩展数据的接口</summary>
        </member>
        <member name="P:NewLife.Data.IExtend.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Data.IExtend.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.IFilter">
            <summary>数据过滤器</summary>
        </member>
        <member name="P:NewLife.Data.IFilter.Next">
            <summary>下一个过滤器</summary>
        </member>
        <member name="M:NewLife.Data.IFilter.Execute(NewLife.Data.FilterContext)">
            <summary>对封包执行过滤器</summary>
            <param name="context"></param>
        </member>
        <member name="T:NewLife.Data.FilterContext">
            <summary>过滤器上下文</summary>
        </member>
        <member name="P:NewLife.Data.FilterContext.Packet">
            <summary>封包</summary>
        </member>
        <member name="T:NewLife.Data.FilterHelper">
            <summary>过滤器助手</summary>
        </member>
        <member name="M:NewLife.Data.FilterHelper.Find(NewLife.Data.IFilter,System.Type)">
            <summary>在链条里面查找指定类型的过滤器</summary>
            <param name="filter"></param>
            <param name="filterType"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.FilterBase">
            <summary>数据过滤器基类</summary>
        </member>
        <member name="P:NewLife.Data.FilterBase.Next">
            <summary>下一个过滤器</summary>
        </member>
        <member name="M:NewLife.Data.FilterBase.Execute(NewLife.Data.FilterContext)">
            <summary>对封包执行过滤器</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Data.FilterBase.OnExecute(NewLife.Data.FilterContext)">
            <summary>执行过滤</summary>
            <param name="context"></param>
            <returns>返回是否执行下一个过滤器</returns>
        </member>
        <member name="T:NewLife.Data.Packet">
            <summary>数据包</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Data">
            <summary>数据</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Offset">
            <summary>偏移</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Count">
            <summary>长度</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Next">
            <summary>下一个链式包</summary>
        </member>
        <member name="P:NewLife.Data.Packet.Total">
            <summary>总长度</summary>
        </member>
        <member name="M:NewLife.Data.Packet.#ctor(System.Byte[],System.Int32,System.Int32)">
            <summary>根据数据区实例化</summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.Data.Packet.#ctor(System.ArraySegment{System.Byte})">
            <summary>根据数组段实例化</summary>
            <param name="seg"></param>
        </member>
        <member name="M:NewLife.Data.Packet.#ctor(System.IO.Stream)">
            <summary>从可扩展内存流实例化</summary>
            <param name="stream"></param>
        </member>
        <member name="P:NewLife.Data.Packet.Item(System.Int32)">
            <summary>获取/设置 指定位置的字节</summary>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.Set(System.Byte[],System.Int32,System.Int32)">
            <summary>设置新的数据区</summary>
            <param name="data">数据区</param>
            <param name="offset">偏移</param>
            <param name="count">字节个数</param>
        </member>
        <member name="M:NewLife.Data.Packet.Slice(System.Int32,System.Int32)">
            <summary>截取子数据区</summary>
            <param name="offset">相对偏移</param>
            <param name="count">字节个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.IndexOf(System.Byte[],System.Int32,System.Int32)">
            <summary>查找目标数组</summary>
            <param name="data">目标数组</param>
            <param name="offset">本数组起始偏移</param>
            <param name="count">本数组搜索个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.Append(NewLife.Data.Packet)">
            <summary>附加一个包到当前包链的末尾</summary>
            <param name="pk"></param>
        </member>
        <member name="M:NewLife.Data.Packet.ToArray">
            <summary>返回字节数组。如果是完整数组直接返回，否则截取</summary>
            <remarks>不一定是全新数据，如果需要全新数据请克隆</remarks>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ReadBytes(System.Int32,System.Int32)">
            <summary>从封包中读取指定数据</summary>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToSegment">
            <summary>返回数据段</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.GetStream">
            <summary>获取封包的数据流形式</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.WriteTo(System.IO.Stream)">
            <summary>把封包写入到数据流</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Data.Packet.WriteTo(System.Byte[],System.Int32,System.Int32)">
            <summary>把封包写入到目标数组</summary>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
        </member>
        <member name="M:NewLife.Data.Packet.CopyToAsync(System.IO.Stream)">
            <summary>异步复制到目标数据流</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.Clone">
            <summary>深度克隆一份数据包，拷贝数据区</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToStr(System.Text.Encoding,System.Int32,System.Int32)">
            <summary>以字符串表示</summary>
            <param name="encoding">字符串编码，默认URF-8</param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToHex(System.Int32,System.String,System.Int32)">
            <summary>以十六进制编码表示</summary>
            <param name="maxLength">最大显示多少个字节。默认-1显示全部</param>
            <param name="separate">分隔符</param>
            <param name="groupSize">分组大小，为0时对每个字节应用分隔符，否则对每个分组使用</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.op_Implicit(System.Byte[])~NewLife.Data.Packet">
            <summary>重载类型转换，字节数组直接转为Packet对象</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.op_Implicit(System.ArraySegment{System.Byte})~NewLife.Data.Packet">
            <summary>重载类型转换，一维数组直接转为Packet对象</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.Packet.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Data.PageParameter">
            <summary>分页参数信息</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.Sort">
            <summary>获取 或 设置 排序字段，前台接收，便于做安全性校验</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.Desc">
            <summary>获取 或 设置 是否降序</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.PageIndex">
            <summary>获取 或 设置 页面索引。从1开始，默认1</summary>
            <remarks>如果设定了开始行，分页时将不再使用PageIndex</remarks>
        </member>
        <member name="P:NewLife.Data.PageParameter.PageSize">
            <summary>获取 或 设置 页面大小。默认20，若为0表示不分页</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.TotalCount">
            <summary>获取 或 设置 总记录数</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.PageCount">
            <summary>获取 页数</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.OrderBy">
            <summary>获取 或 设置 组合起来的排序字句。如果没有设置则取Sort+Desc，后台设置，不经过安全性校验</summary>
        </member>
        <member name="P:NewLife.Data.PageParameter.StartRow">
            <summary>获取 或 设置 开始行</summary>
            <remarks>如果设定了开始行，分页时将不再使用PageIndex</remarks>
        </member>
        <member name="P:NewLife.Data.PageParameter.RetrieveTotalCount">
            <summary>获取 或 设置 是否获取总记录数</summary>
        </member>
        <member name="M:NewLife.Data.PageParameter.#ctor">
            <summary>实例化分页参数</summary>
        </member>
        <member name="M:NewLife.Data.PageParameter.#ctor(NewLife.Data.PageParameter)">
            <summary>通过另一个分页参数来实例化当前分页参数</summary>
            <param name="pm"></param>
        </member>
        <member name="M:NewLife.Data.PageParameter.CopyFrom(NewLife.Data.PageParameter)">
            <summary>从另一个分页参数拷贝到当前分页参数</summary>
            <param name="pm"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Data.PageParameter.GetKey">
            <summary>获取表示分页参数唯一性的键值，可用作缓存键</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Extension.SpeakProvider.CheckVoice">
            <summary>检查是否安装了语音库</summary>
        </member>
        <member name="T:NewLife.Http.HttpBase">
            <summary>Http请求响应基类</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.ContentLength">
            <summary>内容长度</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.ContentType">
            <summary>内容类型</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.Headers">
            <summary>头部集合</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.Item(System.String)">
            <summary>获取/设置 头部</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Http.HttpBase.Expire">
            <summary>过期时间</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.IsCompleted">
            <summary>是否已完整</summary>
        </member>
        <member name="P:NewLife.Http.HttpBase.BodyLength">
            <summary>主体长度</summary>
        </member>
        <member name="M:NewLife.Http.HttpBase.OnParse(System.String)">
            <summary>分析第一行</summary>
            <param name="firstLine"></param>
        </member>
        <member name="M:NewLife.Http.HttpBase.Build(NewLife.Data.Packet)">
            <summary>创建请求响应包</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpBase.BuildHeader(System.Int32)">
            <summary>创建头部</summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpCodec">
            <summary>Http编解码器</summary>
        </member>
        <member name="T:NewLife.Http.HttpHelper">
            <summary>Http帮助类</summary>
        </member>
        <member name="M:NewLife.Http.HttpHelper.MakeRequest(System.String,System.Uri,System.Collections.Generic.IDictionary{System.String,System.Object},NewLife.Data.Packet)">
            <summary>创建请求包</summary>
            <param name="method"></param>
            <param name="uri"></param>
            <param name="headers"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.MakeResponse(System.Net.HttpStatusCode,System.Collections.Generic.IDictionary{System.String,System.Object},NewLife.Data.Packet)">
            <summary>创建响应包</summary>
            <param name="code"></param>
            <param name="headers"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.ParseHeader(NewLife.Data.Packet)">
            <summary>分析头部</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.MakeHandshake(NewLife.Http.HttpRequest)">
            <summary>建立握手包</summary>
            <param name="request"></param>
        </member>
        <member name="M:NewLife.Http.HttpHelper.Handshake(System.String,NewLife.Http.HttpResponse)">
            <summary>握手</summary>
            <param name="key"></param>
            <param name="response"></param>
        </member>
        <member name="M:NewLife.Http.HttpHelper.ParseWS(NewLife.Data.Packet)">
            <summary>分析WS数据包</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpHelper.MakeWS(NewLife.Data.Packet)">
            <summary>创建WS请求包</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpRequest">
            <summary>Http请求</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.Method">
            <summary>Http方法</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.Url">
            <summary>资源路径</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.UserAgent">
            <summary>用户代理</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.Compressed">
            <summary>是否压缩</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.KeepAlive">
            <summary>保持连接</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.Accept">
            <summary>可接受内容</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.AcceptLanguage">
            <summary>接受语言</summary>
        </member>
        <member name="P:NewLife.Http.HttpRequest.Referer">
            <summary>引用路径</summary>
        </member>
        <member name="M:NewLife.Http.HttpRequest.OnParse(System.String)">
            <summary>分析第一行</summary>
            <param name="firstLine"></param>
        </member>
        <member name="M:NewLife.Http.HttpRequest.BuildHeader(System.Int32)">
            <summary>创建头部</summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Http.HttpResponse">
            <summary>Http响应</summary>
        </member>
        <member name="P:NewLife.Http.HttpResponse.IsSSL">
            <summary>是否启用SSL</summary>
        </member>
        <member name="P:NewLife.Http.HttpResponse.StatusCode">
            <summary>状态码</summary>
        </member>
        <member name="P:NewLife.Http.HttpResponse.StatusDescription">
            <summary>状态描述</summary>
        </member>
        <member name="M:NewLife.Http.HttpResponse.OnParse(System.String)">
            <summary>分析第一行</summary>
            <param name="firstLine"></param>
        </member>
        <member name="M:NewLife.Http.HttpResponse.BuildHeader(System.Int32)">
            <summary>创建头部</summary>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.HttpResponse.Valid">
            <summary>验证，如果失败则抛出异常</summary>
        </member>
        <member name="T:NewLife.Http.HttpServer">
            <summary>Http服务器</summary>
        </member>
        <member name="M:NewLife.Http.HttpServer.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="T:NewLife.Http.TinyHttpClient">
            <summary>迷你Http客户端。不支持https和302跳转</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.Client">
            <summary>客户端</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.ContentType">
            <summary>内容类型</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.ContentLength">
            <summary>内容长度</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.KeepAlive">
            <summary>保持连接</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.StatusCode">
            <summary>状态码</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.Timeout">
            <summary>超时时间。默认15000ms</summary>
        </member>
        <member name="P:NewLife.Http.TinyHttpClient.Headers">
            <summary>头部集合</summary>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.SendDataAsync(NewLife.Net.NetUri,NewLife.Data.Packet)">
            <summary>异步请求</summary>
            <param name="remote"></param>
            <param name="request"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.SendAsync(System.String,System.Byte[])">
            <summary>异步发出请求，并接收响应</summary>
            <param name="url"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.BuildRequest(System.Uri,System.Byte[])">
            <summary>构造请求头</summary>
            <param name="uri"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.ParseResponse(NewLife.Data.Packet)">
            <summary>解析响应</summary>
            <param name="rs"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Http.TinyHttpClient.GetAsync(System.String)">
            <summary>异步获取</summary>
            <param name="url">地址</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.IO.EncodingHelper">
            <summary>编码助手</summary>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.Detect(System.String)">
            <summary>检测文件编码</summary>
            <param name="filename">文件名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.DetectEncoding(System.IO.FileInfo)">
            <summary>检测文件编码</summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.Detect(System.IO.Stream,System.Int64)">
            <summary>检测数据流编码</summary>
            <param name="stream">数据流</param>
            <param name="sampleSize">BOM检测失败时用于启发式探索的数据大小</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.Detect(System.Byte[])">
            <summary>检测字节数组编码</summary>
            <param name="data">字节数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.DetectBOM(System.Byte[])">
            <summary>检测BOM字节序</summary>
            <param name="boms"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.DetectASCII(System.Byte[])">
            <summary>检测是否ASCII</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.DetectUnicode(System.Byte[])">
            <summary>启发式探测Unicode编码</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.IsCommonASCII(System.Byte)">
            <summary>是否可见ASCII</summary>
            <param name="bt"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.IO.EncodingHelper.DetectSuspiciousUTF8SequenceLength(System.Byte[],System.Int64)">
            <summary>检测可能的UTF8序列长度</summary>
            <param name="buf"></param>
            <param name="pos"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.IO.FileSource">
            <summary>文件资源</summary>
        </member>
        <member name="M:NewLife.IO.FileSource.ReleaseFile(System.Reflection.Assembly,System.String,System.String,System.Boolean)">
            <summary>释放文件</summary>
            <param name="asm"></param>
            <param name="fileName"></param>
            <param name="destFile"></param>
            <param name="overWrite"></param>
        </member>
        <member name="M:NewLife.IO.FileSource.ReleaseFolder(System.Reflection.Assembly,System.String,System.String,System.Boolean)">
            <summary>释放文件夹</summary>
            <param name="asm"></param>
            <param name="prefix"></param>
            <param name="dest"></param>
            <param name="overWrite"></param>
        </member>
        <member name="M:NewLife.IO.FileSource.ReleaseFolder(System.Reflection.Assembly,System.String,System.String,System.Boolean,System.Func{System.String,System.String})">
            <summary>释放文件夹</summary>
            <param name="asm"></param>
            <param name="prefix"></param>
            <param name="dest"></param>
            <param name="overWrite"></param>
            <param name="filenameResolver"></param>
        </member>
        <member name="M:NewLife.IO.FileSource.GetFileResource(System.Reflection.Assembly,System.String)">
            <summary>获取文件资源</summary>
            <param name="asm"></param>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Json.JsonConfig`1">
            <summary>Json配置文件基类</summary>
            <remarks>
            标准用法：TConfig.Current
            
            配置实体类通过<see cref="T:NewLife.Json.JsonConfigFileAttribute"/>特性指定配置文件路径以及自动更新时间。
            Current将加载配置文件，如果文件不存在或者加载失败，将实例化一个对象返回。
            
            考虑到自动刷新，不提供LoadFile和SaveFile等方法，可通过扩展方法ToXmlFileEntity和ToXmlFile实现。
            
            用户也可以通过配置实体类的静态构造函数修改基类的<see cref="P:NewLife.Json.JsonConfig`1._.ConfigFile"/>和<see cref="P:NewLife.Json.JsonConfig`1._.ReloadTime"/>来动态配置加载信息。
            </remarks>
            <typeparam name="TConfig"></typeparam>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1.Current">
            <summary>当前实例。通过置空可以使其重新加载。</summary>
        </member>
        <member name="T:NewLife.Json.JsonConfig`1._">
            <summary>一些设置。派生类可以在自己的静态构造函数中指定</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1._.Debug">
            <summary>是否调试</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1._.ConfigFile">
            <summary>配置文件路径</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1._.ReloadTime">
            <summary>重新加载时间。单位：毫秒</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1._.SaveNew">
            <summary>没有配置文件时是否保存新配置。默认true</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1.ConfigFile">
            <summary>配置文件</summary>
        </member>
        <member name="F:NewLife.Json.JsonConfig`1.lastWrite">
            <summary>最后写入时间</summary>
        </member>
        <member name="F:NewLife.Json.JsonConfig`1.expire">
            <summary>过期时间。如果在这个时间之后再次访问，将检查文件修改时间</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1.IsUpdated">
            <summary>是否已更新。通过文件写入时间判断</summary>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.SetExpire">
            <summary>设置过期重新加载配置的时间</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfig`1.IsNew">
            <summary>是否新的配置文件</summary>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.Load(System.String)">
            <summary>加载指定配置文件</summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.OnLoaded">
            <summary>从配置文件中读取完成后触发</summary>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.Save(System.String)">
            <summary>保存到配置文件中去</summary>
            <param name="filename"></param>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.Save">
            <summary>保存到配置文件中去</summary>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.SaveAsync">
            <summary>异步保存</summary>
        </member>
        <member name="M:NewLife.Json.JsonConfig`1.OnNew">
            <summary>新创建配置文件时执行</summary>
        </member>
        <member name="T:NewLife.Json.JsonConfigFileAttribute">
            <summary>Json配置文件特性</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfigFileAttribute.FileName">
            <summary>配置文件名</summary>
        </member>
        <member name="P:NewLife.Json.JsonConfigFileAttribute.ReloadTime">
            <summary>重新加载时间。单位：毫秒</summary>
        </member>
        <member name="M:NewLife.Json.JsonConfigFileAttribute.#ctor(System.String)">
            <summary>指定配置文件名</summary>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Json.JsonConfigFileAttribute.#ctor(System.String,System.Int32)">
            <summary>指定配置文件名和重新加载时间（毫秒）</summary>
            <param name="fileName"></param>
            <param name="reloadTime"></param>
        </member>
        <member name="T:NewLife.Log.ActionLog">
            <summary>依托于动作的日志类</summary>
        </member>
        <member name="P:NewLife.Log.ActionLog.Method">
            <summary>方法</summary>
        </member>
        <member name="M:NewLife.Log.ActionLog.#ctor(System.Action{System.String,System.Object[]})">
            <summary>使用指定方法否则动作日志</summary>
            <param name="action"></param>
        </member>
        <member name="M:NewLife.Log.ActionLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.ActionLog.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.CompositeLog">
            <summary>复合日志提供者，多种方式输出</summary>
        </member>
        <member name="P:NewLife.Log.CompositeLog.Logs">
            <summary>日志提供者集合</summary>
        </member>
        <member name="M:NewLife.Log.CompositeLog.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Log.CompositeLog.#ctor(NewLife.Log.ILog)">
            <summary>实例化</summary>
            <param name="log"></param>
        </member>
        <member name="M:NewLife.Log.CompositeLog.#ctor(NewLife.Log.ILog,NewLife.Log.ILog)">
            <summary>实例化</summary>
            <param name="log1"></param>
            <param name="log2"></param>
        </member>
        <member name="M:NewLife.Log.CompositeLog.Add(NewLife.Log.ILog)">
            <summary>添加一个日志提供者</summary>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CompositeLog.Remove(NewLife.Log.ILog)">
            <summary>删除日志提供者</summary>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CompositeLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.CompositeLog.Get``1">
            <summary>从复合日志提供者中提取指定类型的日志提供者</summary>
            <typeparam name="TLog"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CompositeLog.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.ConsoleLog">
            <summary>控制台输出日志</summary>
        </member>
        <member name="P:NewLife.Log.ConsoleLog.UseColor">
            <summary>是否使用多种颜色，默认使用</summary>
        </member>
        <member name="M:NewLife.Log.ConsoleLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.ConsoleLog.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.ICounter">
            <summary>性能计数器接口</summary>
        </member>
        <member name="P:NewLife.Log.ICounter.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Log.ICounter.Times">
            <summary>次数</summary>
        </member>
        <member name="P:NewLife.Log.ICounter.Speed">
            <summary>速度</summary>
        </member>
        <member name="P:NewLife.Log.ICounter.Cost">
            <summary>平均耗时，单位us</summary>
        </member>
        <member name="M:NewLife.Log.ICounter.Increment(System.Int64,System.Int64)">
            <summary>增加</summary>
            <param name="value">增加的数量</param>
            <param name="usCost">耗时，单位us</param>
        </member>
        <member name="T:NewLife.Log.CounterHelper">
            <summary>计数器助手</summary>
        </member>
        <member name="M:NewLife.Log.CounterHelper.StartCount(NewLife.Log.ICounter)">
            <summary>开始计时</summary>
            <param name="counter"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CounterHelper.StopCount(NewLife.Log.ICounter,System.Int64)">
            <summary>结束计时</summary>
            <param name="counter"></param>
            <param name="startTicks"></param>
        </member>
        <member name="T:NewLife.Log.ILog">
            <summary>日志接口</summary>
        </member>
        <member name="M:NewLife.Log.ILog.Write(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level">日志级别</param>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Debug(System.String,System.Object[])">
            <summary>调试日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Info(System.String,System.Object[])">
            <summary>信息日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Warn(System.String,System.Object[])">
            <summary>警告日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Error(System.String,System.Object[])">
            <summary>错误日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.ILog.Fatal(System.String,System.Object[])">
            <summary>严重错误日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="P:NewLife.Log.ILog.Enable">
            <summary>是否启用日志</summary>
        </member>
        <member name="P:NewLife.Log.ILog.Level">
            <summary>日志等级，只输出大于等于该级别的日志，默认Info，打开NewLife.Debug时默认为最低的Debug</summary>
        </member>
        <member name="T:NewLife.Log.Logger">
            <summary>日志基类。提供日志的基本实现</summary>
        </member>
        <member name="M:NewLife.Log.Logger.Debug(System.String,System.Object[])">
            <summary>调试日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Info(System.String,System.Object[])">
            <summary>信息日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Warn(System.String,System.Object[])">
            <summary>警告日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Error(System.String,System.Object[])">
            <summary>错误日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Fatal(System.String,System.Object[])">
            <summary>严重错误日志</summary>
            <param name="format">格式化字符串</param>
            <param name="args">格式化参数</param>
        </member>
        <member name="M:NewLife.Log.Logger.Write(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.Logger.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.Logger.Format(System.String,System.Object[])">
            <summary>格式化参数，特殊处理异常和时间</summary>
            <param name="format"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.Logger.Enable">
            <summary>是否启用日志。默认true</summary>
        </member>
        <member name="P:NewLife.Log.Logger.Level">
            <summary>日志等级，只输出大于等于该级别的日志，默认Info，打开NewLife.Debug时默认为最低的Debug</summary>
        </member>
        <member name="P:NewLife.Log.Logger.Null">
            <summary>空日志实现</summary>
        </member>
        <member name="M:NewLife.Log.Logger.GetHead">
            <summary>输出日志头，包含所有环境信息</summary>
        </member>
        <member name="T:NewLife.Log.LogLevel">
            <summary>日志等级</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.All">
            <summary>打开所有日志记录</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Debug">
            <summary>最低调试。细粒度信息事件对调试应用程序非常有帮助</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Info">
            <summary>普通消息。在粗粒度级别上突出强调应用程序的运行过程</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Warn">
            <summary>警告</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Error">
            <summary>错误</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Fatal">
            <summary>严重错误</summary>
        </member>
        <member name="F:NewLife.Log.LogLevel.Off">
            <summary>关闭所有日志记录</summary>
        </member>
        <member name="T:NewLife.Log.NetworkLog">
            <summary>网络日志</summary>
        </member>
        <member name="P:NewLife.Log.NetworkLog.Client">
            <summary>网络套接字</summary>
        </member>
        <member name="P:NewLife.Log.NetworkLog.Remote">
            <summary>远程服务器地址</summary>
        </member>
        <member name="M:NewLife.Log.NetworkLog.#ctor">
            <summary>实例化网络日志。默认广播到514端口</summary>
        </member>
        <member name="M:NewLife.Log.NetworkLog.#ctor(System.Net.IPEndPoint)">
            <summary>指定日志服务器地址来实例化网络日志</summary>
            <param name="server"></param>
        </member>
        <member name="M:NewLife.Log.NetworkLog.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="M:NewLife.Log.NetworkLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Log.PerfCounter">
            <summary>性能计数器。次数、TPS、平均耗时</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Enable">
            <summary>是否启用。默认true</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Value">
            <summary>数值</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Times">
            <summary>次数</summary>
        </member>
        <member name="F:NewLife.Log.PerfCounter._TotalCost">
            <summary>耗时，单位us</summary>
        </member>
        <member name="M:NewLife.Log.PerfCounter.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Log.PerfCounter.Increment(System.Int64,System.Int64)">
            <summary>增加</summary>
            <param name="value">增加的数量</param>
            <param name="usCost">耗时，单位us</param>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Interval">
            <summary>采样间隔，默认1000毫秒</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Duration">
            <summary>持续采样时间，默认60秒</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Speed">
            <summary>当前速度</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.MaxSpeed">
            <summary>最大速度</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.Cost">
            <summary>最后一个采样周期的平均耗时，单位us</summary>
        </member>
        <member name="P:NewLife.Log.PerfCounter.MaxCost">
            <summary>持续采样时间内的最大平均耗时，单位us</summary>
        </member>
        <member name="M:NewLife.Log.PerfCounter.DoWork(System.Object)">
            <summary>定期采样，保存最近60组到数组队列里面</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Log.PerfCounter.ToString">
            <summary>已重载。输出统计信息</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.TextControlLog">
            <summary>文本控件输出日志</summary>
        </member>
        <member name="P:NewLife.Log.TextControlLog.Control">
            <summary>文本控件</summary>
        </member>
        <member name="P:NewLife.Log.TextControlLog.MaxLines">
            <summary>最大行数，超过该行数讲清空文本控件。默认1000行</summary>
        </member>
        <member name="M:NewLife.Log.TextControlLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.TextControlLog.WriteLog(System.Windows.Forms.Control,System.String,System.Int32)">
            <summary>在WinForm控件上输出日志，主要考虑非UI线程操作</summary>
            <remarks>不是常用功能，为了避免干扰常用功能，保持UseWinForm开头</remarks>
            <param name="control">要绑定日志输出的WinForm控件</param>
            <param name="msg">日志</param>
            <param name="maxLines">最大行数</param>
        </member>
        <member name="T:NewLife.Log.TimeCost">
            <summary>统计代码的时间消耗</summary>
        </member>
        <member name="P:NewLife.Log.TimeCost.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Log.TimeCost.Max">
            <summary>最大时间。毫秒</summary>
        </member>
        <member name="P:NewLife.Log.TimeCost.Log">
            <summary>日志输出</summary>
        </member>
        <member name="M:NewLife.Log.TimeCost.#ctor(System.String,System.Int32)">
            <summary>指定最大执行时间来构造一个代码时间统计</summary>
            <param name="name"></param>
            <param name="msMax"></param>
        </member>
        <member name="M:NewLife.Log.TimeCost.OnDispose(System.Boolean)">
            <summary>析构</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Log.TimeCost.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Log.TimeCost.Stop">
            <summary>停止</summary>
        </member>
        <member name="T:NewLife.Log.TraceStream">
            <summary>跟踪流。包装一个基础数据流，主要用于重写Read/Write等行为，跟踪程序操作数据流的过程</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.BaseStream">
            <summary>基础流</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.TraceMembers">
            <summary>跟踪的成员</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.IsLittleEndian">
            <summary>是否小端字节序。x86系列则采用Little-Endian方式存储数据；网络协议都是Big-Endian；</summary>
            <remarks>
            网络协议都是Big-Endian；
            Java编译的都是Big-Endian；
            Motorola的PowerPC是Big-Endian；
            x86系列则采用Little-Endian方式存储数据；
            ARM同时支持 big和little，实际应用中通常使用Little-Endian。
            </remarks>
        </member>
        <member name="P:NewLife.Log.TraceStream.ShowPositionStep">
            <summary>显示位置的步长，位移超过此长度后输出位置。默认16，设为0不输出位置</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>写入</summary>
            <param name="buffer">缓冲区</param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Log.TraceStream.WriteByte(System.Byte)">
            <summary>写入一个字节</summary>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Log.TraceStream.Read(System.Byte[],System.Int32,System.Int32)">
            <summary>读取</summary>
            <param name="buffer">缓冲区</param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.ReadByte">
            <summary>读取一个字节</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.BeginRead(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>异步开始读</summary>
            <param name="buffer">缓冲区</param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.BeginWrite(System.Byte[],System.Int32,System.Int32,System.AsyncCallback,System.Object)">
            <summary>异步开始写</summary>
            <param name="buffer">缓冲区</param>
            <param name="offset">偏移</param>
            <param name="count">数量</param>
            <param name="callback"></param>
            <param name="state"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.EndRead(System.IAsyncResult)">
            <summary>异步读结束</summary>
            <param name="asyncResult"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.EndWrite(System.IAsyncResult)">
            <summary>异步写结束</summary>
            <param name="asyncResult"></param>
        </member>
        <member name="M:NewLife.Log.TraceStream.Seek(System.Int64,System.IO.SeekOrigin)">
            <summary>设置流位置</summary>
            <param name="offset">偏移</param>
            <param name="origin"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TraceStream.Close">
            <summary>关闭数据流</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.Flush">
            <summary>刷新缓冲区</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.SetLength(System.Int64)">
            <summary>设置长度</summary>
            <param name="value">数值</param>
        </member>
        <member name="P:NewLife.Log.TraceStream.CanRead">
            <summary>可读</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.CanSeek">
            <summary>可搜索</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.CanTimeout">
            <summary>可超时</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.CanWrite">
            <summary>可写</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.ReadTimeout">
            <summary>可读</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.WriteTimeout">
            <summary>读写超时</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.Length">
            <summary>长度</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.Position">
            <summary>位置</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.#ctor">
            <summary>实例化跟踪流</summary>
        </member>
        <member name="M:NewLife.Log.TraceStream.#ctor(System.IO.Stream)">
            <summary>实例化跟踪流</summary>
            <param name="stream"></param>
        </member>
        <member name="E:NewLife.Log.TraceStream.OnAction">
            <summary>操作时触发</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.UseConsole">
            <summary>是否使用控制台</summary>
        </member>
        <member name="P:NewLife.Log.TraceStream.Encoding">
            <summary>编码</summary>
        </member>
        <member name="T:NewLife.Log.TextFileLog">
            <summary>文本文件日志类。提供向文本文件写日志的能力</summary>
            <remarks>
            2015-06-01 为了继承TextFileLog，增加了无参构造函数，修改了异步写日志方法为虚方法，可以进行重载
            </remarks>
        </member>
        <member name="M:NewLife.Log.TextFileLog.#ctor">
            <summary>该构造函数没有作用，为了继承而设置</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.Create(System.String,System.String)">
            <summary>每个目录的日志实例应该只有一个，所以采用静态创建</summary>
            <param name="path">日志目录或日志文件路径</param>
            <param name="fileFormat"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TextFileLog.CreateFile(System.String)">
            <summary>每个目录的日志实例应该只有一个，所以采用静态创建</summary>
            <param name="path">日志目录或日志文件路径</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.TextFileLog.Dispose">
            <summary>销毁</summary>
        </member>
        <member name="P:NewLife.Log.TextFileLog.LogFile">
            <summary>日志文件</summary>
        </member>
        <member name="P:NewLife.Log.TextFileLog.LogPath">
            <summary>日志目录</summary>
        </member>
        <member name="P:NewLife.Log.TextFileLog.FileFormat">
            <summary>日志文件格式</summary>
        </member>
        <member name="F:NewLife.Log.TextFileLog.isFirst">
            <summary>是否当前进程的第一次写日志</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.InitLog">
            <summary>初始化日志记录文件</summary>
        </member>
        <member name="M:NewLife.Log.TextFileLog.WriteFile(System.Object)">
            <summary>写文件</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.OnWrite(NewLife.Log.LogLevel,System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="level"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.TextFileLog.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.CodeTimer">
            <summary>代码性能计时器</summary>
            <remarks>参考了老赵（http://www.cnblogs.com/jeffreyzhao/archive/2009/03/10/codetimer.html）和eaglet（http://www.cnblogs.com/eaglet/archive/2009/03/10/1407791.html）两位的作品</remarks>
            <remarks>为了保证性能比较的公平性，采用了多种指标，并使用计时器重写等手段来避免各种不必要的损耗</remarks>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Time(System.Int32,System.Action{System.Int32},System.Boolean)">
            <summary>计时</summary>
            <param name="times">次数</param>
            <param name="action">需要计时的委托</param>
            <param name="needTimeOne">是否需要预热</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.CodeTimer.TimeLine(System.String,System.Int32,System.Action{System.Int32},System.Boolean)">
            <summary>计时，并用控制台输出行</summary>
            <param name="title">标题</param>
            <param name="times">次数</param>
            <param name="action">需要计时的委托</param>
            <param name="needTimeOne">是否需要预热</param>
        </member>
        <member name="M:NewLife.Log.CodeTimer.ShowHeader(System.String)">
            <summary>显示头部</summary>
            <param name="title"></param>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Times">
            <summary>次数</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Action">
            <summary>迭代方法，如不指定，则使用Time(int index)</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.ShowProgress">
            <summary>是否显示控制台进度</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Index">
            <summary>进度</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.CpuCycles">
            <summary>CPU周期</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.ThreadTime">
            <summary>线程时间，单位是ms</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Gen">
            <summary>GC代数</summary>
        </member>
        <member name="P:NewLife.Log.CodeTimer.Elapsed">
            <summary>执行时间</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.#ctor">
            <summary>实例化一个代码计时器</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Time">
            <summary>计时核心方法，处理进程和线程优先级</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.TimeTrue">
            <summary>真正的计时</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.TimeOne">
            <summary>执行一次迭代，预热所有方法</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Init">
            <summary>迭代前执行，计算时间</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Time(System.Int32)">
            <summary>每一次迭代，计算时间</summary>
            <param name="index"></param>
        </member>
        <member name="M:NewLife.Log.CodeTimer.Finish">
            <summary>迭代后执行，计算时间</summary>
        </member>
        <member name="F:NewLife.Log.CodeTimer.msBase">
            <summary>基准时间</summary>
        </member>
        <member name="M:NewLife.Log.CodeTimer.ToString">
            <summary>已重载。输出依次分别是：执行时间、CPU线程时间、时钟周期、GC代数</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Log.WriteLogEventArgs">
            <summary>写日志事件参数</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Level">
            <summary>日志等级</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Message">
            <summary>日志信息</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Exception">
            <summary>异常</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Time">
            <summary>时间</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.ThreadID">
            <summary>线程编号</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.IsPool">
            <summary>是否线程池线程</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.IsWeb">
            <summary>是否Web线程</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.ThreadName">
            <summary>线程名</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.TaskID">
            <summary>任务编号</summary>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.#ctor">
            <summary>实例化一个日志事件参数</summary>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.Current">
            <summary>线程专有实例。线程静态，每个线程只用一个，避免GC浪费</summary>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.Set(NewLife.Log.LogLevel)">
            <summary>初始化为新日志</summary>
            <param name="level">日志等级</param>
            <returns>返回自身，链式写法</returns>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.Set(System.String,System.Exception)">
            <summary>初始化为新日志</summary>
            <param name="message">日志</param>
            <param name="exception">异常</param>
            <returns>返回自身，链式写法</returns>
        </member>
        <member name="M:NewLife.Log.WriteLogEventArgs.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.WriteLogEventArgs.CurrentThreadName">
            <summary>设置当前线程输出日志时的线程名</summary>
        </member>
        <member name="T:NewLife.Log.XTrace">
            <summary>日志类，包含跟踪调试功能</summary>
            <remarks>
            该静态类包括写日志、写调用栈和Dump进程内存等调试功能。
            
            默认写日志到文本文件，可通过修改<see cref="P:NewLife.Log.XTrace.Log"/>属性来增加日志输出方式。
            对于控制台工程，可以直接通过UseConsole方法，把日志输出重定向为控制台输出，并且可以为不同线程使用不同颜色。
            </remarks>
        </member>
        <member name="F:NewLife.Log.XTrace._Log">
            <summary>文本文件日志</summary>
        </member>
        <member name="P:NewLife.Log.XTrace.Log">
            <summary>日志提供者，默认使用文本文件日志</summary>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteLine(System.String)">
            <summary>输出日志</summary>
            <param name="msg">信息</param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteLine(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteException(System.Exception)">
            <summary>输出异常日志</summary>
            <param name="ex">异常信息</param>
        </member>
        <member name="M:NewLife.Log.XTrace.InitLog">
            <summary>
            2012.11.05 修正初次调用的时候，由于同步BUG，导致Log为空的问题。
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.UseConsole(System.Boolean,System.Boolean)">
            <summary>使用控制台输出日志，只能调用一次</summary>
            <param name="useColor">是否使用颜色，默认使用</param>
            <param name="useFileLog">是否同时使用文件日志，默认使用</param>
        </member>
        <member name="M:NewLife.Log.XTrace.UseWinForm(System.Boolean)">
            <summary>拦截WinForm异常并记录日志，可指定是否用<see cref="T:System.Windows.Forms.MessageBox"/>显示。</summary>
            <param name="showErrorMessage">发为捕获异常时，是否显示提示，默认显示</param>
        </member>
        <member name="M:NewLife.Log.XTrace.UseWinFormControl(System.Windows.Forms.Control,System.Boolean,System.Int32)">
            <summary>在WinForm控件上输出日志，主要考虑非UI线程操作</summary>
            <remarks>不是常用功能，为了避免干扰常用功能，保持UseWinForm开头</remarks>
            <param name="control">要绑定日志输出的WinForm控件</param>
            <param name="useFileLog">是否同时使用文件日志，默认使用</param>
            <param name="maxLines">最大行数</param>
        </member>
        <member name="M:NewLife.Log.XTrace.Combine(System.Windows.Forms.Control,NewLife.Log.ILog,System.Int32)">
            <summary>控件绑定到日志，生成混合日志</summary>
            <param name="control"></param>
            <param name="log"></param>
            <param name="maxLines"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Log.XTrace.Debug">
            <summary>是否调试。</summary>
        </member>
        <member name="P:NewLife.Log.XTrace.LogPath">
            <summary>文本日志目录</summary>
        </member>
        <member name="P:NewLife.Log.XTrace.TempPath">
            <summary>临时目录</summary>
        </member>
        <member name="M:NewLife.Log.XTrace.DebugStack">
            <summary>堆栈调试。
            输出堆栈信息，用于调试时处理调用上下文。
            本方法会造成大量日志，请慎用。
            </summary>
        </member>
        <member name="M:NewLife.Log.XTrace.DebugStack(System.Int32)">
            <summary>堆栈调试。</summary>
            <param name="maxNum">最大捕获堆栈方法数</param>
        </member>
        <member name="M:NewLife.Log.XTrace.DebugStack(System.Int32,System.Int32)">
            <summary>堆栈调试</summary>
            <param name="start">开始方法数，0是DebugStack的直接调用者</param>
            <param name="maxNum">最大捕获堆栈方法数</param>
        </member>
        <member name="M:NewLife.Log.XTrace.GetCaller(System.Int32,System.Int32,System.String)">
            <summary>获取调用栈</summary>
            <param name="start">要跳过的方法数，默认1，也就是跳过GetCaller</param>
            <param name="maxNum">最大层数</param>
            <param name="split">分割符号，默认左箭头加上换行</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteVersion">
            <summary>输出核心库和启动程序的版本号</summary>
        </member>
        <member name="M:NewLife.Log.XTrace.WriteVersion(System.Reflection.Assembly)">
            <summary>输出程序集版本</summary>
            <param name="asm"></param>
        </member>
        <member name="T:NewLife.Expressions.UnionExpresion">
            <summary>与或非表达式</summary>
        </member>
        <member name="F:NewLife.Expressions.UnionExpresion.AndChar">
            <summary>位与</summary>
        </member>
        <member name="F:NewLife.Expressions.UnionExpresion.OrChar">
            <summary>位或</summary>
        </member>
        <member name="M:NewLife.Expressions.UnionExpresion.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Expressions.UnionExpresion.GetOperationLevel(System.String)">
            <summary>操作符等级</summary>
            <param name="op"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.UnionExpresion.AdapteAndReplace(System.String)">
            <summary>适配替换</summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Expressions.UnionExpresion.Container">
            <summary>容器</summary>
        </member>
        <member name="M:NewLife.Expressions.UnionExpresion.Complie(System.String,System.Object[])">
            <summary>解逆波兰表达式</summary>
            <param name="expression">标准逆波兰表达式</param>
            <param name="args"></param>
            <returns>逆波兰表达式的解</returns>
        </member>
        <member name="M:NewLife.Expressions.UnionExpresion.IsValid(System.String[])">
            <summary>是否有效</summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.UnionExpresion.GetAllMarks">
            <summary>所有掩码</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Expressions.MathExpression">
            <summary>数学表达式</summary>
        </member>
        <member name="F:NewLife.Expressions.MathExpression.AddChar">
            <summary>加法</summary>
        </member>
        <member name="F:NewLife.Expressions.MathExpression.SubtractChar">
            <summary>减法</summary>
        </member>
        <member name="F:NewLife.Expressions.MathExpression.MultiplyChar">
            <summary>乘法</summary>
        </member>
        <member name="F:NewLife.Expressions.MathExpression.DivideChar">
            <summary>除法</summary>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.GetOperationLevel(System.String)">
            <summary>计算运算符优先级</summary>
            <param name="op"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.AdapteAndReplace(System.String)">
            <summary>适配和替换</summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.Complie(System.String,System.Object[])">
            <summary>解逆波兰表达式</summary>
            <param name="expression">标准逆波兰表达式</param>
            <param name="args"></param>
            <returns>逆波兰表达式的解</returns>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.IsValid(System.String[])">
            <summary>是否有效</summary>
            <param name="arr"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.ToDouble(System.String)">
            <summary>转为浮点数</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.MathExpression.ComplieRpnExp(System.Double,System.Double,System.String)">
            <summary>
            计算逆波兰表达式
            </summary>
            <param name="last">最后压入数字堆栈的数字</param>
            <param name="first">首先压入数字堆栈的数字</param>
            <param name="op">操作运算符</param>
            <returns>返回计算结果</returns>
        </member>
        <member name="T:NewLife.Expressions.RpnExpression">
            <summary>逆波兰表达式</summary>
        </member>
        <member name="F:NewLife.Expressions.RpnExpression.LeftBracket">
            <summary>左括号</summary>
        </member>
        <member name="F:NewLife.Expressions.RpnExpression.RightBracket">
            <summary>右括号</summary>
        </member>
        <member name="F:NewLife.Expressions.RpnExpression.JoinChar">
            <summary>连接符</summary>
        </member>
        <member name="F:NewLife.Expressions.RpnExpression.EmptyChar">
            <summary>空格</summary>
        </member>
        <member name="P:NewLife.Expressions.RpnExpression.OperationChars">
            <summary>操作符数组</summary>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.IsBracket(System.String)">
            <summary>是否括号</summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.IsBracket(System.Char)">
            <summary>是否括号</summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.GetOperationLevel(System.String)">
            <summary>计算操作等级</summary>
            <param name="op"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.IsBracketMatch(System.String)">
            <summary>是否括号匹配</summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.AdapteAndReplace(System.String)">
            <summary>适配器和替换</summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Expressions.RpnExpression.Value">
            <summary>值</summary>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.ToExpression(System.String)">
            <summary>将中缀表达式转换为逆波兰表达式</summary>
            <param name="expression">标准中缀表达式</param>
            <returns>标准逆波兰表达式</returns>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.IsValid(System.String[])">
            <summary>是否有效</summary>
            <param name="splitArray"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Expressions.RpnExpression.Complie(System.String,System.Object[])">
            <summary>编译计算</summary>
            <param name="expression"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Messaging.DefaultMessage">
            <summary>标准消息</summary>
            <remarks>
            标准网络封包协议：1 Flag + 1 Sequence + 2 Length + N Payload
            1个字节标识位，标识请求、响应、错误、加密、压缩等；
            1个字节序列号，用于请求响应包配对；
            2个字节数据长度N，小端，指示后续负载数据长度（不包含头部4个字节），解决粘包问题；
            N个字节负载数据，数据内容完全由业务决定，最大长度65535=64k。
            如：
            Open => OK
            01-01-04-00-"Open" => 81-01-02-00-"OK"
            </remarks>
        </member>
        <member name="P:NewLife.Messaging.DefaultMessage.Flag">
            <summary>标记位</summary>
        </member>
        <member name="P:NewLife.Messaging.DefaultMessage.Error">
            <summary>是否有错</summary>
        </member>
        <member name="P:NewLife.Messaging.DefaultMessage.OneWay">
            <summary>是否单向，仅请求无需响应</summary>
        </member>
        <member name="P:NewLife.Messaging.DefaultMessage.Sequence">
            <summary>序列号，匹配请求和响应</summary>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.CreateReply">
            <summary>根据请求创建配对的响应消息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.Read(NewLife.Data.Packet)">
            <summary>从数据包中读取消息</summary>
            <param name="pk"></param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.ToPacket">
            <summary>把消息转为封包</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.GetLength(NewLife.Data.Packet)">
            <summary>获取数据包长度</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.DefaultMessage.ToString">
            <summary>消息摘要</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Messaging.IMessage">
            <summary>消息命令</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessage.Reply">
            <summary>是否响应</summary>
        </member>
        <member name="P:NewLife.Messaging.IMessage.Payload">
            <summary>负载数据</summary>
        </member>
        <member name="M:NewLife.Messaging.IMessage.CreateReply">
            <summary>根据请求创建配对的响应消息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.IMessage.Read(NewLife.Data.Packet)">
            <summary>从数据包中读取消息</summary>
            <param name="pk"></param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Messaging.IMessage.ToPacket">
            <summary>把消息转为封包</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Messaging.Message">
            <summary>消息命令基类</summary>
        </member>
        <member name="P:NewLife.Messaging.Message.Reply">
            <summary>是否响应</summary>
        </member>
        <member name="P:NewLife.Messaging.Message.Payload">
            <summary>负载数据</summary>
        </member>
        <member name="M:NewLife.Messaging.Message.CreateReply">
            <summary>根据请求创建配对的响应消息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Messaging.Message.Read(NewLife.Data.Packet)">
            <summary>从数据包中读取消息</summary>
            <param name="pk"></param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Messaging.Message.ToPacket">
            <summary>把消息转为封包</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Messaging.MessageEventArgs">
            <summary>收到消息时的事件参数</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageEventArgs.Packet">
            <summary>数据包</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageEventArgs.Message">
            <summary>消息</summary>
        </member>
        <member name="P:NewLife.Messaging.MessageEventArgs.UserState">
            <summary>用户数据。比如远程地址等</summary>
        </member>
        <member name="T:NewLife.Model.IFactory`1">
            <summary>用于创建对象的工厂接口</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Model.IFactory`1.Create(System.Object)">
            <summary>创建对象实例</summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.Factory`1">
            <summary>反射创建对象的工厂</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Model.Factory`1.Create(System.Object)">
            <summary>创建对象实例</summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.IHistory">
            <summary>历史接口，用户操作历史</summary>
        </member>
        <member name="P:NewLife.Model.IHistory.UserID">
            <summary>会员</summary>
        </member>
        <member name="P:NewLife.Model.IHistory.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.IHistory.Type">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Model.IHistory.Action">
            <summary>操作</summary>
        </member>
        <member name="P:NewLife.Model.IHistory.Success">
            <summary>成功</summary>
        </member>
        <member name="P:NewLife.Model.IHistory.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:NewLife.Model.IHistory.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="P:NewLife.Model.IHistory.Remark">
            <summary>内容</summary>
        </member>
        <member name="M:NewLife.Model.IHistory.SaveAsync(System.Int32)">
            <summary>异步保存。实现延迟保存，大事务保存。主要面向日志表和频繁更新的在线记录表</summary>
            <param name="msDelay">延迟保存的时间。默认0ms近实时保存</param>
            <returns>是否成功加入异步队列</returns>
        </member>
        <member name="T:NewLife.Model.IAuthUser">
            <summary>认证用户接口，具有登录验证、注册、在线等基本信息</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.Password">
            <summary>密码</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.Online">
            <summary>在线</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.Logins">
            <summary>登录次数</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.LastLogin">
            <summary>最后登录</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.LastLoginIP">
            <summary>最后登录IP</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.RegisterTime">
            <summary>注册时间</summary>
        </member>
        <member name="P:NewLife.Model.IAuthUser.RegisterIP">
            <summary>注册IP</summary>
        </member>
        <member name="M:NewLife.Model.IAuthUser.Save">
            <summary>保存</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.ManageUserHelper">
            <summary>用户接口工具类</summary>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.CheckEqual(NewLife.Model.IAuthUser,System.String)">
            <summary>比较密码相等</summary>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.CheckMD5(NewLife.Model.IAuthUser,System.String)">
            <summary>比较密码MD5</summary>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.CheckRC4(NewLife.Model.IAuthUser,System.String)">
            <summary>比较密码RC4</summary>
            <param name="user"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.SaveLogin(NewLife.Model.IAuthUser,NewLife.Net.INetSession)">
            <summary>保存登录信息</summary>
            <param name="user"></param>
            <param name="session"></param>
        </member>
        <member name="M:NewLife.Model.ManageUserHelper.SaveRegister(NewLife.Model.IAuthUser,NewLife.Net.INetSession)">
            <summary>保存注册信息</summary>
            <param name="user"></param>
            <param name="session"></param>
        </member>
        <member name="T:NewLife.Model.IOnline">
            <summary>在线接口，用户在线离线</summary>
        </member>
        <member name="P:NewLife.Model.IOnline.UserID">
            <summary>会员</summary>
        </member>
        <member name="P:NewLife.Model.IOnline.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.IOnline.Type">
            <summary>类型</summary>
        </member>
        <member name="P:NewLife.Model.IOnline.SessionID">
            <summary>会话</summary>
        </member>
        <member name="P:NewLife.Model.IOnline.CreateTime">
            <summary>创建时间</summary>
        </member>
        <member name="P:NewLife.Model.IOnline.CreateIP">
            <summary>创建地址</summary>
        </member>
        <member name="P:NewLife.Model.IOnline.UpdateTime">
            <summary>更新时间</summary>
        </member>
        <member name="M:NewLife.Model.IOnline.SaveAsync(System.Int32)">
            <summary>异步保存。实现延迟保存，大事务保存。主要面向日志表和频繁更新的在线记录表</summary>
            <param name="msDelay">延迟保存的时间。默认0ms近实时保存</param>
            <returns>是否成功加入异步队列</returns>
        </member>
        <member name="M:NewLife.Model.IOnline.Delete">
            <summary>从数据库中删除该对象</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IOnline.Save">
            <summary>保存</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.IPlugin">
            <summary>通用插件接口</summary>
            <remarks>
            为了方便构建一个简单通用的插件系统，先规定如下：
            1，负责加载插件的宿主，在加载插件后会进行插件实例化，此时可在插件构造函数中做一些事情，但不应该开始业务处理，因为宿主的准备工作可能尚未完成
            2，宿主一切准备就绪后，会顺序调用插件的Init方法，并将宿主标识传入，插件通过标识区分是否自己的目标宿主。插件的Init应尽快完成。
            3，如果插件实现了<see cref="T:System.IDisposable"/>接口，宿主最后会清理资源。
            </remarks>
        </member>
        <member name="M:NewLife.Model.IPlugin.Init(System.String,System.IServiceProvider)">
            <summary>初始化</summary>
            <param name="identity">插件宿主标识</param>
            <param name="provider">服务提供者</param>
            <returns>返回初始化是否成功。如果当前宿主不是所期待的宿主，这里返回false</returns>
        </member>
        <member name="T:NewLife.Model.PluginAttribute">
            <summary>插件特性。用于判断某个插件实现类是否支持某个宿主</summary>
        </member>
        <member name="P:NewLife.Model.PluginAttribute.Identity">
            <summary>插件宿主标识</summary>
        </member>
        <member name="M:NewLife.Model.PluginAttribute.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="identity"></param>
        </member>
        <member name="T:NewLife.Model.PluginManager">
            <summary>插件管理器</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Identity">
            <summary>宿主标识，用于供插件区分不同宿主</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Provider">
            <summary>宿主服务提供者</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Plugins">
            <summary>插件集合</summary>
        </member>
        <member name="P:NewLife.Model.PluginManager.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="M:NewLife.Model.PluginManager.#ctor">
            <summary>实例化一个插件管理器</summary>
        </member>
        <member name="M:NewLife.Model.PluginManager.#ctor(System.Object)">
            <summary>使用宿主对象实例化一个插件管理器</summary>
            <param name="host"></param>
        </member>
        <member name="M:NewLife.Model.PluginManager.OnDispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            因为该方法只会被调用一次，所以该参数的意义不太大。</param>
        </member>
        <member name="M:NewLife.Model.PluginManager.Load">
            <summary>加载插件。此时是加载所有插件，无法识别哪些是需要的</summary>
        </member>
        <member name="M:NewLife.Model.PluginManager.Init">
            <summary>开始初始化。初始化之后，不属于当前宿主的插件将会被过滤掉</summary>
        </member>
        <member name="T:NewLife.Model.IManageUser">
            <summary>用户接口</summary>
        </member>
        <member name="P:NewLife.Model.IManageUser.ID">
            <summary>编号</summary>
        </member>
        <member name="P:NewLife.Model.IManageUser.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.IManageUser.NickName">
            <summary>昵称</summary>
        </member>
        <member name="P:NewLife.Model.IManageUser.Enable">
            <summary>启用</summary>
        </member>
        <member name="T:NewLife.Model.IObjectContainer">
            <summary>对象容器接口</summary>
            <remarks>
            1，如果容器里面没有这个类型，则返回空；
            2，如果容器里面包含这个类型，<see cref="M:NewLife.Model.IObjectContainer.ResolveInstance(System.Type,System.Object)"/>返回单例；
            3，如果容器里面包含这个类型，<see cref="M:NewLife.Model.IObjectContainer.Resolve(System.Type,System.Object)"/>创建对象返回多实例；
            4，如果有带参数构造函数，则从容器内获取各个参数的实例，最后创建对象返回。
            
            这里有一点跟大多数对象容器非常不同，其它对象容器会控制对象的生命周期，在对象不再使用时收回到容器里面。
            这里的对象容器主要是为了用于解耦，所以只有最简单的功能实现。
            
            代码注册的默认优先级是0；
            配置注册的默认优先级是1；
            自动注册的外部实现（非排除项）的默认优先级是1，排除项的优先级是0；
            所以，配置注册的优先级最高
            </remarks>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Register(System.Type,System.Type,System.Object,System.Object,System.Int32)">
            <summary>注册类型和名称</summary>
            <param name="from">接口类型</param>
            <param name="to">实现类型</param>
            <param name="instance">实例</param>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.AutoRegister(System.Type,System.Type[])">
            <summary>遍历所有程序集的所有类型，自动注册实现了指定接口或基类的类型。如果没有注册任何实现，则默认注册第一个排除类型</summary>
            <remarks>自动注册一般用于单实例功能扩展型接口</remarks>
            <param name="from">接口或基类</param>
            <param name="excludeTypes">要排除的类型，一般是内部默认实现</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.Resolve(System.Type,System.Object)">
            <summary>解析类型指定名称的实例</summary>
            <param name="from">接口类型</param>
            <param name="id">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.ResolveInstance(System.Type,System.Object)">
            <summary>解析类型指定名称的实例</summary>
            <param name="from">接口类型</param>
            <param name="id">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.ResolveType(System.Type,System.Object)">
            <summary>解析接口指定名称的实现类型</summary>
            <param name="from">接口类型</param>
            <param name="id">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.IObjectContainer.ResolveAll(System.Type)">
            <summary>解析接口所有已注册的对象映射</summary>
            <param name="from">接口类型</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.IObjectMap">
            <summary>对象映射接口</summary>
        </member>
        <member name="P:NewLife.Model.IObjectMap.Identity">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.IObjectMap.Type">
            <summary>实现类型</summary>
        </member>
        <member name="P:NewLife.Model.IObjectMap.Instance">
            <summary>对象实例</summary>
        </member>
        <member name="T:NewLife.Model.ObjectContainer">
            <summary>实现 <seealso cref="T:NewLife.Model.IObjectContainer"/> 接口的对象容器</summary>
            <remarks>
            1，如果容器里面没有这个类型，则返回空；
            2，如果容器里面包含这个类型，<see cref="M:NewLife.Model.ObjectContainer.ResolveInstance(System.Type,System.Object)"/>返回单例；
            3，如果容器里面包含这个类型，<see cref="M:NewLife.Model.ObjectContainer.Resolve(System.Type,System.Object)"/>创建对象返回多实例；
            4，如果有带参数构造函数，则从容器内获取各个参数的实例，最后创建对象返回。
            
            这里有一点跟大多数对象容器非常不同，其它对象容器会控制对象的生命周期，在对象不再使用时收回到容器里面。
            这里的对象容器主要是为了用于解耦，所以只有最简单的功能实现。
            
            代码注册的默认优先级是0；
            配置注册的默认优先级是1；
            自动注册的外部实现（非排除项）的默认优先级是1，排除项的优先级是0；
            所以，配置注册的优先级最高
            </remarks>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Current">
            <summary>当前容器</summary>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.#ctor">
            <summary>初始化一个对象容器实例，自动从配置文件中加载注册</summary>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Find(System.Type,System.Boolean)">
            <summary>不存在又不添加时返回空列表</summary>
            <param name="type"></param>
            <param name="add"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Map.Identity">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Map.Type">
            <summary>实现类型</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Map.Priority">
            <summary>优先级</summary>
        </member>
        <member name="P:NewLife.Model.ObjectContainer.Map.Instance">
            <summary>实例</summary>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Register(System.Type,System.Type,System.Object,System.Object,System.Int32)">
            <summary>注册</summary>
            <param name="from">接口类型</param>
            <param name="to">实现类型</param>
            <param name="instance">实例</param>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.AutoRegister(System.Type,System.Type[])">
            <summary>遍历所有程序集的所有类型，自动注册实现了指定接口或基类的类型。如果没有注册任何实现，则默认注册第一个排除类型</summary>
            <remarks>自动注册一般用于单实例功能扩展型接口</remarks>
            <param name="from">接口或基类</param>
            <param name="excludeTypes">要排除的类型，一般是内部默认实现</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.Resolve(System.Type,System.Object)">
            <summary>解析类型指定名称的实例</summary>
            <param name="from">接口类型</param>
            <param name="id">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ResolveInstance(System.Type,System.Object)">
            <summary>解析类型指定名称的实例</summary>
            <param name="from">接口类型</param>
            <param name="id">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ResolveType(System.Type,System.Object)">
            <summary>解析接口指定名称的实现类型</summary>
            <param name="from">接口类型</param>
            <param name="id">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ResolveAll(System.Type)">
            <summary>解析接口所有已注册的对象映射</summary>
            <param name="from">接口类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Model.ObjectContainer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Model.IServer">
            <summary>服务接口。</summary>
            <remarks>服务代理XAgent可以附加代理实现了IServer接口的服务。</remarks>
        </member>
        <member name="M:NewLife.Model.IServer.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Model.IServer.Stop(System.String)">
            <summary>停止</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="T:NewLife.Remoting.ApiAction">
            <summary>Api动作</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.Name">
            <summary>动作名称</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.Type">
            <summary>动作所在类型</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.Method">
            <summary>方法</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.Controller">
            <summary>控制器对象</summary>
            <remarks>如果指定控制器对象，则每次调用前不再实例化对象</remarks>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.IsPacketParameter">
            <summary>是否二进制参数</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAction.IsPacketReturn">
            <summary>是否二进制返回</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiAction.#ctor(System.Reflection.MethodInfo,System.Type)">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiAction.GetName(System.Type,System.Reflection.MethodInfo)">
            <summary>获取名称</summary>
            <param name="type"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiAction.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.ApiAttribute">
            <summary>标识Api</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiAttribute.Name">
            <summary>名称</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiAttribute.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="name"></param>
        </member>
        <member name="T:NewLife.Remoting.ApiClient">
            <summary>应用接口客户端</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.Active">
            <summary>是否已打开</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.Servers">
            <summary>服务端地址集合。负载均衡</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.NewLife#Remoting#IApiSession#Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.LastActive">
            <summary>最后活跃时间</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.NewLife#Remoting#IApiSession#AllSessions">
            <summary>所有服务器所有会话，包含自己</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.StatSend">
            <summary>发送数据包统计信息</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.StatReceive">
            <summary>接收数据包统计信息</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.#ctor">
            <summary>实例化应用接口客户端</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.#ctor(System.String)">
            <summary>实例化应用接口客户端</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.Open">
            <summary>打开客户端</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.Close(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.FindAction(System.String)">
            <summary>查找Api动作</summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.CreateController(NewLife.Remoting.ApiAction)">
            <summary>创建控制器实例</summary>
            <param name="api"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.InvokeAsync(System.Type,System.String,System.Object,System.Byte)">
            <summary>异步调用，等待返回结果</summary>
            <param name="resultType">返回类型</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.InvokeAsync``1(System.String,System.Object,System.Byte)">
            <summary>异步调用，等待返回结果</summary>
            <typeparam name="TResult"></typeparam>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.Invoke(System.String,System.Object,System.Byte)">
            <summary>同步调用，不等待返回</summary>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.InvokeWithClientAsync``1(NewLife.Net.ISocketClient,System.String,System.Object,System.Byte)">
            <summary>指定客户端的异步调用，等待返回结果</summary>
            <typeparam name="TResult"></typeparam>
            <param name="client">客户端</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.OnNewSession(NewLife.Remoting.IApiSession,System.Object)">
            <summary>新会话。客户端每次连接或断线重连后，可用InvokeWithClientAsync做登录</summary>
            <param name="session">会话</param>
            <param name="state">状态。客户端ISocketClient</param>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.OnLogin(NewLife.Net.ISocketClient)">
            <summary>连接后自动登录</summary>
            <param name="client">客户端</param>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.Pool">
            <summary>连接池</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.CreateCallback">
            <summary>创建回调</summary>
        </member>
        <member name="F:NewLife.Remoting.ApiClient._index">
            <summary>Round-Robin 负载均衡</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.OnCreate">
            <summary>为连接池创建连接</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiClient.OnCreate(System.String)">
            <summary>创建客户端之后，打开连接之前</summary>
            <param name="svr"></param>
        </member>
        <member name="P:NewLife.Remoting.ApiClient.StatPeriod">
            <summary>显示统计信息的周期。默认600秒，0表示不显示统计信息</summary>
        </member>
        <member name="T:NewLife.Remoting.ApiException">
            <summary>远程调用异常</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiException.Code">
            <summary>代码</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiException.#ctor(System.Int32,System.String)">
            <summary>实例化远程调用异常</summary>
            <param name="code"></param>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiException.#ctor(System.Int32,System.Exception)">
            <summary>实例化远程调用异常</summary>
            <param name="code"></param>
            <param name="ex"></param>
        </member>
        <member name="T:NewLife.Remoting.ApiHost">
            <summary>Api主机</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Encoder">
            <summary>编码器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Handler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Timeout">
            <summary>调用超时时间。默认30_000ms</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.StatInvoke">
            <summary>发送数据包统计信息</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.StatProcess">
            <summary>接收数据包统计信息</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Items">
            <summary>用户会话数据</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Item(System.String)">
            <summary>获取/设置 用户会话数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Manager">
            <summary>接口动作管理器</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.Register``1">
            <summary>注册服务提供类。该类的所有公开方法将直接暴露</summary>
            <typeparam name="TService"></typeparam>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.Register(System.Object,System.String)">
            <summary>注册服务</summary>
            <param name="controller">控制器对象</param>
            <param name="method">动作名称。为空时遍历控制器所有公有成员方法</param>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.Register(System.Type,System.String)">
            <summary>注册服务</summary>
            <param name="type">控制器类型</param>
            <param name="method">动作名称。为空时遍历控制器所有公有成员方法</param>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.ShowService">
            <summary>显示可用服务</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.GetMessageCodec">
            <summary>获取消息编码器。重载以指定不同的封包协议</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.NewLife#Remoting#IApiHost#Process(NewLife.Remoting.IApiSession,NewLife.Messaging.IMessage)">
            <summary>处理消息</summary>
            <param name="session"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.OnProcess(NewLife.Remoting.IApiSession,System.String,NewLife.Data.Packet)">
            <summary>执行</summary>
            <param name="session"></param>
            <param name="action"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.OnNewSession(NewLife.Remoting.IApiSession,System.Object)">
            <summary>新会话。服务端收到新连接，客户端每次连接或断线重连后，可用于做登录</summary>
            <param name="session">会话</param>
            <param name="state">状态。客户端ISocketClient</param>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.Log">
            <summary>日志</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.EncoderLog">
            <summary>编码器日志</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiHost.ShowError">
            <summary>显示调用和处理错误。默认false</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiHost.ToString">
            <summary>已重载。返回具有本类特征的字符串</summary>
            <returns>String</returns>
        </member>
        <member name="P:NewLife.Remoting.ApiNetServer.Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiNetServer.AllSessions">
            <summary>当前服务器所有会话</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiNetServer.Timeout">
            <summary>调用超时时间。默认30_000ms</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiNetServer.Init(System.String)">
            <summary>初始化</summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ApiNetSession.NewLife#Remoting#IApiSession#Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiNetSession.LastActive">
            <summary>最后活跃时间</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiNetSession.AllSessions">
            <summary>所有服务器所有会话，包含自己</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiNetSession.Start">
            <summary>开始会话处理</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiNetSession.FindAction(System.String)">
            <summary>查找Api动作</summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiNetSession.CreateController(NewLife.Remoting.ApiAction)">
            <summary>创建控制器实例</summary>
            <param name="api"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiNetSession.InvokeAsync``1(System.String,System.Object,System.Byte)">
            <summary>远程调用</summary>
            <typeparam name="TResult"></typeparam>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.ApiServer">
            <summary>应用接口服务器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.Active">
            <summary>是否正在工作</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.Server">
            <summary>服务器</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.#ctor">
            <summary>实例化一个应用接口服务器</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.#ctor(System.Int32)">
            <summary>使用指定端口实例化网络服务应用接口提供者</summary>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.#ctor(NewLife.Net.NetUri)">
            <summary>实例化</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.OnDispose(System.Boolean)">
            <summary>销毁时停止服务</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.Use(NewLife.Net.NetUri)">
            <summary>添加服务器</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.EnsureCreate">
            <summary>确保已创建服务器对象</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.Start">
            <summary>开始服务</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiServer.Stop(System.String)">
            <summary>停止服务</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="P:NewLife.Remoting.ApiServer.StatPeriod">
            <summary>显示统计信息的周期。默认600秒，0表示不显示统计信息</summary>
        </member>
        <member name="T:NewLife.Remoting.ApiController">
            <summary>API控制器</summary>
        </member>
        <member name="P:NewLife.Remoting.ApiController.Host">
            <summary>主机</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiController.All">
            <summary>获取所有接口</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiController.Info">
            <summary>服务器信息，用户健康检测</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.ControllerContext">
            <summary>控制器上下文</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Controller">
            <summary>控制器实例</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Action">
            <summary>处理动作</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.ActionName">
            <summary>真实动作名称</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Session">
            <summary>会话</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Request">
            <summary>请求</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Parameters">
            <summary>请求参数</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.ActionParameters">
            <summary>获取或设置操作方法参数。</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Result">
            <summary>获取或设置由操作方法返回的结果。</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Exception">
            <summary>获取或设置在操作方法的执行过程中发生的异常（如果有）。</summary>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.ExceptionHandled">
            <summary>获取或设置一个值，该值指示是否处理异常。</summary>
        </member>
        <member name="M:NewLife.Remoting.ControllerContext.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Remoting.ControllerContext.#ctor(NewLife.Remoting.ControllerContext)">
            <summary>拷贝实例化</summary>
            <param name="context"></param>
        </member>
        <member name="P:NewLife.Remoting.ControllerContext.Current">
            <summary>当前线程上下文</summary>
        </member>
        <member name="T:NewLife.Remoting.IActionFilter">
            <summary>定义操作筛选器中使用的方法。</summary>
        </member>
        <member name="M:NewLife.Remoting.IActionFilter.OnActionExecuting(NewLife.Remoting.ControllerContext)">
            <summary>在执行操作方法之前调用。</summary>
            <param name="filterContext"></param>
        </member>
        <member name="M:NewLife.Remoting.IActionFilter.OnActionExecuted(NewLife.Remoting.ControllerContext)">
            <summary>在执行操作方法后调用。</summary>
            <param name="filterContext"></param>
        </member>
        <member name="T:NewLife.Remoting.IApi">
            <summary>Api接口</summary>
        </member>
        <member name="P:NewLife.Remoting.IApi.Session">
            <summary>会话</summary>
        </member>
        <member name="T:NewLife.Remoting.IApiHandler">
            <summary>Api处理器</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiHandler.Execute(NewLife.Remoting.IApiSession,System.String,NewLife.Data.Packet)">
            <summary>执行</summary>
            <param name="session"></param>
            <param name="action"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ApiHandler.Host">
            <summary>Api接口主机</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHandler.Execute(NewLife.Remoting.IApiSession,System.String,NewLife.Data.Packet)">
            <summary>执行</summary>
            <param name="session"></param>
            <param name="action"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.IApiHost">
            <summary>Api主机</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiHost.Encoder">
            <summary>编码器</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiHost.Handler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiHost.Manager">
            <summary>接口动作管理器</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiHost.GetMessageCodec">
            <summary>获取消息编码器。重载以指定不同的封包协议</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IApiHost.Process(NewLife.Remoting.IApiSession,NewLife.Messaging.IMessage)">
            <summary>处理消息</summary>
            <param name="session"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.IApiHost.StatInvoke">
            <summary>发送统计</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiHost.StatProcess">
            <summary>接收统计</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiHost.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiHost.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Remoting.ApiHostHelper">
            <summary>Api主机助手</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiHostHelper.InvokeAsync(NewLife.Remoting.IApiHost,System.Object,System.Type,System.String,System.Object,System.Byte)">
            <summary>调用</summary>
            <param name="host"></param>
            <param name="session"></param>
            <param name="resultType">结果类型</param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHostHelper.Invoke(NewLife.Remoting.IApiHost,System.Object,System.String,System.Object,System.Byte)">
            <summary>调用</summary>
            <param name="host"></param>
            <param name="session"></param>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHostHelper.CreateController(NewLife.Remoting.IApiHost,NewLife.Remoting.IApiSession,NewLife.Remoting.ApiAction)">
            <summary>创建控制器实例</summary>
            <param name="host"></param>
            <param name="session"></param>
            <param name="api"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHostHelper.Encode(System.String,System.Int32,NewLife.Data.Packet)">
            <summary>编码 请求/响应</summary>
            <param name="action"></param>
            <param name="code"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHostHelper.Decode(NewLife.Messaging.IMessage,System.String@,System.Int32@,NewLife.Data.Packet@)">
            <summary>解码 请求/响应</summary>
            <param name="msg">消息</param>
            <param name="action">服务动作</param>
            <param name="code">错误码</param>
            <param name="value">参数或结果</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.ApiHostHelper.GetStat(NewLife.Remoting.IApiHost)">
            <summary>获取统计信息</summary>
            <param name="host"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.IApiManager">
            <summary>接口管理器</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiManager.Services">
            <summary>可提供服务的方法</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiManager.Register``1">
            <summary>注册服务提供类。该类的所有公开方法将直接暴露</summary>
            <typeparam name="TService"></typeparam>
        </member>
        <member name="M:NewLife.Remoting.IApiManager.Register(System.Object,System.String)">
            <summary>注册服务</summary>
            <param name="controller">控制器对象</param>
            <param name="method">动作名称。为空时遍历控制器所有公有成员方法</param>
        </member>
        <member name="M:NewLife.Remoting.IApiManager.Register(System.Type,System.String)">
            <summary>注册服务</summary>
            <param name="type">控制器类型</param>
            <param name="method">动作名称。为空时遍历控制器所有公有成员方法</param>
        </member>
        <member name="M:NewLife.Remoting.IApiManager.Register(System.Reflection.MethodInfo)">
            <summary>注册服务</summary>
            <param name="method">动作</param>
        </member>
        <member name="M:NewLife.Remoting.IApiManager.Find(System.String)">
            <summary>查找服务</summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.ApiManager.Services">
            <summary>可提供服务的方法</summary>
        </member>
        <member name="M:NewLife.Remoting.ApiManager.Register``1">
            <summary>注册服务提供类。该类的所有公开方法将直接暴露</summary>
            <typeparam name="TService"></typeparam>
        </member>
        <member name="M:NewLife.Remoting.ApiManager.Register(System.Object,System.String)">
            <summary>注册服务</summary>
            <param name="controller">控制器对象</param>
            <param name="method">动作名称。为空时遍历控制器所有公有成员方法</param>
        </member>
        <member name="M:NewLife.Remoting.ApiManager.Register(System.Type,System.String)">
            <summary>注册服务</summary>
            <param name="type">控制器类型</param>
            <param name="method">动作名称。为空时遍历控制器所有公有成员方法</param>
        </member>
        <member name="M:NewLife.Remoting.ApiManager.Register(System.Reflection.MethodInfo)">
            <summary>注册服务</summary>
            <param name="method">动作名称。为空时遍历控制器所有公有成员方法</param>
        </member>
        <member name="M:NewLife.Remoting.ApiManager.Find(System.String)">
            <summary>查找服务</summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.IApiServer">
            <summary>应用接口服务器接口</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiServer.Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiServer.AllSessions">
            <summary>当前服务器所有会话</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiServer.Init(System.String)">
            <summary>初始化</summary>
            <param name="config"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IApiServer.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Remoting.IApiServer.Stop(System.String)">
            <summary>停止</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="P:NewLife.Remoting.IApiServer.Log">
            <summary>日志</summary>
        </member>
        <member name="T:NewLife.Remoting.IApiSession">
            <summary>Api会话</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiSession.Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiSession.LastActive">
            <summary>最后活跃时间</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiSession.AllSessions">
            <summary>所有服务器所有会话，包含自己</summary>
        </member>
        <member name="P:NewLife.Remoting.IApiSession.Item(System.String)">
            <summary>获取/设置 用户会话数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IApiSession.FindAction(System.String)">
            <summary>查找Api动作</summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IApiSession.CreateController(NewLife.Remoting.ApiAction)">
            <summary>创建控制器实例</summary>
            <param name="api"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IApiSession.SendAsync(NewLife.Messaging.IMessage)">
            <summary>发送消息。低级接口，由框架使用</summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IApiSession.Send(NewLife.Messaging.IMessage)">
            <summary>发送消息。低级接口，由框架使用</summary>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IApiSession.InvokeAsync``1(System.String,System.Object,System.Byte)">
            <summary>远程调用</summary>
            <typeparam name="TResult"></typeparam>
            <param name="action">服务操作</param>
            <param name="args">参数</param>
            <param name="flag">标识</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Remoting.IEncoder">
            <summary>编码器</summary>
        </member>
        <member name="M:NewLife.Remoting.IEncoder.Encode(System.String,System.Int32,System.Object)">
            <summary>编码 请求/响应</summary>
            <param name="action">服务动作</param>
            <param name="code">错误码</param>
            <param name="value">参数或结果</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IEncoder.Decode(System.String,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="action"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IEncoder.Convert``1(System.Object)">
            <summary>转换为对象</summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.IEncoder.Convert(System.Object,System.Type)">
            <summary>转换为目标类型</summary>
            <param name="obj"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Remoting.IEncoder.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="T:NewLife.Remoting.EncoderBase">
            <summary>编码器基类</summary>
        </member>
        <member name="P:NewLife.Remoting.EncoderBase.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="M:NewLife.Remoting.EncoderBase.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Remoting.JsonEncoder">
            <summary>Json编码器</summary>
        </member>
        <member name="M:NewLife.Remoting.JsonEncoder.Encode(System.String,System.Int32,System.Object)">
            <summary>编码</summary>
            <param name="action"></param>
            <param name="code"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.JsonEncoder.Decode(System.String,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="action"></param>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.JsonEncoder.Convert``1(System.Object)">
            <summary>转换为对象</summary>
            <typeparam name="T"></typeparam>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Remoting.JsonEncoder.Convert(System.Object,System.Type)">
            <summary>转换为目标类型</summary>
            <param name="obj"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryCodec2">
            <summary>二进制编码解码器</summary>
        </member>
        <member name="P:NewLife.Serialization.BinaryCodec2.EncodedInt">
            <summary>使用7位编码整数。默认true使用</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryCodec2.Write(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>对象转二进制</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryCodec2.Read(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>二进制转对象</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonCodec2">
            <summary>Json编码解码器</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonCodec2.Write(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>对象转Json</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonCodec2.Read(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>Json转对象</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonCodec`1">
            <summary>Json编码解码器</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonCodec`1.Write(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>对象转Json</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonCodec`1.Read(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>Json转对象</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryCodec`1">
            <summary>二进制编码解码器</summary>
        </member>
        <member name="P:NewLife.Serialization.BinaryCodec`1.EncodedInt">
            <summary>使用7位编码整数。默认true使用</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryCodec`1.Write(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>对象转二进制</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryCodec`1.Read(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>二进制转对象</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryDictionary">
            <summary>字典数据编码</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryDictionary.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryDictionary.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryDictionary.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryNormal">
            <summary>常用类型编码</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.Write(System.Byte[],System.Int32)">
            <summary>写入字节数组，自动计算长度</summary>
            <param name="buffer">缓冲区</param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组，如果count小于0，则先读取字节数组长度。</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryNormal.ReadChars(System.Int32)">
            <summary>从当前流中读取 count 个字符，以字符数组的形式返回数据，并根据所使用的 Encoding 和从流中读取的特定字符，提升当前位置。</summary>
            <param name="count">要读取的字符数。</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryList">
            <summary>列表数据编码</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryList.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryList.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryList.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Binary">
            <summary>二进制序列化</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.EncodeInt">
            <summary>使用7位编码整数。默认false不使用</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.IsLittleEndian">
            <summary>小端字节序。默认false大端</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.UseFieldSize">
            <summary>使用指定大小的FieldSizeAttribute特性，默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.UseRef">
            <summary>使用对象引用，默认true</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.SizeWidth">
            <summary>大小宽度。可选0/1/2/4，默认0表示压缩编码整数</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.IgnoreMembers">
            <summary>要忽略的成员</summary>
        </member>
        <member name="P:NewLife.Serialization.Binary.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="M:NewLife.Serialization.Binary.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.Binary.AddHandler(NewLife.Serialization.IBinaryHandler)">
            <summary>添加处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.AddHandler``1(System.Int32)">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.GetHandler``1">
            <summary>获取处理器</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.Write(System.Byte)">
            <summary>写入字节</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Binary.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流，不写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="offset">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteSize(System.Int32)">
            <summary>写入大小，如果有FieldSize则返回，否则写入编码的大小</summary>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.WriteEncoded(System.Int32)">
            <summary>写7位压缩编码整数</summary>
            <remarks>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </remarks>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.Read(System.Type)">
            <summary>读取指定类型对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.Read``1">
            <summary>读取指定类型对象</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadSize">
            <summary>读取大小</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadIntBytes(System.Int32)">
            <summary>读取整数的字节数组，某些写入器（如二进制写入器）可能需要改变字节顺序</summary>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadInt16">
            <summary>从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadInt32">
            <summary>从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadEncodedInt16">
            <summary>以压缩格式读取16位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadEncodedInt32">
            <summary>以压缩格式读取32位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.ReadEncodedInt64">
            <summary>以压缩格式读取64位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.EnableTrace">
            <summary>使用跟踪流。实际上是重新包装一次Stream，必须在设置Stream后，使用之前</summary>
        </member>
        <member name="M:NewLife.Serialization.Binary.FastRead``1(System.IO.Stream,System.Boolean)">
            <summary>快速读取</summary>
            <typeparam name="T"></typeparam>
            <param name="stream">数据流</param>
            <param name="encodeInt">使用7位编码整数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Binary.FastWrite(System.Object,System.Boolean)">
            <summary>快速写入</summary>
            <param name="value">对象</param>
            <param name="encodeInt">使用7位编码整数</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryComposite">
            <summary>复合对象处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryComposite.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryComposite.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryComposite.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryComposite.GetMembers(System.Type,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryPair">
            <summary>二进制名值对</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.WritePair(System.String,System.Object)">
            <summary>写入名值对</summary>
            <param name="name"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.ReadPair">
            <summary>读取原始名值对</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.ReadPair(System.IO.Stream,System.Text.Encoding)">
            <summary>读取原始名值对</summary>
            <param name="ms">数据流</param>
            <param name="encoding">编码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.TryReadPair(System.Collections.Generic.IDictionary{System.String,System.Byte[]},System.String,System.Type,System.Object@)">
            <summary>从原始名值对读取数据</summary>
            <param name="dic"></param>
            <param name="name"></param>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryPair.GetMembers(System.Type,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.FieldSizeAttribute">
            <summary>字段大小特性。</summary>
            <remarks>
            可以通过Size指定字符串或数组的固有大小，为0表示自动计算；也可以通过指定参考字段ReferenceName，然后从其中获取大小。
            支持_Header._Questions形式的多层次引用字段
            </remarks>
        </member>
        <member name="P:NewLife.Serialization.FieldSizeAttribute.Size">
            <summary>大小。使用<see cref="P:NewLife.Serialization.FieldSizeAttribute.ReferenceName"/>时，作为偏移量；0表示自动计算大小</summary>
        </member>
        <member name="P:NewLife.Serialization.FieldSizeAttribute.ReferenceName">
            <summary>参考大小字段名</summary>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.Int32)">
            <summary>通过Size指定字符串或数组的固有大小，为0表示自动计算</summary>
            <param name="size"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.String)">
            <summary>指定参考字段ReferenceName，然后从其中获取大小</summary>
            <param name="referenceName"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.#ctor(System.String,System.Int32)">
            <summary>指定参考字段ReferenceName，然后从其中获取大小</summary>
            <param name="referenceName"></param>
            <param name="size">在参考字段值基础上的增量，可以是正数负数</param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.FindReference(System.Object,System.Reflection.MemberInfo,System.Object@)">
            <summary>找到所引用的参考字段</summary>
            <param name="target">目标对象</param>
            <param name="member">目标对象的成员</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.SetReferenceSize(System.Object,System.Reflection.MemberInfo,System.Text.Encoding)">
            <summary>设置目标对象的引用大小值</summary>
            <param name="target">目标对象</param>
            <param name="member"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Serialization.FieldSizeAttribute.GetReferenceSize(System.Object,System.Reflection.MemberInfo)">
            <summary>获取目标对象的引用大小值</summary>
            <param name="target">目标对象</param>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryGeneral">
            <summary>二进制基础类型处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns>是否处理成功</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Byte)">
            <summary>将一个无符号字节写入</summary>
            <param name="value">要写入的无符号字节。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Byte[])">
            <summary>将字节数组写入，如果设置了UseSize，则先写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流，不写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="offset">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Byte[],System.Int32)">
            <summary>写入字节数组，自动计算长度</summary>
            <param name="buffer">缓冲区</param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Int16)">
            <summary>将 2 字节有符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Int32)">
            <summary>将 4 字节有符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Int64)">
            <summary>将 8 字节有符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节有符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.WriteIntBytes(System.Byte[])">
            <summary>判断字节顺序</summary>
            <param name="buffer">缓冲区</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.UInt16)">
            <summary>将 2 字节无符号整数写入当前流，并将流的位置提升 2 个字节。</summary>
            <param name="value">要写入的 2 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.UInt32)">
            <summary>将 4 字节无符号整数写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.UInt64)">
            <summary>将 8 字节无符号整数写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节无符号整数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Single)">
            <summary>将 4 字节浮点值写入当前流，并将流的位置提升 4 个字节。</summary>
            <param name="value">要写入的 4 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Double)">
            <summary>将 8 字节浮点值写入当前流，并将流的位置提升 8 个字节。</summary>
            <param name="value">要写入的 8 字节浮点值。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Decimal)">
            <summary>将一个十进制值写入当前流，并将流位置提升十六个字节。</summary>
            <param name="value">要写入的十进制值。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Char)">
            <summary>将 Unicode 字符写入当前流，并根据所使用的 Encoding 和向流中写入的特定字符，提升流的当前位置。</summary>
            <param name="ch">要写入的非代理项 Unicode 字符。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.Char[],System.Int32,System.Int32)">
            <summary>将字符数组部分写入当前流，并根据所使用的 Encoding（可能还根据向流中写入的特定字符），提升流的当前位置。</summary>
            <param name="chars">包含要写入的数据的字符数组。</param>
            <param name="index">chars 中开始写入的起始点。</param>
            <param name="count">要写入的字符数。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value">要写入的值。</param>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadByte">
            <summary>从当前流中读取下一个字节，并使流的当前位置提升 1 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组，如果count小于0，则先读取字节数组长度。</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadIntBytes(System.Int32)">
            <summary>读取整数的字节数组，某些写入器（如二进制写入器）可能需要改变字节顺序</summary>
            <param name="count">数量</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadInt16">
            <summary>从当前流中读取 2 字节有符号整数，并使流的当前位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadInt32">
            <summary>从当前流中读取 4 字节有符号整数，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadInt64">
            <summary>从当前流中读取 8 字节有符号整数，并使流的当前位置向前移动 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadUInt16">
            <summary>使用 Little-Endian 编码从当前流中读取 2 字节无符号整数，并将流的位置提升 2 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadUInt32">
            <summary>从当前流中读取 4 字节无符号整数并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadUInt64">
            <summary>从当前流中读取 8 字节无符号整数并使流的当前位置提升 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadSingle">
            <summary>从当前流中读取 4 字节浮点值，并使流的当前位置提升 4 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadDouble">
            <summary>从当前流中读取 8 字节浮点值，并使流的当前位置提升 8 个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadChar">
            <summary>从当前流中读取下一个字符，并根据所使用的 Encoding 和从流中读取的特定字符，提升流的当前位置。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadString">
            <summary>从当前流中读取一个字符串。字符串有长度前缀，一次 7 位地被编码为整数。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadDecimal">
            <summary>从当前流中读取十进制数值，并将该流的当前位置提升十六个字节。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadEncodedInt16">
            <summary>以压缩格式读取16位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadEncodedInt32">
            <summary>以压缩格式读取32位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.ReadEncodedInt64">
            <summary>以压缩格式读取64位整数</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.WriteEncoded(System.Int16)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.WriteEncoded(System.Int32)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryGeneral.WriteEncoded(System.Int64)">
            <summary>
            以7位压缩格式写入64位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="T:NewLife.Serialization.IBinary">
            <summary>二进制序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.EncodeInt">
            <summary>编码整数</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.IsLittleEndian">
            <summary>小端字节序。默认false大端</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.UseFieldSize">
            <summary>使用指定大小的FieldSizeAttribute特性，默认false</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.IgnoreMembers">
            <summary>要忽略的成员</summary>
        </member>
        <member name="P:NewLife.Serialization.IBinary.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="M:NewLife.Serialization.IBinary.Write(System.Byte)">
            <summary>写入字节</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IBinary.Write(System.Byte[],System.Int32,System.Int32)">
            <summary>将字节数组部分写入当前流，不写入数组长度。</summary>
            <param name="buffer">包含要写入的数据的字节数组。</param>
            <param name="offset">buffer 中开始写入的起始点。</param>
            <param name="count">要写入的字节数。</param>
        </member>
        <member name="M:NewLife.Serialization.IBinary.WriteSize(System.Int32)">
            <summary>写入大小</summary>
            <param name="size">要写入的大小值</param>
            <returns>返回特性指定的固定长度，如果没有则返回-1</returns>
        </member>
        <member name="M:NewLife.Serialization.IBinary.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IBinary.ReadBytes(System.Int32)">
            <summary>从当前流中将 count 个字节读入字节数组</summary>
            <param name="count">要读取的字节数。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IBinary.ReadSize">
            <summary>读取大小</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IBinaryHandler">
            <summary>二进制读写处理器接口</summary>
        </member>
        <member name="T:NewLife.Serialization.BinaryHandlerBase">
            <summary>二进制读写处理器基类</summary>
        </member>
        <member name="T:NewLife.Serialization.BinaryUnknown">
            <summary>内部对象处理器。对于其它处理器无法支持的类型，一律由该处理器解决</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryUnknown.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryUnknown.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryUnknown.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryFont">
            <summary>字体处理器。</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryFont.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryFont.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryFont.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.BinaryColor">
            <summary>颜色处理器。</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryColor.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.BinaryColor.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.BinaryColor.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IMemberAccessor">
            <summary>成员序列化访问器。接口实现者可以在这里完全自定义序列化行为</summary>
        </member>
        <member name="M:NewLife.Serialization.IMemberAccessor.Read(NewLife.Serialization.IFormatterX,System.Reflection.MemberInfo)">
            <summary>从数据流中读取消息</summary>
            <param name="fm">序列化</param>
            <param name="member">成员</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IMemberAccessor.Write(NewLife.Serialization.IFormatterX,System.Reflection.MemberInfo)">
            <summary>把消息写入到数据流中</summary>
            <param name="fm">序列化</param>
            <param name="member">成员</param>
        </member>
        <member name="T:NewLife.Serialization.IAccessor">
            <summary>序列化访问器。接口实现者可以在这里完全自定义序列化行为</summary>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.Read(System.IO.Stream,System.Object)">
            <summary>从数据流中读取消息</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Serialization.IAccessor.Write(System.IO.Stream,System.Object)">
            <summary>把消息写入到数据流中</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="T:NewLife.Serialization.AccessorHelper">
            <summary>访问器助手</summary>
        </member>
        <member name="M:NewLife.Serialization.AccessorHelper.ToPacket(NewLife.Serialization.IAccessor,System.Object)">
            <summary>支持访问器的对象转数据包</summary>
            <param name="accessor">访问器</param>
            <param name="context">上下文</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.AccessorHelper.AccessorRead(System.Type,NewLife.Data.Packet,System.Object)">
            <summary>通过访问器读取</summary>
            <param name="type"></param>
            <param name="pk"></param>
            <param name="context">上下文</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.AccessorHelper.ToEntity``1(NewLife.Data.Packet,System.Object)">
            <summary>通过访问器转换数据包为实体对象</summary>
            <typeparam name="T"></typeparam>
            <param name="pk"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IFormatterX">
            <summary>序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Stream">
            <summary>数据流</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Hosts">
            <summary>主对象</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Encoding">
            <summary>文本编码</summary>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.UseProperty">
            <summary>序列化属性而不是字段。默认true</summary>
        </member>
        <member name="M:NewLife.Serialization.IFormatterX.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IFormatterX.Read(System.Type)">
            <summary>读取指定类型对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IFormatterX.Read``1">
            <summary>读取指定类型对象</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IFormatterX.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.IFormatterX.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="T:NewLife.Serialization.IHandler`1">
            <summary>序列化处理器接口</summary>
            <typeparam name="THost"></typeparam>
        </member>
        <member name="P:NewLife.Serialization.IHandler`1.Host">
            <summary>宿主读写器</summary>
        </member>
        <member name="P:NewLife.Serialization.IHandler`1.Priority">
            <summary>优先级</summary>
        </member>
        <member name="M:NewLife.Serialization.IHandler`1.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IHandler`1.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.FormatterBase">
            <summary>序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Stream">
            <summary>数据流。默认实例化一个内存数据流</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Hosts">
            <summary>主对象</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Member">
            <summary>成员</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Encoding">
            <summary>字符串编码，默认Default</summary>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.UseProperty">
            <summary>序列化属性而不是字段。默认true</summary>
        </member>
        <member name="M:NewLife.Serialization.FormatterBase.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.FormatterBase.GetBytes">
            <summary>获取流里面的数据</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Serialization.FormatterBase.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="M:NewLife.Serialization.FormatterBase.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Serialization.HandlerBase`2">
            <summary>读写处理器基类</summary>
        </member>
        <member name="P:NewLife.Serialization.HandlerBase`2.Host">
            <summary>宿主读写器</summary>
        </member>
        <member name="P:NewLife.Serialization.HandlerBase`2.Priority">
            <summary>优先级</summary>
        </member>
        <member name="M:NewLife.Serialization.HandlerBase`2.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.HandlerBase`2.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.HandlerBase`2.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Serialization.IJsonHost">
            <summary>Json序列化接口</summary>
        </member>
        <member name="M:NewLife.Serialization.IJsonHost.Write(System.Object,System.Boolean)">
            <summary>写入对象，得到Json字符串</summary>
            <param name="value"></param>
            <param name="indented">是否缩进</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IJsonHost.Read(System.String,System.Type)">
            <summary>从Json字符串中读取对象</summary>
            <param name="json"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IJsonHost.Convert(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="obj"></param>
            <param name="targetType"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonHelper">
            <summary>Json助手</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonHelper.Default">
            <summary>默认实现</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.ToJson(System.Object,System.Boolean)">
            <summary>写入对象，得到Json字符串</summary>
            <param name="value"></param>
            <param name="indented">是否缩进</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.ToJsonEntity(System.String,System.Type)">
            <summary>从Json字符串中读取对象</summary>
            <param name="json"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.ToJsonEntity``1(System.String)">
            <summary>从Json字符串中读取对象</summary>
            <typeparam name="T"></typeparam>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.Format(System.String)">
            <summary>格式化Json文本</summary>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHelper.Convert``1(System.Object)">
            <summary>Json类型对象转换实体类</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonNet.Support">
            <summary>是否支持</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Json">
            <summary>Json序列化</summary>
        </member>
        <member name="P:NewLife.Serialization.Json.Indented">
            <summary>是否缩进</summary>
        </member>
        <member name="P:NewLife.Serialization.Json.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="M:NewLife.Serialization.Json.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.Json.AddHandler(NewLife.Serialization.IJsonHandler)">
            <summary>添加处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.AddHandler``1(System.Int32)">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.GetHandler``1">
            <summary>获取处理器</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Json.Write(System.Text.StringBuilder,System.Object)">
            <summary>写入</summary>
            <param name="sb"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.Json.Read(System.Type)">
            <summary>读取指定类型对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.Read``1">
            <summary>读取指定类型对象</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.Read(System.String)">
            <summary>读取</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Json.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonComposite">
            <summary>复合对象处理器</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonComposite.IgnoreMembers">
            <summary>要忽略的成员</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonComposite.GetMembers(System.Type,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonGeneral">
            <summary>Json基础类型处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonGeneral.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonGeneral.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonGeneral.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonArray">
            <summary>列表数据编码</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonArray.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonArray.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonArray.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonArray.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IJson">
            <summary>IJson序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.IJson.Indented">
            <summary>是否缩进</summary>
        </member>
        <member name="P:NewLife.Serialization.IJson.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="M:NewLife.Serialization.IJson.Write(System.String)">
            <summary>写入字符串</summary>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IJson.Write(System.Text.StringBuilder,System.Object)">
            <summary>写入</summary>
            <param name="sb"></param>
            <param name="value"></param>
        </member>
        <member name="M:NewLife.Serialization.IJson.Read(System.String)">
            <summary>读取</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IJson.ReadByte">
            <summary>读取字节</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IJsonHandler">
            <summary>IJson读写处理器接口</summary>
        </member>
        <member name="M:NewLife.Serialization.IJsonHandler.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="T:NewLife.Serialization.JsonHandlerBase">
            <summary>IJson读写处理器基类</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonHandlerBase.GetString(System.Object)">
            <summary>获取对象的Json字符串表示形式。</summary>
            <param name="value"></param>
            <returns>返回null表示不支持</returns>
        </member>
        <member name="M:NewLife.Serialization.JsonHandlerBase.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns>是否处理成功</returns>
        </member>
        <member name="T:NewLife.Serialization.JsonParser">
            <summary>Json分析器</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonParser.Token">
            <summary>标识符</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Curly_Open">
            <summary>左大括号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Curly_Close">
            <summary>右大括号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Squared_Open">
            <summary>左方括号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Squared_Close">
            <summary>右方括号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Colon">
            <summary>冒号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Comma">
            <summary>逗号</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.String">
            <summary>字符串</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Number">
            <summary>数字</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.True">
            <summary>布尔真</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.False">
            <summary>布尔真</summary>
        </member>
        <member name="F:NewLife.Serialization.JsonParser.Token.Null">
            <summary>空值</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonParser.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="json"></param>
        </member>
        <member name="M:NewLife.Serialization.JsonParser.Decode">
            <summary>解码</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonParser.SkipToken">
            <summary>读取一个Token</summary>
        </member>
        <member name="T:NewLife.Serialization.JsonReader">
            <summary>Json读取器</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonReader.UseUTCDateTime">
            <summary>是否使用UTC时间</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.Read``1(System.String)">
            <summary>读取Json到指定类型</summary>
            <typeparam name="T"></typeparam>
            <param name="json"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.Read(System.String,System.Type)">
            <summary>读取Json到指定类型</summary>
            <param name="json"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ToObject(System.Object,System.Type,System.Object)">
            <summary>Json字典或列表转为具体类型对象</summary>
            <param name="jobj">Json对象</param>
            <param name="type">模板类型</param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ParseList(System.Collections.Generic.IList{System.Object},System.Type,System.Object)">
            <summary>转为泛型列表</summary>
            <param name="vlist"></param>
            <param name="type"></param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ParseArray(System.Collections.Generic.IList{System.Object},System.Type,System.Object)">
            <summary>转为数组</summary>
            <param name="list"></param>
            <param name="type"></param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ParseDictionary(System.Collections.Generic.IDictionary{System.String,System.Object},System.Type,System.Collections.IDictionary)">
            <summary>转为泛型字典</summary>
            <param name="dic"></param>
            <param name="type"></param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.ParseObject(System.Collections.Generic.IDictionary{System.String,System.Object},System.Type,System.Object)">
            <summary>字典转复杂对象，反射属性赋值</summary>
            <param name="dic"></param>
            <param name="type"></param>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.JsonReader.CreateDateTime(System.Object)">
            <summary>创建时间</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.JsonWriter">
            <summary>Json写入器</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.UseUTCDateTime">
            <summary>使用UTC时间</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.LowerCaseName">
            <summary>使用小写名称</summary>
        </member>
        <member name="P:NewLife.Serialization.JsonWriter.NullValue">
            <summary>写入空值</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.JsonWriter.ToJson(System.Object,System.Boolean)">
            <summary>对象序列化为Json字符串</summary>
            <param name="obj"></param>
            <param name="indented"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Accessor">
            <summary>访问器基类</summary>
        </member>
        <member name="M:NewLife.Serialization.Accessor.Read(System.IO.Stream,System.Object)">
            <summary>从数据流中读取消息</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Serialization.Accessor.Write(System.IO.Stream,System.Object)">
            <summary>把消息写入到数据流中</summary>
            <param name="stream">数据流</param>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Serialization.Accessor.ToPacket">
            <summary>消息转为字节数组</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Accessor.CreateFormatter(System.Boolean)">
            <summary>创建序列化器</summary>
            <param name="isRead"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Accessor.ToString">
            <summary>输出消息实体</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Accessor.GetMember(System.Reflection.PropertyInfo,System.Int32,System.Text.StringBuilder)">
            <summary>获取成员输出</summary>
            <param name="pi"></param>
            <param name="len"></param>
            <param name="sb"></param>
        </member>
        <member name="M:NewLife.Serialization.Accessor.GetMemberValue(System.Reflection.PropertyInfo)">
            <summary>获取用于输出的成员值</summary>
            <param name="pi"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.Accessor`1">
            <summary>访问器泛型基类</summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:NewLife.Serialization.Accessor`1.Read(System.IO.Stream)">
            <summary>从流中读取消息</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Accessor`1.Read(NewLife.Data.Packet)">
            <summary>从字节数组中读取消息</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.SerialHelper">
            <summary>序列化助手</summary>
        </member>
        <member name="M:NewLife.Serialization.SerialHelper.GetName(System.Reflection.PropertyInfo)">
            <summary>获取序列化名称</summary>
            <param name="pi"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.XmlList">
            <summary>列表数据编码</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlList.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlList.Write(System.Object,System.Type)">
            <summary>写入</summary>
            <param name="value"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.XmlList.TryRead(System.Type,System.Object@)">
            <summary>读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.XmlComposite">
            <summary>Xml复合对象处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlComposite.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlComposite.Write(System.Object,System.Type)">
            <summary>写入对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.XmlComposite.TryRead(System.Type,System.Object@)">
            <summary>尝试读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.XmlComposite.GetMembers(System.Type)">
            <summary>获取成员</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.XmlGeneral">
            <summary>Xml基础类型处理器</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlGeneral.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.XmlGeneral.Write(System.Object,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="type">类型</param>
            <returns>是否处理成功</returns>
        </member>
        <member name="M:NewLife.Serialization.XmlGeneral.TryRead(System.Type,System.Object@)">
            <summary>尝试读取</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IXml">
            <summary>二进制序列化接口</summary>
        </member>
        <member name="P:NewLife.Serialization.IXml.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="P:NewLife.Serialization.IXml.UseComment">
            <summary>使用注释</summary>
        </member>
        <member name="M:NewLife.Serialization.IXml.Write(System.Object,System.String,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="name">名称</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IXml.GetWriter">
            <summary>获取Xml写入器</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.IXml.GetReader">
            <summary>获取Xml读取器</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Serialization.IXmlHandler">
            <summary>二进制读写处理器接口</summary>
        </member>
        <member name="T:NewLife.Serialization.XmlHandlerBase">
            <summary>Xml读写处理器基类</summary>
        </member>
        <member name="T:NewLife.Serialization.Xml">
            <summary>Xml序列化</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.Depth">
            <summary>深度</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.Handlers">
            <summary>处理器列表</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.UseAttribute">
            <summary>使用特性</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.UseComment">
            <summary>使用注释</summary>
        </member>
        <member name="P:NewLife.Serialization.Xml.CurrentName">
            <summary>当前名称</summary>
        </member>
        <member name="M:NewLife.Serialization.Xml.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Serialization.Xml.AddHandler(NewLife.Serialization.IXmlHandler)">
            <summary>添加处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.AddHandler``1(System.Int32)">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
            <param name="priority"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.Write(System.Object,System.String,System.Type)">
            <summary>写入一个对象</summary>
            <param name="value">目标对象</param>
            <param name="name">名称</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.WriteStart(System.Type)">
            <summary>写入开头</summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.Xml.WriteEnd">
            <summary>写入结尾</summary>
        </member>
        <member name="M:NewLife.Serialization.Xml.GetWriter">
            <summary>获取Xml写入器</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.Read(System.Type)">
            <summary>读取指定类型对象</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.Read``1">
            <summary>读取指定类型对象</summary>
            <typeparam name="T"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.TryRead(System.Type,System.Object@)">
            <summary>尝试读取指定类型对象</summary>
            <param name="type"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.ReadStart(System.Type)">
            <summary>读取开始</summary>
            <param name="type"></param>
        </member>
        <member name="M:NewLife.Serialization.Xml.ReadEnd">
            <summary>读取结束</summary>
        </member>
        <member name="M:NewLife.Serialization.Xml.GetReader">
            <summary>获取Xml读取器</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Serialization.Xml.GetString">
            <summary>获取字符串</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Handlers.StandardCodec">
            <summary>标准网络封包。头部4字节定长</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.Write(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>写入数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.AddToQueue(NewLife.Net.Handlers.IHandlerContext,NewLife.Messaging.IMessage)">
            <summary>加入队列</summary>
            <param name="context"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.Decode(NewLife.Net.Handlers.IHandlerContext,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="context"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.StandardCodec.IsMatch(System.Object,System.Object)">
            <summary>是否匹配响应</summary>
            <param name="request"></param>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Handlers.LengthFieldCodec">
            <summary>长度字段作为头部</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.LengthFieldCodec.Offset">
            <summary>长度所在位置</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.LengthFieldCodec.Size">
            <summary>长度占据字节数，1/2/4个字节，0表示压缩编码整数，默认2</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.LengthFieldCodec.Expire">
            <summary>过期时间，超过该时间后按废弃数据处理，默认500ms</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.LengthFieldCodec.Encode(NewLife.Net.Handlers.IHandlerContext,NewLife.Data.Packet)">
            <summary>编码</summary>
            <param name="context"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.LengthFieldCodec.Decode(NewLife.Net.Handlers.IHandlerContext,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="context"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Handlers.MessageCodec`1">
            <summary>消息封包</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.MessageCodec`1.Queue">
            <summary>消息队列。用于匹配请求响应包</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.MessageCodec`1.Timeout">
            <summary>调用超时时间。默认30_000ms</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.MessageCodec`1.UserPacket">
            <summary>使用数据包，写入时数据包转消息，读取时消息自动解包返回数据负载。默认true</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Write(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>写入数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Encode(NewLife.Net.Handlers.IHandlerContext,`0)">
            <summary>编码</summary>
            <param name="context"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.AddToQueue(NewLife.Net.Handlers.IHandlerContext,`0)">
            <summary>加入队列</summary>
            <param name="context"></param>
            <param name="msg"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Read(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>读取数据</summary>
            <param name="context"></param>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Decode(NewLife.Net.Handlers.IHandlerContext,NewLife.Data.Packet)">
            <summary>解码</summary>
            <param name="context"></param>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.IsMatch(System.Object,System.Object)">
            <summary>是否匹配响应</summary>
            <param name="request"></param>
            <param name="response"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.Parse(NewLife.Data.Packet,NewLife.Net.Handlers.CodecItem,System.Func{NewLife.Data.Packet,System.Int32},System.Int32)">
            <summary>分析数据流，得到一帧数据</summary>
            <param name="pk">待分析数据包</param>
            <param name="codec">参数</param>
            <param name="getLength">获取长度</param>
            <param name="expire">缓存有效期</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.MessageCodec`1.GetLength(NewLife.Data.Packet,System.Int32,System.Int32)">
            <summary>从数据流中获取整帧数据长度</summary>
            <param name="pk"></param>
            <param name="offset"></param>
            <param name="size"></param>
            <returns>数据帧长度（包含头部长度位）</returns>
        </member>
        <member name="T:NewLife.Net.Handlers.CodecItem">
            <summary>消息编码参数</summary>
        </member>
        <member name="F:NewLife.Net.Handlers.CodecItem.Stream">
            <summary>缓存流</summary>
        </member>
        <member name="F:NewLife.Net.Handlers.CodecItem.Last">
            <summary>最后一次接收</summary>
        </member>
        <member name="T:NewLife.Net.Handlers.IHandler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.IHandler.Prev">
            <summary>上一个处理器</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.IHandler.Next">
            <summary>下一个处理器</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.IHandler.Read(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>读取数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Net.Handlers.IHandler.Write(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>写入数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Net.Handlers.IHandler.Open(NewLife.Net.Handlers.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Net.Handlers.IHandler.Close(NewLife.Net.Handlers.IHandlerContext,System.String)">
            <summary>关闭连接</summary>
            <param name="context">上下文</param>
            <param name="reason">原因</param>
        </member>
        <member name="M:NewLife.Net.Handlers.IHandler.Error(NewLife.Net.Handlers.IHandlerContext,System.Exception)">
            <summary>发生错误</summary>
            <param name="context">上下文</param>
            <param name="exception">异常</param>
        </member>
        <member name="T:NewLife.Net.Handlers.Handler">
            <summary>处理器</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.Handler.Prev">
            <summary>上一个处理器</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.Handler.Next">
            <summary>下一个处理器</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.Handler.Read(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>读取数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Net.Handlers.Handler.Write(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>写入数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Net.Handlers.Handler.Open(NewLife.Net.Handlers.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Net.Handlers.Handler.Close(NewLife.Net.Handlers.IHandlerContext,System.String)">
            <summary>关闭连接</summary>
            <param name="context">上下文</param>
            <param name="reason">原因</param>
        </member>
        <member name="M:NewLife.Net.Handlers.Handler.Error(NewLife.Net.Handlers.IHandlerContext,System.Exception)">
            <summary>发生错误</summary>
            <param name="context">上下文</param>
            <param name="exception">异常</param>
        </member>
        <member name="T:NewLife.Net.Handlers.IHandlerContext">
            <summary>处理器上下文</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.IHandlerContext.Pipeline">
            <summary>管道</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.IHandlerContext.Session">
            <summary>远程连接</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.IHandlerContext.Data">
            <summary>数据帧</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.IHandlerContext.FireRead(System.Object)">
            <summary>处理收到消息</summary>
            <param name="message"></param>
        </member>
        <member name="T:NewLife.Net.Handlers.HandlerContext">
            <summary>处理器上下文</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.HandlerContext.Pipeline">
            <summary>管道</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.HandlerContext.Session">
            <summary>远程连接</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.HandlerContext.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Net.Handlers.HandlerContext.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.Handlers.HandlerContext.Data">
            <summary>数据帧</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.HandlerContext.FireRead(System.Object)">
            <summary>处理收到消息</summary>
            <param name="message"></param>
        </member>
        <member name="T:NewLife.Net.Handlers.IMatchQueue">
            <summary>消息匹配队列接口。用于把响应数据包配对到请求包</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.IMatchQueue.Add(System.Object,System.Object,System.Int32,System.Threading.Tasks.TaskCompletionSource{System.Object})">
            <summary>加入请求队列</summary>
            <param name="owner">拥有者</param>
            <param name="request">请求消息</param>
            <param name="msTimeout">超时取消时间</param>
            <param name="source">任务源</param>
        </member>
        <member name="M:NewLife.Net.Handlers.IMatchQueue.Match(System.Object,System.Object,System.Object,System.Func{System.Object,System.Object,System.Boolean})">
            <summary>检查请求队列是否有匹配该响应的请求</summary>
            <param name="owner">拥有者</param>
            <param name="response">响应消息</param>
            <param name="result">任务结果</param>
            <param name="callback">用于检查匹配的回调</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Handlers.DefaultMatchQueue">
            <summary>消息匹配队列。子类可重载以自定义请求响应匹配逻辑</summary>
        </member>
        <member name="M:NewLife.Net.Handlers.DefaultMatchQueue.Add(System.Object,System.Object,System.Int32,System.Threading.Tasks.TaskCompletionSource{System.Object})">
            <summary>加入请求队列</summary>
            <param name="owner">拥有者</param>
            <param name="request">请求的数据</param>
            <param name="msTimeout">超时取消时间</param>
            <param name="source">任务源</param>
        </member>
        <member name="M:NewLife.Net.Handlers.DefaultMatchQueue.Match(System.Object,System.Object,System.Object,System.Func{System.Object,System.Object,System.Boolean})">
            <summary>检查请求队列是否有匹配该响应的请求</summary>
            <param name="owner">拥有者</param>
            <param name="response">响应消息</param>
            <param name="result">任务结果</param>
            <param name="callback">用于检查匹配的回调</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Handlers.DefaultMatchQueue.Check(System.Object)">
            <summary>定时检查发送队列，超时未收到响应则重发</summary>
            <param name="state"></param>
        </member>
        <member name="T:NewLife.Net.INetSession">
            <summary>网络服务会话接口</summary>
            <remarks>
            所有应用服务器以会话<see cref="T:NewLife.Net.INetSession"/>作为业务处理核心。
            应用服务器收到新会话请求后，通过<see cref="M:NewLife.Net.INetSession.Start"/>启动一个会话处理。
            会话进行业务处理的过程中，可以通过多个Send方法向客户端发送数据。
            </remarks>
        </member>
        <member name="P:NewLife.Net.INetSession.ID">
            <summary>编号</summary>
        </member>
        <member name="P:NewLife.Net.INetSession.Host">
            <summary>主服务</summary>
        </member>
        <member name="P:NewLife.Net.INetSession.Server">
            <summary>Socket服务器。当前通讯所在的Socket服务器，其实是TcpServer/UdpServer</summary>
        </member>
        <member name="P:NewLife.Net.INetSession.Session">
            <summary>客户端。跟客户端通讯的那个Socket，其实是服务端TcpSession/UdpSession</summary>
        </member>
        <member name="P:NewLife.Net.INetSession.Remote">
            <summary>客户端地址</summary>
        </member>
        <member name="M:NewLife.Net.INetSession.Start">
            <summary>开始会话处理。</summary>
        </member>
        <member name="M:NewLife.Net.INetSession.Send(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <param name="pk">数据包</param>
        </member>
        <member name="M:NewLife.Net.INetSession.Send(System.IO.Stream)">
            <summary>发送数据流</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.INetSession.Send(System.String,System.Text.Encoding)">
            <summary>发送字符串</summary>
            <param name="msg"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Net.INetSession.SendAsync(System.Object)">
            <summary>异步发送并等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.INetSession.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="T:NewLife.Net.NetSessionEventArgs">
            <summary>会话事件参数</summary>
        </member>
        <member name="P:NewLife.Net.NetSessionEventArgs.Session">
            <summary>会话</summary>
        </member>
        <member name="T:NewLife.Net.ISocket">
            <summary>基础Socket接口</summary>
            <remarks>
            封装所有基础接口的共有特性！
            
            核心设计理念：事件驱动，接口统一，简单易用！
            异常处理理念：确保主流程简单易用，特殊情况的异常通过事件处理！
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocket.Name">
            <summary>名称。主要用于日志输出</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Client">
            <summary>基础Socket对象</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Local">
            <summary>本地地址</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Pipeline">
            <summary>管道</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.ThrowException">
            <summary>是否抛出异常，默认false不抛出。Send/Receive时可能发生异常，该设置决定是直接抛出异常还是通过<see cref="E:NewLife.Net.ISocket.Error"/>事件</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.ProcessAsync">
            <summary>异步处理接收到的数据。</summary>
            <remarks>异步处理有可能造成数据包乱序，特别是Tcp。true利于提升网络吞吐量。false避免拷贝，提升处理速度</remarks>
        </member>
        <member name="P:NewLife.Net.ISocket.StatSend">
            <summary>发送统计</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.StatReceive">
            <summary>接收统计</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.ISocket.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="M:NewLife.Net.ISocket.WriteLog(System.String,System.Object[])">
            <summary>已重载。日志加上前缀</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="E:NewLife.Net.ISocket.Error">
            <summary>错误发生/断开连接时</summary>
        </member>
        <member name="T:NewLife.Net.ISocketRemote">
            <summary>远程通信Socket，仅具有收发功能</summary>
        </member>
        <member name="P:NewLife.Net.ISocketRemote.Remote">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Net.ISocketRemote.StartTime">
            <summary>通信开始时间</summary>
        </member>
        <member name="P:NewLife.Net.ISocketRemote.LastTime">
            <summary>最后一次通信时间，主要表示会话活跃时间，包括收发</summary>
        </member>
        <member name="P:NewLife.Net.ISocketRemote.BufferSize">
            <summary>缓冲区大小</summary>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.Send(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.ISocketRemote.Remote"/>决定
            </remarks>
            <param name="pk">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.Receive">
            <summary>接收数据。阻塞当前线程等待返回</summary>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.ISocketRemote.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.SendMessageAsync(System.Object)">
            <summary>异步发送数据并等待响应</summary>
            <param name="message">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.SendMessage(System.Object)">
            <summary>发送消息</summary>
            <param name="message">消息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.ISocketRemote.Receive(NewLife.Data.IData)">
            <summary>处理数据帧</summary>
            <param name="data">数据帧</param>
        </member>
        <member name="T:NewLife.Net.SocketRemoteHelper">
            <summary>远程通信Socket扩展</summary>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.GetStat(NewLife.Net.ISocketRemote)">
            <summary>获取统计信息</summary>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.Send(NewLife.Net.ISocketRemote,System.IO.Stream)">
            <summary>发送数据流</summary>
            <param name="session">会话</param>
            <param name="stream">数据流</param>
            <returns>返回是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.Send(NewLife.Net.ISocketRemote,System.String,System.Text.Encoding)">
            <summary>发送字符串</summary>
            <param name="session">会话</param>
            <param name="msg">要发送的字符串</param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.SendMulti(NewLife.Net.ISocketRemote,NewLife.Data.Packet,System.Int32,System.Int32)">
            <summary>异步多次发送数据</summary>
            <param name="session">会话</param>
            <param name="pk">数据包</param>
            <param name="times">次数</param>
            <param name="msInterval">间隔</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.ReceiveString(NewLife.Net.ISocketRemote,System.Text.Encoding)">
            <summary>接收字符串</summary>
            <param name="session">会话</param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.Add``1(NewLife.Net.ISocket)">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
            <param name="session">会话</param>
        </member>
        <member name="M:NewLife.Net.SocketRemoteHelper.Add(NewLife.Net.ISocket,NewLife.Net.Handlers.IHandler)">
            <summary>添加处理器</summary>
            <param name="session">会话</param>
            <param name="handler">处理器</param>
        </member>
        <member name="T:NewLife.Net.ISocketServer">
            <summary>Socket服务器接口</summary>
        </member>
        <member name="P:NewLife.Net.ISocketServer.Active">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Net.ISocketServer.SessionTimeout">
            <summary>会话超时时间。默认20*60秒</summary>
            <remarks>
            对于每一个会话连接，如果超过该时间仍然没有收到任何数据，则断开会话连接。
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocketServer.StatSession">
            <summary>会话统计</summary>
        </member>
        <member name="P:NewLife.Net.ISocketServer.Sessions">
            <summary>会话集合。用地址端口作为标识，业务应用自己维持地址端口与业务主键的对应关系。</summary>
        </member>
        <member name="E:NewLife.Net.ISocketServer.NewSession">
            <summary>新会话时触发</summary>
        </member>
        <member name="T:NewLife.Net.SocketServerHelper">
            <summary>服务端通信Socket扩展</summary>
        </member>
        <member name="M:NewLife.Net.SocketServerHelper.GetStat(NewLife.Net.ISocketServer)">
            <summary>获取统计信息</summary>
            <param name="socket"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.ISocketClient">
            <summary>Socket客户端</summary>
            <remarks>
            具备打开关闭
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocketClient.Timeout">
            <summary>超时。默认3000ms</summary>
        </member>
        <member name="P:NewLife.Net.ISocketClient.Active">
            <summary>是否活动</summary>
        </member>
        <member name="M:NewLife.Net.ISocketClient.Open">
            <summary>打开</summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.ISocketClient.Close(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns>是否成功</returns>
        </member>
        <member name="E:NewLife.Net.ISocketClient.Opened">
            <summary>打开后触发。</summary>
        </member>
        <member name="E:NewLife.Net.ISocketClient.Closed">
            <summary>关闭后触发。可实现掉线重连</summary>
        </member>
        <member name="T:NewLife.Net.NetException">
            <summary>网络异常</summary>
        </member>
        <member name="M:NewLife.Net.NetException.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.Net.NetException.#ctor(System.String)">
            <summary>初始化</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.Net.NetException.#ctor(System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetException.#ctor(System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.Net.NetException.#ctor(System.Exception)">
            <summary>初始化</summary>
            <param name="innerException"></param>
        </member>
        <member name="T:NewLife.Net.NetServer">
            <summary>网络服务器。可同时支持多个Socket服务器，同时支持IPv4和IPv6，同时支持Tcp和Udp</summary>
            <remarks>
            网络服务器模型，所有网络应用服务器可以通过继承该类实现。
            该类仅实现了业务应用对网络流的操作，与具体网络协议无关。
            
            收到请求<see cref="M:NewLife.Net.NetServer.Server_NewSession(System.Object,NewLife.Net.SessionEventArgs)"/>后，会建立<see cref="M:NewLife.Net.NetServer.CreateSession(NewLife.Net.ISocketSession)"/>会话，并加入到会话集合<see cref="P:NewLife.Net.NetServer.Sessions"/>中，然后启动<see cref="M:NewLife.Net.NetServer.Start"/>会话处理；
            
            快速用法：
            指定端口后直接<see cref="M:NewLife.Net.NetServer.Start"/>，NetServer将同时监听Tcp/Udp和IPv4/IPv6（会检查是否支持）四个端口。
            
            简单用法：
            重载方法<see cref="M:NewLife.Net.NetServer.EnsureCreateServer"/>来创建一个SocketServer并赋值给<see cref="P:NewLife.Net.NetServer.Server"/>属性，<see cref="M:NewLife.Net.NetServer.EnsureCreateServer"/>将会在<see cref="M:NewLife.Net.NetServer.OnStart"/>时首先被调用。
            
            标准用法：
            使用<see cref="M:NewLife.Net.NetServer.AttachServer(NewLife.Net.ISocketServer)"/>方法向网络服务器添加Socket服务，其中第一个将作为默认Socket服务<see cref="P:NewLife.Net.NetServer.Server"/>。
            如果Socket服务集合<see cref="P:NewLife.Net.NetServer.Servers"/>为空，将依据地址<see cref="P:NewLife.Net.NetServer.Local"/>、端口<see cref="P:NewLife.Net.NetServer.Port"/>、地址族<see cref="P:NewLife.Net.NetServer.AddressFamily"/>、协议<see cref="P:NewLife.Net.NetServer.ProtocolType"/>创建默认Socket服务。
            如果地址族<see cref="P:NewLife.Net.NetServer.AddressFamily"/>指定为IPv4和IPv6以外的值，将同时创建IPv4和IPv6两个Socket服务；
            如果协议<see cref="P:NewLife.Net.NetServer.ProtocolType"/>指定为Tcp和Udp以外的值，将同时创建Tcp和Udp两个Socket服务；
            默认情况下，地址族<see cref="P:NewLife.Net.NetServer.AddressFamily"/>和协议<see cref="P:NewLife.Net.NetServer.ProtocolType"/>都是其它值，所以一共将会创建四个Socket服务（Tcp、Tcpv6、Udp、Udpv6）。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetServer.Name">
            <summary>服务名</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Local">
            <summary>本地结点</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.ProtocolType">
            <summary>协议类型</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.AddressFamily">
            <summary>寻址方案</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Servers">
            <summary>服务器集合</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Server">
            <summary>服务器。返回服务器集合中的第一个服务器</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Active">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SessionTimeout">
            <summary>会话超时时间。默认0秒，使用SocketServer默认值</summary>
            <remarks>
            对于每一个会话连接，如果超过该时间仍然没有收到任何数据，则断开会话连接。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetServer.Pipeline">
            <summary>管道</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.UseSession">
            <summary>使用会话集合，允许遍历会话。默认true</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.StatSession">
            <summary>会话统计</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.StatSend">
            <summary>发送统计</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.StatReceive">
            <summary>接收统计</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Items">
            <summary>用户会话数据</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.Item(System.String)">
            <summary>获取/设置 用户会话数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.#ctor">
            <summary>实例化一个网络服务器</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.#ctor(System.Int32)">
            <summary>通过指定监听地址和端口实例化一个网络服务器</summary>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.#ctor(System.Net.IPAddress,System.Int32)">
            <summary>通过指定监听地址和端口实例化一个网络服务器</summary>
            <param name="address"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.#ctor(System.Net.IPAddress,System.Int32,NewLife.Net.NetType)">
            <summary>通过指定监听地址和端口，还有协议，实例化一个网络服务器，默认支持Tcp协议和Udp协议</summary>
            <param name="address"></param>
            <param name="port"></param>
            <param name="protocolType"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnDispose(System.Boolean)">
            <summary>已重载。释放会话集合等资源</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.AttachServer(NewLife.Net.ISocketServer)">
            <summary>添加Socket服务器</summary>
            <param name="server"></param>
            <returns>添加是否成功</returns>
        </member>
        <member name="M:NewLife.Net.NetServer.AddServer(System.Net.IPAddress,System.Int32,NewLife.Net.NetType,System.Net.Sockets.AddressFamily)">
            <summary>同时添加指定端口的IPv4和IPv6服务器，如果协议不是指定的Tcp或Udp，则同时添加Tcp和Udp服务器</summary>
            <param name="address"></param>
            <param name="port"></param>
            <param name="protocol"></param>
            <param name="family"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.EnsureCreateServer">
            <summary>确保建立服务器</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.Add``1">
            <summary>添加处理器</summary>
            <typeparam name="THandler"></typeparam>
        </member>
        <member name="M:NewLife.Net.NetServer.Add(NewLife.Net.Handlers.IHandler)">
            <summary>添加处理器</summary>
            <param name="handler">处理器</param>
        </member>
        <member name="M:NewLife.Net.NetServer.Start">
            <summary>开始服务</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.OnStart">
            <summary>开始时调用的方法</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.Stop(System.String)">
            <summary>停止服务</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnStop">
            <summary>停止时调用的方法</summary>
        </member>
        <member name="E:NewLife.Net.NetServer.NewSession">
            <summary>新会话，对于TCP是新连接，对于UDP是新客户端</summary>
        </member>
        <member name="E:NewLife.Net.NetServer.Received">
            <summary>某个会话的数据到达。sender是ISocketSession</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.Server_NewSession(System.Object,NewLife.Net.SessionEventArgs)">
            <summary>接受连接时，对于Udp是收到数据时（同时触发OnReceived）。</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnNewSession(NewLife.Net.ISocketSession)">
            <summary>收到连接时，建立会话，并挂接数据接收和错误处理事件</summary>
            <param name="session"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnReceived(System.Object,NewLife.Net.ReceivedEventArgs)">
            <summary>收到数据时</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.OnReceive(NewLife.Net.INetSession,System.IO.Stream)">
            <summary>收到数据时，最原始的数据处理，但不影响会话内部的数据处理</summary>
            <param name="session"></param>
            <param name="stream"></param>
        </member>
        <member name="E:NewLife.Net.NetServer.Error">
            <summary>错误发生/断开连接时。sender是ISocketSession</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.OnError(System.Object,NewLife.ExceptionEventArgs)">
            <summary>触发异常</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="P:NewLife.Net.NetServer.Sessions">
            <summary>会话集合。用自增的数字ID作为标识，业务应用自己维持ID与业务主键的对应关系。</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SessionCount">
            <summary>会话数</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.MaxSessionCount">
            <summary>最高会话数</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.AddSession(NewLife.Net.INetSession)">
            <summary>添加会话。子类可以在添加会话前对会话进行一些处理</summary>
            <param name="session"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.CreateSession(NewLife.Net.ISocketSession)">
            <summary>创建会话</summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.GetSession(System.Int32)">
            <summary>根据会话ID查找会话</summary>
            <param name="sessionid"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.SendAllAsync(System.Byte[])">
            <summary>异步群发</summary>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.CreateServer(System.Net.IPAddress,System.Int32,NewLife.Net.NetType,System.Net.Sockets.AddressFamily)">
            <summary>创建Tcp/Udp、IPv4/IPv6服务</summary>
            <param name="address"></param>
            <param name="port"></param>
            <param name="protocol"></param>
            <param name="family"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer.GetStat">
            <summary>获取统计信息</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.NetServer.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SocketLog">
            <summary>用于内部Socket服务器的日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.SessionLog">
            <summary>用于网络会话的日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.NetServer.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.NetServer.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.WriteError(System.String,System.Object[])">
            <summary>输出错误日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetServer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.NetServer`1">
            <summary>网络服务器</summary>
            <typeparam name="TSession"></typeparam>
        </member>
        <member name="M:NewLife.Net.NetServer`1.CreateSession(NewLife.Net.ISocketSession)">
            <summary>创建会话</summary>
            <param name="session"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetServer`1.GetSession(System.Int32)">
            <summary>获取指定标识的会话</summary>
            <param name="id"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.NetSession`1">
            <summary>网络服务的会话</summary>
            <typeparam name="TServer">网络服务类型</typeparam>
        </member>
        <member name="P:NewLife.Net.NetSession`1.Host">
            <summary>主服务</summary>
        </member>
        <member name="T:NewLife.Net.NetSession">
            <summary>网络服务的会话</summary>
            <remarks>
            实际应用可通过重载OnReceive实现收到数据时的业务逻辑。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetSession.ID">
            <summary>编号</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.NewLife#Net#INetSession#Host">
            <summary>主服务</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Session">
            <summary>客户端。跟客户端通讯的那个Socket，其实是服务端TcpSession/UdpServer</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Server">
            <summary>服务端</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Remote">
            <summary>客户端地址</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Items">
            <summary>用户会话数据</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.Item(System.String)">
            <summary>获取/设置 用户会话数据</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetSession.Start">
            <summary>开始会话处理。</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.OnDispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）</param>
        </member>
        <member name="M:NewLife.Net.NetSession.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>收到客户端发来的数据，触发<seealso cref="E:NewLife.Net.NetSession.Received"/>事件，重载者可直接处理数据</summary>
            <param name="e"></param>
        </member>
        <member name="E:NewLife.Net.NetSession.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.Send(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <param name="pk">数据包</param>
        </member>
        <member name="M:NewLife.Net.NetSession.Send(System.IO.Stream)">
            <summary>发送数据流</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetSession.Send(System.String,System.Text.Encoding)">
            <summary>发送字符串</summary>
            <param name="msg"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.SendAsync(System.Object)">
            <summary>异步发送并等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetSession.OnError(System.Object,NewLife.ExceptionEventArgs)">
            <summary>错误处理</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="P:NewLife.Net.NetSession.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.LogSession">
            <summary>是否记录会话日志</summary>
        </member>
        <member name="P:NewLife.Net.NetSession.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.NetSession.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.WriteError(System.String,System.Object[])">
            <summary>输出错误日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.NetSession.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.IPipeline">
            <summary>管道。进站顺序，出站逆序</summary>
        </member>
        <member name="P:NewLife.Net.IPipeline.Head">
            <summary>头部处理器</summary>
        </member>
        <member name="P:NewLife.Net.IPipeline.Tail">
            <summary>尾部处理器</summary>
        </member>
        <member name="M:NewLife.Net.IPipeline.AddFirst(NewLife.Net.Handlers.IHandler)">
            <summary>添加处理器到开头</summary>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.IPipeline.AddLast(NewLife.Net.Handlers.IHandler)">
            <summary>添加处理器到末尾</summary>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.IPipeline.AddBefore(NewLife.Net.Handlers.IHandler,NewLife.Net.Handlers.IHandler)">
            <summary>添加处理器到指定名称之前</summary>
            <param name="baseHandler">基准处理器</param>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.IPipeline.AddAfter(NewLife.Net.Handlers.IHandler,NewLife.Net.Handlers.IHandler)">
            <summary>添加处理器到指定名称之后</summary>
            <param name="baseHandler">基准处理器</param>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.IPipeline.Remove(NewLife.Net.Handlers.IHandler)">
            <summary>删除处理器</summary>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.IPipeline.CreateContext(NewLife.Net.ISocketRemote)">
            <summary>创建上下文</summary>
            <param name="session">远程会话</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.IPipeline.Read(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>读取数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Net.IPipeline.Write(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>写入数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Net.IPipeline.FireWrite(NewLife.Net.ISocketRemote,System.Object)">
            <summary>写入数据</summary>
            <param name="session">远程会话</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Net.IPipeline.FireWriteAndWait(NewLife.Net.ISocketRemote,System.Object)">
            <summary>写入数据</summary>
            <param name="session">远程会话</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Net.IPipeline.Open(NewLife.Net.Handlers.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Net.IPipeline.Close(NewLife.Net.Handlers.IHandlerContext,System.String)">
            <summary>关闭连接</summary>
            <param name="context">上下文</param>
            <param name="reason">原因</param>
        </member>
        <member name="M:NewLife.Net.IPipeline.Error(NewLife.Net.Handlers.IHandlerContext,System.Exception)">
            <summary>发生错误</summary>
            <param name="context">上下文</param>
            <param name="exception">异常</param>
        </member>
        <member name="T:NewLife.Net.Pipeline">
            <summary>管道。进站顺序，出站逆序</summary>
        </member>
        <member name="P:NewLife.Net.Pipeline.Head">
            <summary>头部处理器</summary>
        </member>
        <member name="P:NewLife.Net.Pipeline.Tail">
            <summary>尾部处理器</summary>
        </member>
        <member name="M:NewLife.Net.Pipeline.AddFirst(NewLife.Net.Handlers.IHandler)">
            <summary>添加处理器到开头</summary>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Pipeline.AddLast(NewLife.Net.Handlers.IHandler)">
            <summary>添加处理器到末尾</summary>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Pipeline.AddBefore(NewLife.Net.Handlers.IHandler,NewLife.Net.Handlers.IHandler)">
            <summary>添加处理器到指定名称之前</summary>
            <param name="baseHandler">基准处理器</param>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Pipeline.AddAfter(NewLife.Net.Handlers.IHandler,NewLife.Net.Handlers.IHandler)">
            <summary>添加处理器到指定名称之后</summary>
            <param name="baseHandler">基准处理器</param>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Pipeline.Remove(NewLife.Net.Handlers.IHandler)">
            <summary>删除处理器</summary>
            <param name="handler">处理器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Pipeline.CreateContext(NewLife.Net.ISocketRemote)">
            <summary>创建上下文</summary>
            <param name="session">远程会话</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Pipeline.Read(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>读取数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Net.Pipeline.Write(NewLife.Net.Handlers.IHandlerContext,System.Object)">
            <summary>写入数据，返回结果作为下一个处理器消息</summary>
            <param name="context">上下文</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Net.Pipeline.FireWrite(NewLife.Net.ISocketRemote,System.Object)">
            <summary>写入数据</summary>
            <param name="session">远程会话</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Net.Pipeline.FireWriteAndWait(NewLife.Net.ISocketRemote,System.Object)">
            <summary>写入数据</summary>
            <param name="session">远程会话</param>
            <param name="message">消息</param>
        </member>
        <member name="M:NewLife.Net.Pipeline.Open(NewLife.Net.Handlers.IHandlerContext)">
            <summary>打开连接</summary>
            <param name="context">上下文</param>
        </member>
        <member name="M:NewLife.Net.Pipeline.Close(NewLife.Net.Handlers.IHandlerContext,System.String)">
            <summary>关闭连接</summary>
            <param name="context">上下文</param>
            <param name="reason">原因</param>
        </member>
        <member name="M:NewLife.Net.Pipeline.Error(NewLife.Net.Handlers.IHandlerContext,System.Exception)">
            <summary>发生错误</summary>
            <param name="context">上下文</param>
            <param name="exception">异常</param>
        </member>
        <member name="M:NewLife.Net.Pipeline.GetEnumerator">
            <summary>枚举器</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.ReceivedEventArgs">
            <summary>收到数据时的事件参数</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Packet">
            <summary>数据包</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Data">
            <summary>数据</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Length">
            <summary>数据长度</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Stream">
            <summary>数据区对应的一个数据流实例</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Remote">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.Message">
            <summary>解码后的消息</summary>
        </member>
        <member name="P:NewLife.Net.ReceivedEventArgs.UserState">
            <summary>用户数据</summary>
        </member>
        <member name="M:NewLife.Net.ReceivedEventArgs.#ctor">
            <summary>实例化一个数据事件参数</summary>
        </member>
        <member name="M:NewLife.Net.ReceivedEventArgs.#ctor(NewLife.Data.Packet)">
            <summary>使用字节数组实例化一个数据事件参数</summary>
            <param name="pk"></param>
        </member>
        <member name="M:NewLife.Net.ReceivedEventArgs.#ctor(NewLife.Data.IData)">
            <summary>使用数据帧实例化</summary>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.Net.ReceivedEventArgs.ToStr(System.Text.Encoding)">
            <summary>以字符串表示</summary>
            <param name="encoding">字符串编码，默认URF-8</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.ReceivedEventArgs.ToHex(System.Int32,System.String,System.Int32)">
            <summary>以十六进制编码表示</summary>
            <param name="maxLength">最大显示多少个字节。默认-1显示全部</param>
            <param name="separate">分隔符</param>
            <param name="groupSize">分组大小，为0时对每个字节应用分隔符，否则对每个分组使用</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.ITransport">
            <summary>帧数据传输接口</summary>
            <remarks>实现者确保数据以包的形式传输，屏蔽数据的粘包和拆包</remarks>
        </member>
        <member name="P:NewLife.Net.ITransport.Timeout">
            <summary>超时</summary>
        </member>
        <member name="M:NewLife.Net.ITransport.Open">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Net.ITransport.Close">
            <summary>关闭</summary>
        </member>
        <member name="M:NewLife.Net.ITransport.Send(NewLife.Data.Packet)">
            <summary>写入数据</summary>
            <param name="pk">数据包</param>
        </member>
        <member name="M:NewLife.Net.ITransport.Receive">
            <summary>读取数据</summary>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.ITransport.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="T:NewLife.Net.NetType">
            <summary>协议类型</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Unknown">
            <summary>未知协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Tcp">
            <summary>传输控制协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Udp">
            <summary>用户数据报协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Http">
            <summary>Http协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.Https">
            <summary>Https协议</summary>
        </member>
        <member name="F:NewLife.Net.NetType.WebSocket">
            <summary>WebSocket协议</summary>
        </member>
        <member name="T:NewLife.Net.NetUri">
            <summary>网络资源标识，指定协议、地址、端口、地址族（IPv4/IPv6）</summary>
            <remarks>
            仅序列化<see cref="P:NewLife.Net.NetUri.Type"/>和<see cref="P:NewLife.Net.NetUri.EndPoint"/>，其它均是配角！
            有可能<see cref="P:NewLife.Net.NetUri.Host"/>代表主机域名，而<see cref="P:NewLife.Net.NetUri.Address"/>指定主机IP地址。
            </remarks>
        </member>
        <member name="P:NewLife.Net.NetUri.Type">
            <summary>协议类型</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.Host">
            <summary>主机</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.Address">
            <summary>地址</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.EndPoint">
            <summary>终结点</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.IsTcp">
            <summary>是否Tcp协议</summary>
        </member>
        <member name="P:NewLife.Net.NetUri.IsUdp">
            <summary>是否Udp协议</summary>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor(NewLife.Net.NetType,System.Net.IPEndPoint)">
            <summary>实例化</summary>
            <param name="protocol"></param>
            <param name="endpoint"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor(NewLife.Net.NetType,System.Net.IPAddress,System.Int32)">
            <summary>实例化</summary>
            <param name="protocol"></param>
            <param name="address"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.#ctor(NewLife.Net.NetType,System.String,System.Int32)">
            <summary>实例化</summary>
            <param name="protocol"></param>
            <param name="host"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.Parse(System.String)">
            <summary>分析</summary>
            <param name="uri"></param>
        </member>
        <member name="M:NewLife.Net.NetUri.ParseAddress(System.String)">
            <summary>分析地址</summary>
            <param name="hostname">主机地址</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetUri.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.NetUri.op_Implicit(System.String)~NewLife.Net.NetUri">
            <summary>重载类型转换，字符串直接转为NetUri对象</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.SerialTransport">
            <summary>串口传输</summary>
            <example>
            标准例程：
            <code>
            var st = new SerialTransport();
            st.PortName = "COM65";  // 通讯口
            st.FrameSize = 16;      // 数据帧大小
            
            st.Received += (s, e) =>
            {
                Console.WriteLine("收到 {0}", e.ToHex());
            };
            // 开始异步操作
            st.Open();
            
            //var buf = "01080000801A".ToHex();
            var buf = "0111C02C".ToHex();
            for (int i = 0; i &lt; 100; i++)
            {
                Console.WriteLine("发送 {0}", buf.ToHex());
                st.Send(buf);
            
                Thread.Sleep(1000);
            }
            </code>
            </example>
        </member>
        <member name="P:NewLife.Net.SerialTransport.Serial">
            <summary>串口对象</summary>
        </member>
        <member name="P:NewLife.Net.SerialTransport.PortName">
            <summary>端口名称。默认COM1</summary>
        </member>
        <member name="P:NewLife.Net.SerialTransport.BaudRate">
            <summary>波特率。默认115200</summary>
        </member>
        <member name="P:NewLife.Net.SerialTransport.Parity">
            <summary>奇偶校验位。默认None</summary>
        </member>
        <member name="P:NewLife.Net.SerialTransport.DataBits">
            <summary>数据位。默认8</summary>
        </member>
        <member name="P:NewLife.Net.SerialTransport.StopBits">
            <summary>停止位。默认One</summary>
        </member>
        <member name="P:NewLife.Net.SerialTransport.Timeout">
            <summary>超时时间。超过该大小未收到数据，说明是另一帧。默认10ms</summary>
        </member>
        <member name="P:NewLife.Net.SerialTransport.Description">
            <summary>描述信息</summary>
        </member>
        <member name="P:NewLife.Net.SerialTransport.ByteTimeout">
            <summary>字节超时。数据包间隔，默认20ms</summary>
        </member>
        <member name="M:NewLife.Net.SerialTransport.#ctor">
            <summary>串口传输</summary>
        </member>
        <member name="M:NewLife.Net.SerialTransport.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.SerialTransport.EnsureCreate">
            <summary>确保创建</summary>
        </member>
        <member name="M:NewLife.Net.SerialTransport.Open">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Net.SerialTransport.Close">
            <summary>关闭</summary>
        </member>
        <member name="M:NewLife.Net.SerialTransport.Send(NewLife.Data.Packet)">
            <summary>写入数据</summary>
            <param name="pk">数据包</param>
        </member>
        <member name="M:NewLife.Net.SerialTransport.SendAsync(NewLife.Data.Packet)">
            <summary>异步发送数据并等待响应</summary>
            <param name="pk"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SerialTransport.Receive">
            <summary>接收数据</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SerialTransport.OnReceive(NewLife.Data.Packet)">
            <summary>处理收到的数据。默认匹配同步接收委托</summary>
            <param name="pk"></param>
        </member>
        <member name="E:NewLife.Net.SerialTransport.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="E:NewLife.Net.SerialTransport.Disconnected">
            <summary>断开时触发，可能是人为断开，也可能是串口链路断开</summary>
        </member>
        <member name="M:NewLife.Net.SerialTransport.CheckDisconnect(System.Object)">
            <summary>检查串口是否已经断开</summary>
            <remarks>
            FX串口异步操作有严重的泄漏缺陷，如果外部硬件长时间断开，
            SerialPort.IsOpen检测不到，并且会无限大占用内存。
            </remarks>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Net.SerialTransport.GetPortNames">
            <summary>获取带有描述的串口名，没有时返回空数组</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SerialTransport.GetNames">
            <summary>获取串口列表，名称和描述</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SerialTransport.Choose(System.String)">
            <summary>从串口列表选择串口，支持自动选择关键字</summary>
            <param name="keyWord">串口名称或者描述符的关键字</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.SerialTransport.Log">
            <summary>日志对象</summary>
        </member>
        <member name="M:NewLife.Net.SerialTransport.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.SerialTransport.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.Setting">
            <summary>网络设置</summary>
        </member>
        <member name="P:NewLife.Net.Setting.Debug">
            <summary>网络调试</summary>
        </member>
        <member name="P:NewLife.Net.Setting.SessionTimeout">
            <summary>会话超时时间。默认20*60秒</summary>
        </member>
        <member name="P:NewLife.Net.Setting.BufferSize">
            <summary>缓冲区大小。默认64k</summary>
        </member>
        <member name="M:NewLife.Net.Setting.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="T:NewLife.Net.SocketHelper">
            <summary>Socket扩展</summary>
        </member>
        <member name="M:NewLife.Net.SocketHelper.SendAsync(System.Net.Sockets.Socket,System.Byte[])">
            <summary>异步发送数据</summary>
            <param name="socket"></param>
            <param name="buffer"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.SendToAsync(System.Net.Sockets.Socket,System.Byte[],System.Net.IPEndPoint)">
            <summary>异步发送数据</summary>
            <param name="socket"></param>
            <param name="buffer"></param>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Send(System.Net.Sockets.Socket,System.IO.Stream,System.Net.IPEndPoint)">
            <summary>发送数据流</summary>
            <param name="socket"></param>
            <param name="stream"></param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Send(System.Net.Sockets.Socket,System.Byte[],System.Net.IPEndPoint)">
            <summary>向指定目的地发送信息</summary>
            <param name="socket"></param>
            <param name="buffer">缓冲区</param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Send(System.Net.Sockets.Socket,System.String,System.Text.Encoding,System.Net.IPEndPoint)">
            <summary>向指定目的地发送信息</summary>
            <param name="socket"></param>
            <param name="message"></param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Broadcast(System.Net.Sockets.Socket,System.Byte[],System.Int32)">
            <summary>广播数据包</summary>
            <param name="socket"></param>
            <param name="buffer">缓冲区</param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Broadcast(System.Net.Sockets.Socket,System.String,System.Int32)">
            <summary>广播字符串</summary>
            <param name="socket"></param>
            <param name="message"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.SocketHelper.ReceiveString(System.Net.Sockets.Socket,System.Text.Encoding)">
            <summary>接收字符串</summary>
            <param name="socket"></param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.CheckBroadcast(System.Net.Sockets.Socket,System.Net.IPAddress)">
            <summary>检查并开启广播</summary>
            <param name="socket"></param>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.Shutdown(System.Net.Sockets.Socket,System.Boolean)">
            <summary>关闭连接</summary>
            <param name="socket"></param>
            <param name="reuseAddress"></param>
        </member>
        <member name="P:NewLife.Net.SocketHelper.mSafeHandle">
            <summary>SafeHandle字段</summary>
        </member>
        <member name="M:NewLife.Net.SocketHelper.IsNotClosed(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>Socket是否未被关闭</summary>
            <param name="se"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SocketHelper.GetException(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>根据异步事件获取可输出异常，屏蔽常见异常</summary>
            <param name="se"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.TcpSession">
            <summary>增强TCP客户端</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.ID">
            <summary>会话编号</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.DisconnectWhenEmptyData">
            <summary>收到空数据时抛出异常并断开连接。默认true</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.NewLife#Net#ISocketSession#Server">
            <summary>Socket服务器。当前通讯所在的Socket服务器，其实是TcpServer/UdpServer。该属性决定本会话是客户端会话还是服务的会话</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.AutoReconnect">
            <summary>自动重连次数，默认3。发生异常断开连接时，自动重连服务端。</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.MatchEmpty">
            <summary>是否匹配空包。Http协议需要</summary>
        </member>
        <member name="M:NewLife.Net.TcpSession.#ctor">
            <summary>实例化增强TCP</summary>
        </member>
        <member name="M:NewLife.Net.TcpSession.#ctor(System.Int32)">
            <summary>使用监听口初始化</summary>
            <param name="listenPort"></param>
        </member>
        <member name="M:NewLife.Net.TcpSession.#ctor(System.Net.Sockets.Socket)">
            <summary>用TCP客户端初始化</summary>
            <param name="client"></param>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnOpen">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnClose(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnSend(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.SessionBase.Remote"/>决定
            </remarks>
            <param name="pk">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnPreReceive(NewLife.Data.Packet,System.Net.IPEndPoint)">
            <summary>预处理</summary>
            <param name="pk">数据包</param>
            <param name="remote">远程地址</param>
            <returns>将要处理该数据包的会话</returns>
        </member>
        <member name="M:NewLife.Net.TcpSession.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>处理收到的数据</summary>
            <param name="e">接收事件参数</param>
        </member>
        <member name="F:NewLife.Net.TcpSession._Reconnect">
            <summary>重连次数</summary>
        </member>
        <member name="P:NewLife.Net.TcpSession.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.TcpSession.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.TcpServer">
            <summary>TCP服务器</summary>
            <remarks>
            核心工作：启动服务<see cref="M:NewLife.Net.TcpServer.Start"/>时，监听端口，并启用多个（逻辑处理器数的10倍）异步接受操作<see cref="M:NewLife.Net.TcpServer.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs,System.Boolean)"/>。
            
            服务器完全处于异步工作状态，任何操作都不可能被阻塞。
            
            注意：服务器接受连接请求后，不会开始处理数据，而是由<see cref="E:NewLife.Net.TcpServer.NewSession"/>事件订阅者决定何时开始处理数据。
            </remarks>
        </member>
        <member name="P:NewLife.Net.TcpServer.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Local">
            <summary>本地绑定信息</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.SessionTimeout">
            <summary>会话超时时间</summary>
            <remarks>
            对于每一个会话连接，如果超过该时间仍然没有收到任何数据，则断开会话连接。
            </remarks>
        </member>
        <member name="P:NewLife.Net.TcpServer.ProcessAsync">
            <summary>异步处理接收到的数据，默认false。</summary>
            <remarks>异步处理有可能造成数据包乱序，特别是Tcp。true利于提升网络吞吐量。false避免拷贝，提升处理速度</remarks>
        </member>
        <member name="P:NewLife.Net.TcpServer.Client">
            <summary>底层Socket</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Active">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.ThrowException">
            <summary>是否抛出异常，默认false不抛出。Send/Receive时可能发生异常，该设置决定是直接抛出异常还是通过<see cref="E:NewLife.Net.TcpServer.Error"/>事件</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.MaxAsync">
            <summary>最大并行接收连接数。默认CPU*1.6</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.EnableHttp">
            <summary>启用Http，数据处理时截去请求响应头，默认false</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Pipeline">
            <summary>管道</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.StatSession">
            <summary>会话统计</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.StatSend">
            <summary>发送统计</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.StatReceive">
            <summary>接收统计</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.#ctor">
            <summary>构造TCP服务器对象</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.#ctor(System.Int32)">
            <summary>构造TCP服务器对象</summary>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.TcpServer.OnDispose(System.Boolean)">
            <summary>已重载。释放会话集合等资源</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.TcpServer.Start">
            <summary>开始</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.Stop(System.String)">
            <summary>停止</summary>
            <param name="reason">关闭原因。便于日志分析</param>
        </member>
        <member name="E:NewLife.Net.TcpServer.NewSession">
            <summary>新会话时触发</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs,System.Boolean)">
            <summary>开启异步接受新连接</summary>
            <param name="se"></param>
            <param name="io">是否IO线程</param>
            <returns>开启异步是否成功</returns>
        </member>
        <member name="M:NewLife.Net.TcpServer.OnAccept(System.Net.Sockets.Socket)">
            <summary>收到新连接时处理</summary>
            <param name="client"></param>
        </member>
        <member name="P:NewLife.Net.TcpServer.Sessions">
            <summary>会话集合。用地址端口作为标识，业务应用自己维持地址端口与业务主键的对应关系。</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.CreateSession(System.Net.Sockets.Socket)">
            <summary>创建会话</summary>
            <param name="client"></param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.TcpServer.Error">
            <summary>错误发生/断开连接时</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.OnError(System.String,System.Exception)">
            <summary>触发异常</summary>
            <param name="action">动作</param>
            <param name="ex">异常</param>
        </member>
        <member name="P:NewLife.Net.TcpServer.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.Log">
            <summary>日志对象</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.TcpServer.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="M:NewLife.Net.TcpServer.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.TcpServer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.SessionCollection">
            <summary>会话集合。带有自动清理不活动会话的功能</summary>
        </member>
        <member name="P:NewLife.Net.SessionCollection.Server">
            <summary>服务端</summary>
        </member>
        <member name="P:NewLife.Net.SessionCollection.ClearPeriod">
            <summary>清理周期。单位毫秒，默认10秒。</summary>
        </member>
        <member name="F:NewLife.Net.SessionCollection.clearTimer">
            <summary>清理会话计时器</summary>
        </member>
        <member name="M:NewLife.Net.SessionCollection.Add(NewLife.Net.ISocketSession)">
            <summary>添加新会话，并设置会话编号</summary>
            <param name="session"></param>
            <returns>返回添加新会话是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionCollection.Get(System.String)">
            <summary>获取会话，加锁</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionCollection.CloseAll">
            <summary>关闭所有</summary>
        </member>
        <member name="M:NewLife.Net.SessionCollection.RemoveNotAlive(System.Object)">
            <summary>移除不活动的会话</summary>
        </member>
        <member name="T:NewLife.Net.UdpServer">
            <summary>增强的UDP</summary>
            <remarks>
            如果已经打开异步接收，还要使用同步接收，则同步Receive内部不再调用底层Socket，而是等待截走异步数据。
            </remarks>
        </member>
        <member name="P:NewLife.Net.UdpServer.SessionTimeout">
            <summary>会话超时时间</summary>
            <remarks>
            对于每一个会话连接，如果超过该时间仍然没有收到任何数据，则断开会话连接。
            </remarks>
        </member>
        <member name="P:NewLife.Net.UdpServer.LastRemote">
            <summary>最后一次同步接收数据得到的远程地址</summary>
        </member>
        <member name="P:NewLife.Net.UdpServer.Loopback">
            <summary>是否接收来自自己广播的环回数据。默认false</summary>
        </member>
        <member name="P:NewLife.Net.UdpServer.StatSession">
            <summary>会话统计</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.#ctor">
            <summary>实例化增强UDP</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.#ctor(System.Int32)">
            <summary>使用监听口初始化</summary>
            <param name="listenPort"></param>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnOpen">
            <summary>打开</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnClose(System.String)">
            <summary>关闭</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnSend(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.SessionBase.Remote"/>决定
            </remarks>
            <param name="pk">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.SendMessageAsync(System.Object)">
            <summary>发送消息并等待响应。必须调用会话的发送，否则配对会失败</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnPreReceive(NewLife.Data.Packet,System.Net.IPEndPoint)">
            <summary>预处理</summary>
            <param name="pk">数据包</param>
            <param name="remote">远程地址</param>
            <returns>将要处理该数据包的会话</returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>处理收到的数据</summary>
            <param name="e">接收事件参数</param>
        </member>
        <member name="M:NewLife.Net.UdpServer.OnReceiveError(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>收到异常时如何处理。Tcp/Udp客户端默认关闭会话，但是Udp服务端不能关闭服务器，仅关闭会话</summary>
            <param name="se"></param>
            <returns>是否当作异常处理并结束会话</returns>
        </member>
        <member name="E:NewLife.Net.UdpServer.NewSession">
            <summary>新会话时触发</summary>
        </member>
        <member name="P:NewLife.Net.UdpServer.Sessions">
            <summary>会话集合。用地址端口作为标识，业务应用自己维持地址端口与业务主键的对应关系。</summary>
        </member>
        <member name="M:NewLife.Net.UdpServer.CreateSession(System.Net.IPEndPoint)">
            <summary>创建会话</summary>
            <param name="remoteEP"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpServer.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UdpHelper">
            <summary>Udp扩展</summary>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Send(System.Net.Sockets.UdpClient,System.IO.Stream,System.Net.IPEndPoint)">
            <summary>发送数据流</summary>
            <param name="udp"></param>
            <param name="stream"></param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Send(System.Net.Sockets.UdpClient,System.Byte[],System.Net.IPEndPoint)">
            <summary>向指定目的地发送信息</summary>
            <param name="udp"></param>
            <param name="buffer">缓冲区</param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Send(System.Net.Sockets.UdpClient,System.String,System.Text.Encoding,System.Net.IPEndPoint)">
            <summary>向指定目的地发送信息</summary>
            <param name="udp"></param>
            <param name="message"></param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <param name="remoteEP"></param>
            <returns>返回自身，用于链式写法</returns>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Broadcast(System.Net.Sockets.UdpClient,System.Byte[],System.Int32)">
            <summary>广播数据包</summary>
            <param name="udp"></param>
            <param name="buffer">缓冲区</param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.UdpHelper.Broadcast(System.Net.Sockets.UdpClient,System.String,System.Int32)">
            <summary>广播字符串</summary>
            <param name="udp"></param>
            <param name="message"></param>
            <param name="port"></param>
        </member>
        <member name="M:NewLife.Net.UdpHelper.ReceiveString(System.Net.Sockets.UdpClient,System.Text.Encoding)">
            <summary>接收字符串</summary>
            <param name="udp"></param>
            <param name="encoding">文本编码，默认null表示UTF-8编码</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Net.UdpSession">
            <summary>Udp会话。仅用于服务端与某一固定远程地址通信</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.ID">
            <summary>会话编号</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Server">
            <summary>服务器</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.NewLife#Net#ISocket#Client">
            <summary>底层Socket</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Local">
            <summary>本地地址</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Remote">
            <summary>远程地址</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Timeout">
            <summary>超时。默认3000ms</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Pipeline">
            <summary>管道</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.NewLife#Net#ISocketSession#Server">
            <summary>Socket服务器。当前通讯所在的Socket服务器，其实是TcpServer/UdpServer</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.ThrowException">
            <summary>是否抛出异常，默认false不抛出。Send/Receive时可能发生异常，该设置决定是直接抛出异常还是通过<see cref="E:NewLife.Net.UdpSession.Error"/>事件</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.ProcessAsync">
            <summary>异步处理接收到的数据，默认true利于提升网络吞吐量。</summary>
            <remarks>异步处理有可能造成数据包乱序，特别是Tcp。false避免拷贝，提升处理速度</remarks>
        </member>
        <member name="P:NewLife.Net.UdpSession.StatSend">
            <summary>发送数据包统计信息</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.StatReceive">
            <summary>接收数据包统计信息</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.StartTime">
            <summary>通信开始时间</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.LastTime">
            <summary>最后一次通信时间，主要表示活跃时间，包括收发</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.BufferSize">
            <summary>缓冲区大小。默认8k</summary>
        </member>
        <member name="M:NewLife.Net.UdpSession.SendMessage(System.Object)">
            <summary>发送消息</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpSession.SendMessageAsync(System.Object)">
            <summary>发送消息并等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpSession.Receive">
            <summary>接收数据</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.UdpSession.NewLife#Net#ISocketRemote#Receive(NewLife.Data.IData)">
            <summary>处理数据帧</summary>
            <param name="data">数据帧</param>
        </member>
        <member name="E:NewLife.Net.UdpSession.Error">
            <summary>错误发生/断开连接时</summary>
        </member>
        <member name="M:NewLife.Net.UdpSession.OnError(System.String,System.Exception)">
            <summary>触发异常</summary>
            <param name="action">动作</param>
            <param name="ex">异常</param>
        </member>
        <member name="M:NewLife.Net.UdpSession.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.UdpSession.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.UdpSession.Log">
            <summary>日志提供者</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.UdpSession.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="M:NewLife.Net.UdpSession.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.Net.UdpSession.WriteDebugLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.Upgrade">
            <summary>升级更新</summary>
            <remarks>
            自动更新的难点在于覆盖正在使用的exe/dll文件，通过改名可以解决
            </remarks>
        </member>
        <member name="P:NewLife.Net.Upgrade.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Server">
            <summary>服务器地址</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Version">
            <summary>版本</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Compile">
            <summary>本地编译时间</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.AutoStart">
            <summary>更新完成以后自动启动主程序</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.UpdatePath">
            <summary>更新目录</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Links">
            <summary>超链接信息，其中第一个为最佳匹配项</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.SourceFile">
            <summary>更新源文件</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.#ctor">
            <summary>实例化一个升级对象实例，获取当前应用信息</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.Check">
            <summary>获取版本信息，检查是否需要更新</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.Upgrade.Download">
            <summary>开始更新</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.Update">
            <summary>检查并执行更新操作</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.CopyAndReplace(System.String)">
            <summary>正在使用锁定的文件不可删除，但可以改名</summary>
            <param name="source"></param>
        </member>
        <member name="M:NewLife.Net.Upgrade.DeleteBuckup">
            <summary>删除备份文件</summary>
        </member>
        <member name="P:NewLife.Net.Upgrade.Log">
            <summary>日志对象</summary>
        </member>
        <member name="M:NewLife.Net.Upgrade.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.SessionBase">
            <summary>会话基类</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Local">
            <summary>本地绑定信息</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Remote">
            <summary>远程结点地址</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Timeout">
            <summary>超时。默认3000ms</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Active">
            <summary>是否活动</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Client">
            <summary>底层Socket</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.ThrowException">
            <summary>是否抛出异常，默认false不抛出。Send/Receive时可能发生异常，该设置决定是直接抛出异常还是通过<see cref="E:NewLife.Net.SessionBase.Error"/>事件</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.StatSend">
            <summary>发送数据包统计信息</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.StatReceive">
            <summary>接收数据包统计信息</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.StartTime">
            <summary>通信开始时间</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.LastTime">
            <summary>最后一次通信时间，主要表示活跃时间，包括收发</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.DynamicPort">
            <summary>是否使用动态端口。如果Port为0则为动态端口</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.MaxAsync">
            <summary>最大并行接收数。Tcp默认1，Udp默认CPU*1.6，0关闭异步接收使用同步接收</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.ProcessAsync">
            <summary>异步处理接收到的数据，Tcp默认false，Udp默认true。</summary>
            <remarks>异步处理有可能造成数据包乱序，特别是Tcp。true利于提升网络吞吐量。false避免拷贝，提升处理速度</remarks>
        </member>
        <member name="P:NewLife.Net.SessionBase.BufferSize">
            <summary>缓冲区大小。默认8k</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.#ctor">
            <summary>构造函数，初始化默认名称</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Net.SessionBase.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.Open">
            <summary>打开</summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnOpen">
            <summary>打开</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.CheckDynamic">
            <summary>检查是否动态端口。如果是动态端口，则把随机得到的端口拷贝到Port</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.Close(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnClose(System.String)">
            <summary>关闭</summary>
            <param name="reason">关闭原因。便于日志分析</param>
            <returns></returns>
        </member>
        <member name="E:NewLife.Net.SessionBase.Opened">
            <summary>打开后触发。</summary>
        </member>
        <member name="E:NewLife.Net.SessionBase.Closed">
            <summary>关闭后触发。可实现掉线重连</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.Send(NewLife.Data.Packet)">
            <summary>直接发送数据包 Byte[]/Packet</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.SessionBase.Remote"/>决定
            </remarks>
            <param name="pk">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnSend(NewLife.Data.Packet)">
            <summary>发送数据</summary>
            <remarks>
            目标地址由<seealso cref="P:NewLife.Net.SessionBase.Remote"/>决定
            </remarks>
            <param name="pk">数据包</param>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.Receive">
            <summary>接收数据</summary>
            <returns></returns>
        </member>
        <member name="F:NewLife.Net.SessionBase._RecvCount">
            <summary>当前异步接收个数</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.ReceiveAsync">
            <summary>开始异步接收</summary>
            <returns>是否成功</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.ReleaseRecv(System.Net.Sockets.SocketAsyncEventArgs,System.String)">
            <summary>释放一个事件参数</summary>
            <param name="se"></param>
            <param name="reason"></param>
        </member>
        <member name="M:NewLife.Net.SessionBase.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs,System.Boolean)">
            <summary>用一个事件参数来开始异步接收</summary>
            <param name="se">事件参数</param>
            <param name="io">是否在IO线程调用</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.ProcessReceive(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>同步或异步收到数据</summary>
            <param name="se"></param>
        </member>
        <member name="M:NewLife.Net.SessionBase.ProcessReceive(NewLife.Data.Packet,System.Net.IPEndPoint)">
            <summary>接收预处理，粘包拆包</summary>
            <param name="pk"></param>
            <param name="remote"></param>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnPreReceive(NewLife.Data.Packet,System.Net.IPEndPoint)">
            <summary>预处理</summary>
            <param name="pk">数据包</param>
            <param name="remote">远程地址</param>
            <returns>将要处理该数据包的会话</returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnReceive(NewLife.Net.ReceivedEventArgs)">
            <summary>处理收到的数据。默认匹配同步接收委托</summary>
            <param name="e">接收事件参数</param>
            <returns>是否已处理，已处理的数据不再向下传递</returns>
        </member>
        <member name="E:NewLife.Net.SessionBase.Received">
            <summary>数据到达事件</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.RaiseReceive(System.Object,NewLife.Net.ReceivedEventArgs)">
            <summary>触发数据到达事件</summary>
            <param name="sender"></param>
            <param name="e">接收事件参数</param>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnReceiveError(System.Net.Sockets.SocketAsyncEventArgs)">
            <summary>收到异常时如何处理。默认关闭会话</summary>
            <param name="se"></param>
            <returns>是否当作异常处理并结束会话</returns>
        </member>
        <member name="P:NewLife.Net.SessionBase.Pipeline">
            <summary>消息管道。收发消息都经过管道处理器</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.SendMessage(System.Object)">
            <summary>通过管道发送消息</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.SendMessageAsync(System.Object)">
            <summary>通过管道发送消息并等待响应</summary>
            <param name="message"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Net.SessionBase.NewLife#Net#ISocketRemote#Receive(NewLife.Data.IData)">
            <summary>处理数据帧</summary>
            <param name="data">数据帧</param>
        </member>
        <member name="E:NewLife.Net.SessionBase.Error">
            <summary>错误发生/断开连接时</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.OnError(System.String,System.Exception)">
            <summary>触发异常</summary>
            <param name="action">动作</param>
            <param name="ex">异常</param>
        </member>
        <member name="P:NewLife.Net.SessionBase.Items">
            <summary>数据项</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Item(System.String)">
            <summary>设置 或 获取 数据项</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Net.SessionBase.LogPrefix">
            <summary>日志前缀</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.Log">
            <summary>日志对象。禁止设为空对象</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.LogSend">
            <summary>是否输出发送日志。默认false</summary>
        </member>
        <member name="P:NewLife.Net.SessionBase.LogReceive">
            <summary>是否输出接收日志。默认false</summary>
        </member>
        <member name="M:NewLife.Net.SessionBase.WriteLog(System.String,System.Object[])">
            <summary>输出日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Net.ISocketSession">
            <summary>用于与对方进行通讯的Socket会话，仅具有收发功能，也专用于上层应用收发数据</summary>
            <remarks>
            Socket会话发送数据不需要指定远程地址，因为内部已经具有。
            接收数据时，Tcp接收全部数据，而Udp只接受来自所属远方的数据。
            
            Socket会话不具有连接和断开的能力，所以需要外部连接好之后再创建Socket会话。
            但是会话可以销毁，来代替断开。
            对于Udp额外创建的会话来说，仅仅销毁会话而已。
            
            所以，它必须具有收发数据的能力。
            </remarks>
        </member>
        <member name="P:NewLife.Net.ISocketSession.Server">
            <summary>Socket服务器。当前通讯所在的Socket服务器，其实是TcpServer/UdpServer</summary>
        </member>
        <member name="T:NewLife.Net.SessionEventArgs">
            <summary>会话事件参数</summary>
        </member>
        <member name="P:NewLife.Net.SessionEventArgs.Session">
            <summary>会话</summary>
        </member>
        <member name="T:NewLife.Net.SerialPortConfig">
            <summary>串口配置</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.PortName">
            <summary>串口名</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.BaudRate">
            <summary>波特率</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.DataBits">
            <summary>数据位</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.StopBits">
            <summary>停止位</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.Parity">
            <summary>奇偶校验</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.Encoding">
            <summary>文本编码</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.WebEncoding">
            <summary>编码</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.HexShow">
            <summary>十六进制显示</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.HexNewLine">
            <summary>十六进制自动换行</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.HexSend">
            <summary>十六进制发送</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.LastUpdate">
            <summary>最后更新时间</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.Extend">
            <summary>扩展数据</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.DtrEnable">
            <summary>DtrEnable</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.RtsEnable">
            <summary>RtsEnable</summary>
        </member>
        <member name="P:NewLife.Net.SerialPortConfig.BreakState">
            <summary>BreakState</summary>
        </member>
        <member name="T:NewLife.IDisposable2">
            <summary>具有是否已释放和释放后事件的接口</summary>
        </member>
        <member name="P:NewLife.IDisposable2.Disposed">
            <summary>是否已经释放</summary>
        </member>
        <member name="E:NewLife.IDisposable2.OnDisposed">
            <summary>被销毁时触发事件</summary>
        </member>
        <member name="T:NewLife.DisposeBase">
            <summary>具有销毁资源处理的抽象基类</summary>
            <example>
            <code>
            /// &lt;summary&gt;子类重载实现资源释放逻辑时必须首先调用基类方法&lt;/summary&gt;
            /// &lt;param name="disposing"&gt;从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            /// 因为该方法只会被调用一次，所以该参数的意义不太大。&lt;/param&gt;
            protected override void OnDispose(bool disposing)
            {
                base.OnDispose(disposing);
            
                if (disposing)
                {
                    // 如果是构造函数进来，不执行这里的代码
                }
            }
            </code>
            </example>
        </member>
        <member name="M:NewLife.DisposeBase.Dispose">
            <summary>释放资源</summary>
        </member>
        <member name="P:NewLife.DisposeBase.Disposed">
            <summary>是否已经释放</summary>
        </member>
        <member name="E:NewLife.DisposeBase.OnDisposed">
            <summary>被销毁时触发事件</summary>
        </member>
        <member name="M:NewLife.DisposeBase.Dispose(System.Boolean)">
            <summary>释放资源，参数表示是否由Dispose调用。该方法保证OnDispose只被调用一次！</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.DisposeBase.OnDispose(System.Boolean)">
            <summary>子类重载实现资源释放逻辑时必须首先调用基类方法</summary>
            <param name="disposing">从Dispose调用（释放所有资源）还是析构函数调用（释放非托管资源）。
            因为该方法只会被调用一次，所以该参数的意义不太大。</param>
        </member>
        <member name="M:NewLife.DisposeBase.Finalize">
            <summary>析构函数</summary>
            <remarks>
            如果忘记调用Dispose，这里会释放非托管资源
            如果曾经调用过Dispose，因为GC.SuppressFinalize(this)，不会再调用该析构函数
            </remarks>
        </member>
        <member name="T:NewLife.DisposeHelper">
            <summary>销毁助手。扩展方法专用</summary>
        </member>
        <member name="M:NewLife.DisposeHelper.TryDispose(System.Object)">
            <summary>尝试销毁对象，如果有<see cref="T:System.IDisposable"/>则调用</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.WeakAction`1">
            <summary>弱引用Action</summary>
            <remarks>
            常见的事件和委托，都包括两部分：对象和方法，当然如果委托到静态方法上，对象是为空的。
            如果把事件委托到某个对象的方法上，同时就间接的引用了这个对象，导致其一直无法被回收，从而造成内存泄漏。
            弱引用Action，原理就是把委托拆分，然后弱引用对象部分，需要调用委托的时候，再把对象“拉”回来，如果被回收了，就没有必要再调用它的方法了。
            </remarks>
            <typeparam name="TArgs"></typeparam>
        </member>
        <member name="F:NewLife.WeakAction`1.Target">
            <summary>目标对象。弱引用，使得调用方对象可以被GC回收</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Method">
            <summary>委托方法</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Handler">
            <summary>经过包装的新的委托</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.UnHandler">
            <summary>取消注册的委托</summary>
        </member>
        <member name="F:NewLife.WeakAction`1.Once">
            <summary>是否只使用一次，如果只使用一次，执行委托后马上取消注册</summary>
        </member>
        <member name="P:NewLife.WeakAction`1.IsAlive">
            <summary>是否可用</summary>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Object,System.Reflection.MethodInfo)">
            <summary>实例化</summary>
            <param name="target">目标对象</param>
            <param name="method">目标方法</param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Object,System.Reflection.MethodInfo,System.Action{System.Action{`0}},System.Boolean)">
            <summary>实例化</summary>
            <param name="target">目标对象</param>
            <param name="method">目标方法</param>
            <param name="unHandler">取消注册回调</param>
            <param name="once">是否一次性事件</param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Delegate)">
            <summary>实例化</summary>
            <param name="handler">事件处理器</param>
        </member>
        <member name="M:NewLife.WeakAction`1.#ctor(System.Delegate,System.Action{System.Action{`0}},System.Boolean)">
            <summary>使用事件处理器、取消注册回调、是否一次性事件来初始化</summary>
            <param name="handler">事件处理器</param>
            <param name="unHandler">取消注册回调</param>
            <param name="once">是否一次性事件</param>
        </member>
        <member name="M:NewLife.WeakAction`1.Invoke(`0)">
            <summary>调用委托</summary>
            <param name="e"></param>
        </member>
        <member name="M:NewLife.WeakAction`1.op_Implicit(NewLife.WeakAction{`0})~System.Action{`0}">
            <summary>把弱引用事件处理器转换为普通事件处理器</summary>
            <param name="handler"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.WeakAction`1.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.XException">
            <summary>X组件异常</summary>
        </member>
        <member name="M:NewLife.XException.#ctor">
            <summary>初始化</summary>
        </member>
        <member name="M:NewLife.XException.#ctor(System.String)">
            <summary>初始化</summary>
            <param name="message"></param>
        </member>
        <member name="M:NewLife.XException.#ctor(System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.XException.#ctor(System.String,System.Exception)">
            <summary>初始化</summary>
            <param name="message"></param>
            <param name="innerException"></param>
        </member>
        <member name="M:NewLife.XException.#ctor(System.Exception,System.String,System.Object[])">
            <summary>初始化</summary>
            <param name="innerException"></param>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="M:NewLife.XException.#ctor(System.Exception)">
            <summary>初始化</summary>
            <param name="innerException"></param>
        </member>
        <member name="T:NewLife.ExceptionEventArgs">
            <summary>异常事件参数</summary>
        </member>
        <member name="P:NewLife.ExceptionEventArgs.Action">
            <summary>发生异常时进行的动作</summary>
        </member>
        <member name="P:NewLife.ExceptionEventArgs.Exception">
            <summary>异常</summary>
        </member>
        <member name="T:NewLife.ExceptionHelper">
            <summary>异常助手</summary>
        </member>
        <member name="M:NewLife.ExceptionHelper.IsDisposed(System.Exception)">
            <summary>是否对象已被释放异常</summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.DynamicInternal">
            <summary>包装程序集内部类的动态对象</summary>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.TryConvert(System.Dynamic.ConvertBinder,System.Object@)">
            <summary>类型转换</summary>
            <param name="binder"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <summary>成员取值</summary>
            <param name="binder"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.TryInvokeMember(System.Dynamic.InvokeMemberBinder,System.Object[],System.Object@)">
            <summary>调用成员</summary>
            <param name="binder"></param>
            <param name="args"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.Wrap(System.Object)">
            <summary>包装</summary>
            <param name="obj"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicInternal.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.DynamicXml">
            <summary>动态Xml</summary>
        </member>
        <member name="P:NewLife.Reflection.DynamicXml.Node">
            <summary>节点</summary>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.#ctor(System.Xml.Linq.XElement)">
            <summary>实例化</summary>
            <param name="node"></param>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.#ctor(System.String)">
            <summary>实例化</summary>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.TrySetMember(System.Dynamic.SetMemberBinder,System.Object)">
            <summary>设置</summary>
            <param name="binder"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DynamicXml.TryGetMember(System.Dynamic.GetMemberBinder,System.Object@)">
            <summary>获取</summary>
            <param name="binder"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.IReflect">
            <summary>反射接口</summary>
            <remarks>该接口仅用于扩展，不建议外部使用</remarks>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetType(System.String,System.Boolean)">
            <summary>根据名称获取类型</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetMethod(System.Type,System.String,System.Type[])">
            <summary>获取方法</summary>
            <remarks>用于具有多个签名的同名方法的场合，不确定是否存在性能问题，不建议普通场合使用</remarks>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="paramTypes">参数类型数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetMethods(System.Type,System.String,System.Int32)">
            <summary>获取指定名称的方法集合，支持指定参数个数来匹配过滤</summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="paramCount">参数个数，-1表示不过滤参数个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetProperty(System.Type,System.String,System.Boolean)">
            <summary>获取属性</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetField(System.Type,System.String,System.Boolean)">
            <summary>获取字段</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetMember(System.Type,System.String,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetFields(System.Type,System.Boolean)">
            <summary>获取字段</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetProperties(System.Type,System.Boolean)">
            <summary>获取属性</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.CreateInstance(System.Type,System.Object[])">
            <summary>反射创建指定类型的实例</summary>
            <param name="type">类型</param>
            <param name="parameters">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.Invoke(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.InvokeWithParams(System.Object,System.Reflection.MethodBase,System.Collections.IDictionary)">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数字典</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetValue(System.Object,System.Reflection.PropertyInfo)">
            <summary>获取目标对象的属性值</summary>
            <param name="target">目标对象</param>
            <param name="property">属性</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetValue(System.Object,System.Reflection.FieldInfo)">
            <summary>获取目标对象的字段值</summary>
            <param name="target">目标对象</param>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.SetValue(System.Object,System.Reflection.PropertyInfo,System.Object)">
            <summary>设置目标对象的属性值</summary>
            <param name="target">目标对象</param>
            <param name="property">属性</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.IReflect.SetValue(System.Object,System.Reflection.FieldInfo,System.Object)">
            <summary>设置目标对象的字段值</summary>
            <param name="target">目标对象</param>
            <param name="field">字段</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.IReflect.Copy(System.Object,System.Object,System.Boolean,System.String[])">
            <summary>从源对象拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="src">源对象</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
            <param name="excludes">要忽略的成员</param>
        </member>
        <member name="M:NewLife.Reflection.IReflect.Copy(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>从源字典拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="dic">源字典</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetElementType(System.Type)">
            <summary>获取一个类型的元素类型</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.ChangeType(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="value">数值</param>
            <param name="conversionType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetName(System.Type,System.Boolean)">
            <summary>获取类型的友好名称</summary>
            <param name="type">指定类型</param>
            <param name="isfull">是否全名，包含命名空间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.As(System.Type,System.Type)">
            <summary>是否能够转为指定基类</summary>
            <param name="type"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetSubclasses(System.Reflection.Assembly,System.Type)">
            <summary>在指定程序集中查找指定基类或接口的所有子类实现</summary>
            <param name="asm">指定程序集</param>
            <param name="baseType">基类或接口，为空时返回所有类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.IReflect.GetAllSubclasses(System.Type,System.Boolean)">
            <summary>在所有程序集中查找指定基类或接口的子类实现</summary>
            <param name="baseType">基类或接口</param>
            <param name="isLoadAssembly">是否加载为加载程序集</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.DefaultReflect">
            <summary>默认反射实现</summary>
            <remarks>该接口仅用于扩展，不建议外部使用</remarks>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetType(System.String,System.Boolean)">
            <summary>根据名称获取类型</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetMethod(System.Type,System.String,System.Type[])">
            <summary>获取方法</summary>
            <remarks>用于具有多个签名的同名方法的场合，不确定是否存在性能问题，不建议普通场合使用</remarks>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="paramTypes">参数类型数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetMethods(System.Type,System.String,System.Int32)">
            <summary>获取指定名称的方法集合，支持指定参数个数来匹配过滤</summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="paramCount">参数个数，-1表示不过滤参数个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetProperty(System.Type,System.String,System.Boolean)">
            <summary>获取属性</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetField(System.Type,System.String,System.Boolean)">
            <summary>获取字段</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetMember(System.Type,System.String,System.Boolean)">
            <summary>获取成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetFields(System.Type,System.Boolean)">
            <summary>获取字段</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetProperties(System.Type,System.Boolean)">
            <summary>获取属性</summary>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.CreateInstance(System.Type,System.Object[])">
            <summary>反射创建指定类型的实例</summary>
            <param name="type">类型</param>
            <param name="parameters">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.Invoke(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.InvokeWithParams(System.Object,System.Reflection.MethodBase,System.Collections.IDictionary)">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数字典</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetValue(System.Object,System.Reflection.PropertyInfo)">
            <summary>获取目标对象的属性值</summary>
            <param name="target">目标对象</param>
            <param name="property">属性</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetValue(System.Object,System.Reflection.FieldInfo)">
            <summary>获取目标对象的字段值</summary>
            <param name="target">目标对象</param>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.SetValue(System.Object,System.Reflection.PropertyInfo,System.Object)">
            <summary>设置目标对象的属性值</summary>
            <param name="target">目标对象</param>
            <param name="property">属性</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.SetValue(System.Object,System.Reflection.FieldInfo,System.Object)">
            <summary>设置目标对象的字段值</summary>
            <param name="target">目标对象</param>
            <param name="field">字段</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.Copy(System.Object,System.Object,System.Boolean,System.String[])">
            <summary>从源对象拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="src">源对象</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
            <param name="excludes">要忽略的成员</param>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.Copy(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>从源字典拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="dic">源字典</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetElementType(System.Type)">
            <summary>获取一个类型的元素类型</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.ChangeType(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="value">数值</param>
            <param name="conversionType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetName(System.Type,System.Boolean)">
            <summary>获取类型的友好名称</summary>
            <param name="type">指定类型</param>
            <param name="isfull">是否全名，包含命名空间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.As(System.Type,System.Type)">
            <summary>是否子类</summary>
            <param name="type"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetSubclasses(System.Reflection.Assembly,System.Type)">
            <summary>在指定程序集中查找指定基类的子类</summary>
            <param name="asm">指定程序集</param>
            <param name="baseType">基类或接口，为空时返回所有类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetAllSubclasses(System.Type,System.Boolean)">
            <summary>在所有程序集中查找指定基类或接口的子类实现</summary>
            <param name="baseType">基类或接口</param>
            <param name="isLoadAssembly">是否加载为加载程序集</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.DefaultReflect.GetType(System.Object@)">
            <summary>获取类型，如果target是Type类型，则表示要反射的是静态成员</summary>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.PEImage">
            <summary>PE镜像</summary>
            <remarks>
            
            </remarks>
        </member>
        <member name="P:NewLife.Reflection.PEImage.Kind">
            <summary>可执行文件类型</summary>
        </member>
        <member name="P:NewLife.Reflection.PEImage.ExecutableKind">
            <summary>可执行文件代码特性</summary>
        </member>
        <member name="P:NewLife.Reflection.PEImage.Machine">
            <summary>可执行文件的目标平台</summary>
        </member>
        <member name="P:NewLife.Reflection.PEImage.Characteristics">
            <summary>标识特性</summary>
        </member>
        <member name="P:NewLife.Reflection.PEImage.Version">
            <summary>版本</summary>
        </member>
        <member name="P:NewLife.Reflection.PEImage.IsNet">
            <summary>是否.Net程序</summary>
        </member>
        <member name="M:NewLife.Reflection.PEImage.Read(System.String)">
            <summary>读取镜像信息</summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PEImage.Read(System.IO.Stream)">
            <summary>从数据流中读取PE文件头部</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.PEImage.CanLoad(System.String,System.Version,System.Boolean)">
            <summary>能否在指定版本下加载程序集</summary>
            <remarks>
            必须加强过滤，下面一旦只读加载，就再也不能删除文件
            </remarks>
            <param name="file">程序集文件</param>
            <param name="ver">指定模版，默认空表示当前版本</param>
            <param name="debug">是否输出调试日志</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.Reflect">
            <summary>反射工具类</summary>
        </member>
        <member name="P:NewLife.Reflection.Reflect.Provider">
            <summary>当前反射提供者</summary>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetTypeEx(System.String,System.Boolean)">
            <summary>根据名称获取类型。可搜索当前目录DLL，自动加载</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetMethodEx(System.Type,System.String,System.Type[])">
            <summary>获取方法</summary>
            <remarks>用于具有多个签名的同名方法的场合，不确定是否存在性能问题，不建议普通场合使用</remarks>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="paramTypes">参数类型数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetMethodsEx(System.Type,System.String,System.Int32)">
            <summary>获取指定名称的方法集合，支持指定参数个数来匹配过滤</summary>
            <param name="type"></param>
            <param name="name"></param>
            <param name="paramCount">参数个数，-1表示不过滤参数个数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetPropertyEx(System.Type,System.String,System.Boolean)">
            <summary>获取属性。搜索私有、静态、基类，优先返回大小写精确匹配成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetFieldEx(System.Type,System.String,System.Boolean)">
            <summary>获取字段。搜索私有、静态、基类，优先返回大小写精确匹配成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetMemberEx(System.Type,System.String,System.Boolean)">
            <summary>获取成员。搜索私有、静态、基类，优先返回大小写精确匹配成员</summary>
            <param name="type">类型</param>
            <param name="name">名称</param>
            <param name="ignoreCase">忽略大小写</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetFields(System.Type,System.Boolean)">
            <summary>获取用于序列化的字段</summary>
            <remarks>过滤<seealso cref="T:NonSerializedAttribute"/>特性的字段</remarks>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetProperties(System.Type,System.Boolean)">
            <summary>获取用于序列化的属性</summary>
            <remarks>过滤<seealso cref="T:XmlIgnoreAttribute"/>特性的属性和索引器</remarks>
            <param name="type"></param>
            <param name="baseFirst"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.CreateInstance(System.Type,System.Object[])">
            <summary>反射创建指定类型的实例</summary>
            <param name="type">类型</param>
            <param name="parameters">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.Invoke(System.Object,System.String,System.Object[])">
            <summary>反射调用指定对象的方法。target为类型时调用其静态方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="name">方法名</param>
            <param name="parameters">方法参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.TryInvoke(System.Object,System.String,System.Object@,System.Object[])">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="name">方法名</param>
            <param name="value">数值</param>
            <param name="parameters">方法参数</param>
            <remarks>反射调用是否成功</remarks>
        </member>
        <member name="M:NewLife.Reflection.Reflect.Invoke(System.Object,System.Reflection.MethodBase,System.Object[])">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.InvokeWithParams(System.Object,System.Reflection.MethodBase,System.Collections.IDictionary)">
            <summary>反射调用指定对象的方法</summary>
            <param name="target">要调用其方法的对象，如果要调用静态方法，则target是类型</param>
            <param name="method">方法</param>
            <param name="parameters">方法参数字典</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetValue(System.Object,System.String,System.Boolean)">
            <summary>获取目标对象指定名称的属性/字段值</summary>
            <param name="target">目标对象</param>
            <param name="name">名称</param>
            <param name="throwOnError">出错时是否抛出异常</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.TryGetValue(System.Object,System.String,System.Object@)">
            <summary>获取目标对象指定名称的属性/字段值</summary>
            <param name="target">目标对象</param>
            <param name="name">名称</param>
            <param name="value">数值</param>
            <returns>是否成功获取数值</returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetValue(System.Object,System.Reflection.MemberInfo)">
            <summary>获取目标对象的成员值</summary>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.SetValue(System.Object,System.String,System.Object)">
            <summary>设置目标对象指定名称的属性/字段值，若不存在返回false</summary>
            <param name="target">目标对象</param>
            <param name="name">名称</param>
            <param name="value">数值</param>
            <remarks>反射调用是否成功</remarks>
        </member>
        <member name="M:NewLife.Reflection.Reflect.SetValue(System.Object,System.Reflection.MemberInfo,System.Object)">
            <summary>设置目标对象的成员值</summary>
            <param name="target">目标对象</param>
            <param name="member">成员</param>
            <param name="value">数值</param>
        </member>
        <member name="M:NewLife.Reflection.Reflect.Copy(System.Object,System.Object,System.Boolean,System.String[])">
            <summary>从源对象拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="src">源对象</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
            <param name="excludes">要忽略的成员</param>
        </member>
        <member name="M:NewLife.Reflection.Reflect.Copy(System.Object,System.Collections.Generic.IDictionary{System.String,System.Object},System.Boolean)">
            <summary>从源字典拷贝数据到目标对象</summary>
            <param name="target">目标对象</param>
            <param name="dic">源字典</param>
            <param name="deep">递归深度拷贝，直接拷贝成员值而不是引用</param>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetElementTypeEx(System.Type)">
            <summary>获取一个类型的元素类型</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.ChangeType(System.Object,System.Type)">
            <summary>类型转换</summary>
            <param name="value">数值</param>
            <param name="conversionType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.ChangeType``1(System.Object)">
            <summary>类型转换</summary>
            <typeparam name="TResult"></typeparam>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetName(System.Type,System.Boolean)">
            <summary>获取类型的友好名称</summary>
            <param name="type">指定类型</param>
            <param name="isfull">是否全名，包含命名空间</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetTypeArray(System.Object[])">
            <summary>从参数数组中获取类型数组</summary>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetMemberType(System.Reflection.MemberInfo)">
            <summary>获取成员的类型，字段和属性是它们的类型，方法是返回类型，类型是自身</summary>
            <param name="member"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetTypeCode(System.Type)">
            <summary>获取类型代码</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsInt(System.Type)">
            <summary>是否整数</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsList(System.Type)">
            <summary>是否泛型列表</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsDictionary(System.Type)">
            <summary>是否泛型字典</summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.As(System.Type,System.Type)">
            <summary>是否能够转为指定基类</summary>
            <param name="type"></param>
            <param name="baseType"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.As``1(System.Type)">
            <summary>是否能够转为指定基类</summary>
            <typeparam name="T"></typeparam>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetSubclasses(System.Reflection.Assembly,System.Type)">
            <summary>在指定程序集中查找指定基类的子类</summary>
            <param name="asm">指定程序集</param>
            <param name="baseType">基类或接口</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetAllSubclasses(System.Type,System.Boolean)">
            <summary>在所有程序集中查找指定基类或接口的子类实现</summary>
            <param name="baseType">基类或接口</param>
            <param name="isLoadAssembly">是否加载为加载程序集</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.GetType(System.Object@)">
            <summary>获取类型，如果target是Type类型，则表示要反射的是静态成员</summary>
            <param name="target">目标对象</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.IsNullable(System.Type)">
            <summary>判断某个类型是否可空类型</summary>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.Reflect.As``1(System.Reflection.MethodInfo,System.Object)">
            <summary>把一个方法转为泛型委托，便于快速反射调用</summary>
            <typeparam name="TFunc"></typeparam>
            <param name="method"></param>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.ScriptEngine">
            <summary>脚本引擎</summary>
            <remarks>
            三大用法：
            1，单个表达式，根据参数计算表达式结果并返回
            2，多个语句，最后有返回语句
            3，多个方法，有一个名为Execute的静态方法作为入口方法
            
            脚本引擎禁止实例化，必须通过<see cref="M:NewLife.Reflection.ScriptEngine.Create(System.String,System.Boolean)"/>方法创建，以代码为键进行缓存，避免重复创建反复编译形成泄漏。
            其中<see cref="M:NewLife.Reflection.ScriptEngine.Create(System.String,System.Boolean)"/>方法的第二个参数为true表示前两种用法，为false表示第三种用法。
            </remarks>
            <example>
            最简单而完整的用法：
            <code>
            // 根据代码创建脚本实例，相同代码只编译一次
            var se = ScriptEngine.Create("a+b");
            // 如果Method为空说明未编译，可设置参数
            if (se.Method == null)
            {
                se.Parameters.Add("a", typeof(Int32));
                se.Parameters.Add("b", typeof(Int32));
            }
            // 脚本固定返回Object类型，需要自己转换
            var n = (Int32)se.Invoke(2, 3);
            Console.WriteLine("2+3={0}", n);
            </code>
            
            无参数快速调用：
            <code>
            var n = (Int32)ScriptEngine.Execute("2*3");
            </code>
            
            约定参数快速调用：
            <code>
            var n = (Int32)ScriptEngine.Execute("p0*p1", new Object[] { 2, 3 });
            Console.WriteLine("2*3={0}", n);
            </code>
            </example>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Code">
            <summary>代码</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.IsExpression">
            <summary>是否表达式</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Parameters">
            <summary>参数集合。编译后就不可修改。</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.FinalCode">
            <summary>最终代码</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Type">
            <summary>编译得到的类型</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Method">
            <summary>根据代码编译出来可供直接调用的入口方法，Eval/Main</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.NameSpaces">
            <summary>命名空间集合</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.ReferencedAssemblies">
            <summary>引用程序集集合</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.Log">
            <summary>日志</summary>
        </member>
        <member name="P:NewLife.Reflection.ScriptEngine.WorkingDirectory">
            <summary>工作目录。执行时，将会作为环境变量的当前目录和PathHelper目录，执行后还原</summary>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.#ctor(System.String,System.Boolean)">
            <summary>构造函数私有，禁止外部越过Create方法直接创建实例</summary>
            <param name="code">代码片段</param>
            <param name="isExpression">是否表达式，表达式将编译成为一个Main方法</param>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Create(System.String,System.Boolean)">
            <summary>为指定代码片段创建脚本引擎实例。采用缓存，避免同一脚本重复创建引擎。</summary>
            <param name="code">代码片段</param>
            <param name="isExpression">是否表达式，表达式将编译成为一个Main方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Execute(System.String)">
            <summary>执行表达式，返回结果</summary>
            <param name="code">代码片段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Execute(System.String,System.String[],System.Type[],System.Object[])">
            <summary>执行表达式，返回结果</summary>
            <param name="code">代码片段</param>
            <param name="names">参数名称</param>
            <param name="parameterTypes">参数类型</param>
            <param name="parameters">参数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Execute(System.String,System.Collections.Generic.IDictionary{System.String,System.Object})">
            <summary>执行表达式，返回结果</summary>
            <param name="code">代码片段</param>
            <param name="parameters">参数名值对</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Execute(System.String,System.Object[])">
            <summary>执行表达式，返回结果。参数名默认为p0/p1/p2/pn</summary>
            <param name="code"></param>
            <param name="parameters">参数数组</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.GenerateCode">
            <summary>生成代码。根据<see cref="P:NewLife.Reflection.ScriptEngine.Code"/>完善得到最终代码<see cref="P:NewLife.Reflection.ScriptEngine.FinalCode"/></summary>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.GetFullCode">
            <summary>获取完整源代码</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Compile">
            <summary>编译</summary>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Compile(System.String,System.CodeDom.Compiler.CompilerParameters)">
            <summary>编译</summary>
            <param name="classCode"></param>
            <param name="options"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.Invoke(System.Object[])">
            <summary>按照传入参数执行代码</summary>
            <param name="parameters">参数</param>
            <returns>结果</returns>
        </member>
        <member name="M:NewLife.Reflection.ScriptEngine.ParseNameSpace(System.String)">
            <summary>分析命名空间</summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.AssemblyX">
            <summary>程序集辅助类。使用Create创建，保证每个程序集只有一个辅助类</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Asm">
            <summary>程序集</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Version">
            <summary>程序集版本</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Title">
            <summary>程序集标题</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.FileVersion">
            <summary>文件版本</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Compile">
            <summary>编译时间</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.CompileVersion">
            <summary>编译版本</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Company">
            <summary>公司名称</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Description">
            <summary>说明</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Location">
            <summary>获取包含清单的已加载文件的路径或 UNC 位置。</summary>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.Create(System.Reflection.Assembly)">
            <summary>创建程序集辅助对象</summary>
            <param name="asm"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Types">
            <summary>类型集合，当前程序集的所有类型，包括私有和内嵌，非内嵌请直接调用Asm.GetTypes()</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.IsSystemAssembly">
            <summary>是否系统程序集</summary>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.Entry">
            <summary>入口程序集</summary>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetType(System.String)">
            <summary>从程序集中查找指定名称的类型</summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetTypeInternal(System.String)">
            <summary>在程序集中查找类型</summary>
            <param name="typeName"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindPlugins``1">
            <summary>查找插件</summary>
            <typeparam name="TPlugin"></typeparam>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindPlugins(System.Type)">
            <summary>查找插件，带缓存</summary>
            <param name="baseType">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.FindAllPlugins(System.Type,System.Boolean,System.Boolean)">
            <summary>查找所有非系统程序集中的所有插件</summary>
            <remarks>继承类所在的程序集会引用baseType所在的程序集，利用这一点可以做一定程度的性能优化。</remarks>
            <param name="baseType"></param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <param name="excludeGlobalTypes">指示是否应检查来自所有引用程序集的类型。如果为 false，则检查来自所有引用程序集的类型。 否则，只检查来自非全局程序集缓存 (GAC) 引用的程序集的类型。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.IsReferencedFrom(System.Reflection.Assembly,System.String)">
            <summary><paramref name="asm"/> 是否引用了 <paramref name="baseAsmName"/></summary>
            <param name="asm">程序集</param>
            <param name="baseAsmName">被引用程序集全名</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetType(System.String,System.Boolean)">
            <summary>根据名称获取类型</summary>
            <param name="typeName">类型名</param>
            <param name="isLoadAssembly">是否从未加载程序集中获取类型。使用仅反射的方法检查目标类型，如果存在，则进行常规加载</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetAssemblies(System.AppDomain)">
            <summary>获取指定程序域所有程序集</summary>
            <param name="domain"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Reflection.AssemblyX.AssemblyPaths">
            <summary>程序集目录集合</summary>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyGetAssemblies">
            <summary>获取当前程序域所有只反射程序集的辅助类</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyLoad(System.String)">
            <summary>只反射加载指定路径的所有程序集</summary>
            <param name="path"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ReflectionOnlyLoadFrom(System.String,System.Version)">
            <summary>只反射加载指定路径的所有程序集</summary>
            <param name="file"></param>
            <param name="ver"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.GetMyAssemblies">
            <summary>获取当前应用程序的所有程序集，不包括系统程序集，仅限本目录</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.OnResolve(System.String)">
            <summary>在对程序集的解析失败时发生</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.AssemblyX.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.EmitHelper">
            <summary>动态生成代码Emit助手。仅提供扩展功能，不封装基本功能</summary>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldc_I4(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>基于Ldc_I4指令的整数推送，自动选择最合适的指令</summary>
            <param name="IL">指令</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldarg(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>基于Ldarg指令的参数加载，自动选择最合适的指令</summary>
            <param name="IL">指令</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Stloc(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>基于Stloc指令的弹栈，自动选择最合适的指令</summary>
            <param name="IL">指令</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldloc(System.Reflection.Emit.ILGenerator,System.Int32)">
            <summary>基于Ldloc指令的压栈，自动选择最合适的指令</summary>
            <param name="IL">指令</param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldfld(System.Reflection.Emit.ILGenerator,System.Reflection.FieldInfo)">
            <summary>查找对象中其引用当前位于计算堆栈的字段的值。</summary>
            <param name="IL">指令</param>
            <param name="field">字段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldind(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>间接加载到计算堆栈</summary>
            <param name="IL">指令</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Stind(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>间接加载到计算堆栈</summary>
            <param name="IL">指令</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldelem_Ref(System.Reflection.Emit.ILGenerator)">
            <summary>将位于指定数组索引处的包含对象引用的元素作为 O 类型（对象引用）加载到计算堆栈的顶部。</summary>
            <param name="IL">指令</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Stelem_Ref(System.Reflection.Emit.ILGenerator)">
            <summary>用计算堆栈上的对象 ref 值（O 类型）替换给定索引处的数组元素。</summary>
            <param name="IL">指令</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.CastFromObject(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>把一个类型转为指定类型，值类型装箱，引用类型直接Cast</summary>
            <param name="IL">指令</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.BoxIfValueType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>装箱</summary>
            <param name="IL">指令</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Call(System.Reflection.Emit.ILGenerator,System.Reflection.MethodInfo)">
            <summary>调用</summary>
            <param name="IL">指令</param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ldnull(System.Reflection.Emit.ILGenerator)">
            <summary>加载空</summary>
            <param name="IL">指令</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.Ret(System.Reflection.Emit.ILGenerator)">
            <summary>返回</summary>
            <param name="IL">指令</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.NewValueType(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>创建值类型，对象位于栈上</summary>
            <param name="IL">指令</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.NewArray(System.Reflection.Emit.ILGenerator,System.Type)">
            <summary>创建数组，参数必须是Object[]</summary>
            <param name="IL">指令</param>
            <param name="type">类型</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.NewObj(System.Reflection.Emit.ILGenerator,System.Reflection.ConstructorInfo)">
            <summary>创建对象</summary>
            <param name="IL">指令</param>
            <param name="constructor"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.CreateLocalsForByRefParams(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
            <summary>为引用参数声明本地变量</summary>
            <param name="IL">指令</param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.AssignByRefParamsToArray(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
            <summary>将引用参数赋值到数组</summary>
            <param name="IL">指令</param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.PushParamsOrLocalsToStack(System.Reflection.Emit.ILGenerator,System.Reflection.MethodBase)">
            <summary>将参数压栈</summary>
            <param name="IL">指令</param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.PushParams(System.Reflection.Emit.ILGenerator,System.Int32,System.Reflection.MethodBase)">
            <summary>将指定参数位置的数组参数按照方法参数要求压栈</summary>
            <param name="IL">指令</param>
            <param name="paramIndex"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Reflection.EmitHelper.PushParams(System.Reflection.Emit.ILGenerator,System.Int32,System.Type[])">
            <summary>将指定参数位置的数组参数一个个压栈</summary>
            <param name="IL">指令</param>
            <param name="paramIndex"></param>
            <param name="paramTypes"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Reflection.IIndexAccessor">
            <summary>
            索引器接访问口。
            该接口用于通过名称快速访问对象属性或字段（属性优先）。
            </summary>
        </member>
        <member name="P:NewLife.Reflection.IIndexAccessor.Item(System.String)">
            <summary>获取/设置 指定名称的属性或字段的值</summary>
            <param name="name">名称</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Certificate">
            <summary>证书</summary>
            <remarks>http://blogs.msdn.com/b/dcook/archive/2008/11/25/creating-a-self-signed-certificate-in-c.aspx</remarks>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String)">
            <summary>建立自签名证书</summary>
            <param name="x500"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String,System.DateTime,System.DateTime)">
            <summary>建立自签名证书</summary>
            <param name="x500"></param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String,System.DateTime,System.DateTime,System.String)">
            <summary>建立自签名证书</summary>
            <param name="x500"></param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <param name="insecurePassword"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.String,System.DateTime,System.DateTime,System.Security.SecureString)">
            <summary>建立自签名证书</summary>
            <param name="x500">例如CN=SelfSignCertificate;C=China;OU=NewLife;O=Development Team;E=nnhy@vip.qq.com，其中CN是显示名</param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Certificate.CreateSelfSignCertificatePfx(System.Security.Cryptography.X509Certificates.X500DistinguishedName,System.DateTime,System.DateTime,System.Security.SecureString)">
            <summary>建立自签名证书</summary>
            <param name="distName"></param>
            <param name="startTime"></param>
            <param name="endTime"></param>
            <param name="password"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Crc16">
            <summary>CRC16校验</summary>
        </member>
        <member name="F:NewLife.Security.Crc16.CrcTable">
            <summary>CRC16表</summary>
        </member>
        <member name="F:NewLife.Security.Crc16.crc">
            <summary>校验值</summary>
        </member>
        <member name="P:NewLife.Security.Crc16.Value">
            <summary>校验值</summary>
        </member>
        <member name="M:NewLife.Security.Crc16.Reset">
            <summary>重置清零</summary>
        </member>
        <member name="M:NewLife.Security.Crc16.Update(System.Int16)">
            <summary>添加整数进行校验</summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:NewLife.Security.Crc16.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>添加字节数组进行校验  CRC16-CCITT x16+x12+x5+1 1021  ISO HDLC, ITU X.25, V.34/V.41/V.42, PPP-FCS</summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="M:NewLife.Security.Crc16.Update(System.IO.Stream,System.Int64)">
            <summary>添加数据流进行校验  CRC-16 x16+x15+x2+1 8005 IBM SDLC</summary>
            <param name="stream"></param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Security.Crc16.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>计算校验码</summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc16.Compute(System.IO.Stream,System.Int32)">
            <summary>计算数据流校验码</summary>
            <param name="stream"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc16.Compute(System.IO.Stream,System.Int64,System.Int32)">
            <summary>计算数据流校验码，指定起始位置和字节数偏移量</summary>
            <remarks>
            一般用于计算数据包校验码，需要回过头去开始校验，并且可能需要跳过最后的校验码长度。
            position小于0时，数据流从当前位置开始计算校验；
            position大于等于0时，数据流移到该位置开始计算校验，最后由count决定可能差几个字节不参与计算；
            </remarks>
            <param name="stream"></param>
            <param name="position">如果大于等于0，则表示从该位置开始计算</param>
            <param name="count">字节数偏移量，一般用负数表示</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.DSAHelper">
            <summary>DSA算法</summary>
        </member>
        <member name="M:NewLife.Security.DSAHelper.GenerateKey(System.Int32)">
            <summary>产生非对称密钥对（私钥和公钥）</summary>
            <param name="keySize">密钥长度，默认1024位强密钥</param>
            <returns>私钥和公钥</returns>
        </member>
        <member name="M:NewLife.Security.DSAHelper.Sign(System.Byte[],System.String)">
            <summary>签名</summary>
            <param name="buf"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.DSAHelper.Verify(System.Byte[],System.String,System.Byte[])">
            <summary>验证</summary>
            <param name="buf"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Rand">
            <summary>随机数</summary>
        </member>
        <member name="M:NewLife.Security.Rand.Next(System.Int32)">
            <summary>返回一个小于所指定最大值的非负随机数</summary>
            <param name="max">返回的随机数的上界（随机数不能取该上界值）</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Rand.Next(System.Int32,System.Int32)">
            <summary>返回一个指定范围内的随机数</summary>
            <remarks>
            调用平均耗时37.76ns，其中GC耗时77.56%
            </remarks>
            <param name="min">返回的随机数的下界（随机数可取该下界值）</param>
            <param name="max">返回的随机数的上界（随机数不能取该上界值）</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Rand.NextBytes(System.Int32)">
            <summary>返回指定长度随机字节数组</summary>
            <remarks>
            调用平均耗时5.46ns，其中GC耗时15%
            </remarks>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Rand.NextString(System.Int32,System.Boolean)">
            <summary>返回指定长度随机字符串</summary>
            <param name="length">长度</param>
            <param name="symbol">是否包含符号</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.RC4">
            <summary>RC4对称加密算法</summary>
            <remarks>
            RC4于1987年提出，和DES算法一样，是一种对称加密算法，也就是说使用的密钥为单钥（或称为私钥）。
            但不同于DES的是，RC4不是对明文进行分组处理，而是字节流的方式依次加密明文中的每一个字节，解密的时候也是依次对密文中的每一个字节进行解密。
            
            RC4算法的特点是算法简单，运行速度快，而且密钥长度是可变的，可变范围为1-256字节(8-2048比特)，
            在如今技术支持的前提下，当密钥长度为128比特时，用暴力法搜索密钥已经不太可行，所以可以预见RC4的密钥范围任然可以在今后相当长的时间里抵御暴力搜索密钥的攻击。
            实际上，如今也没有找到对于128bit密钥长度的RC4加密算法的有效攻击方法。
            </remarks>
        </member>
        <member name="M:NewLife.Security.RC4.Encrypt(System.Byte[],System.Byte[])">
            <summary>加密</summary>
            <param name="data">数据</param>
            <param name="pass">密码</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RC4.GetKey(System.Byte[],System.Int32)">
            <summary>打乱密码</summary>  
            <param name="pass">密码</param>  
            <param name="len">密码箱长度</param>  
            <returns>打乱后的密码</returns>  
        </member>
        <member name="T:NewLife.Security.RSAHelper">
            <summary>RSA算法</summary>
            <remarks>
            RSA加密或签名小数据块时，密文长度128，速度也很快。
            </remarks>
        </member>
        <member name="M:NewLife.Security.RSAHelper.GenerateKey(System.Int32)">
            <summary>产生非对称密钥对</summary>
            <remarks>
            RSAParameters的各个字段采用大端字节序，转为BigInteger的之前一定要倒序。
            RSA加密后密文最小长度就是密钥长度，所以1024密钥最小密文长度是128字节。
            </remarks>
            <param name="keySize">密钥长度，默认1024位强密钥</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Encrypt(System.Byte[],System.String,System.Boolean)">
            <summary>RSA加密</summary>
            <param name="buf"></param>
            <param name="pubKey"></param>
            <param name="fOAEP">如果为 true，则使用 OAEP 填充（仅可用于运行 Windows XP 及更高版本的计算机）执行直接 System.Security.Cryptography.RSA加密；否则，如果为 false，则使用 PKCS#1 v1.5 填充。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Decrypt(System.Byte[],System.String,System.Boolean)">
            <summary>RSA解密</summary>
            <param name="buf"></param>
            <param name="priKey"></param>
            <param name="fOAEP">如果为 true，则使用 OAEP 填充（仅可用于运行 Microsoft Windows XP 及更高版本的计算机）执行直接 System.Security.Cryptography.RSA解密；否则，如果为 false 则使用 PKCS#1 v1.5 填充。</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.EncryptWithDES(System.Byte[],System.String)">
            <summary>配合DES加密</summary>
            <param name="buf"></param>
            <param name="pubKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.DecryptWithDES(System.Byte[],System.String)">
            <summary>配合DES解密</summary>
            <param name="buf"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Encrypt``1(System.Byte[],System.String)">
            <summary>配合对称算法加密</summary>
            <typeparam name="TSymmetricAlgorithm"></typeparam>
            <param name="buf"></param>
            <param name="pubKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Decrypt``1(System.Byte[],System.String)">
            <summary>配合对称算法解密</summary>
            <typeparam name="TSymmetricAlgorithm"></typeparam>
            <param name="buf"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Sign(System.Byte[],System.String)">
            <summary>签名</summary>
            <param name="buf"></param>
            <param name="priKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.Verify(System.Byte[],System.String,System.Byte[])">
            <summary>验证</summary>
            <param name="buf"></param>
            <param name="pukKey"></param>
            <param name="rgbSignature"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.RSAHelper.SetRandom(System.Byte[])">
            <summary>使用随机数设置</summary>
            <param name="buf"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Security.Crc32">
             <summary>CRC32校验</summary>
             <remarks>
             Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
             x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.
            
             Polynomials over GF(2) are represented in binary, one bit per coefficient,
             with the lowest powers in the most significant bit.  Then adding polynomials
             is just exclusive-or, and multiplying a polynomial by x is a right shift by
             one.  If we call the above polynomial p, and represent a byte as the
             polynomial q, also with the lowest power in the most significant bit (so the
             byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
             where a mod b means the remainder after dividing a by b.
            
             This calculation is done using the shift-register method of multiplying and
             taking the remainder.  The register is initialized to zero, and for each
             incoming bit, x^32 is added mod p to the register if the bit is a one (where
             x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
             x (which is shifting right by one and adding x^32 mod p if the bit shifted
             out is a one).  We start with the highest power (least significant bit) of
             q and repeat for all eight bits of q.
            
             The table is simply the CRC of all possible eight bit values.  This is all
             the information needed to generate CRC's on data a byte at a time for all
             combinations of CRC register values and incoming bytes.
             </remarks>
        </member>
        <member name="F:NewLife.Security.Crc32.Table">
            <summary>校验表</summary>
        </member>
        <member name="F:NewLife.Security.Crc32.crc">
            <summary>校验值</summary>
        </member>
        <member name="P:NewLife.Security.Crc32.Value">
            <summary>校验值</summary>
        </member>
        <member name="M:NewLife.Security.Crc32.Reset">
            <summary>重置清零</summary>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.Int32)">
            <summary>添加整数进行校验</summary>
            <param name = "value">
            the byte is taken as the lower 8 bits of value
            </param>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.Byte[],System.Int32,System.Int32)">
            <summary>添加字节数组进行校验</summary>
            <param name = "buffer">
            The buffer which contains the data
            </param>
            <param name = "offset">
            The offset in the buffer where the data starts
            </param>
            <param name = "count">
            The number of data bytes to update the CRC with.
            </param>
        </member>
        <member name="M:NewLife.Security.Crc32.Update(System.IO.Stream,System.Int64)">
            <summary>添加数据流进行校验</summary>
            <param name="stream"></param>
            <param name="count">数量</param>
        </member>
        <member name="M:NewLife.Security.Crc32.Compute(System.Byte[],System.Int32,System.Int32)">
            <summary>计算校验码</summary>
            <param name="buf"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc32.Compute(System.IO.Stream,System.Int32)">
            <summary>计算数据流校验码</summary>
            <param name="stream"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Security.Crc32.ComputeRange(System.IO.Stream,System.Int64,System.Int32)">
            <summary>计算数据流校验码，指定起始位置和字节数偏移量</summary>
            <remarks>
            一般用于计算数据包校验码，需要回过头去开始校验，并且可能需要跳过最后的校验码长度。
            position小于0时，数据流从当前位置开始计算校验；
            position大于等于0时，数据流移到该位置开始计算校验，最后由count决定可能差几个字节不参与计算；
            </remarks>
            <param name="stream"></param>
            <param name="position">如果大于等于0，则表示从该位置开始计算</param>
            <param name="count">字节数偏移量，一般用负数表示</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Setting">
            <summary>核心设置</summary>
        </member>
        <member name="P:NewLife.Setting.Debug">
            <summary>是否启用全局调试。默认启用</summary>
        </member>
        <member name="P:NewLife.Setting.LogLevel">
            <summary>日志等级，只输出大于等于该级别的日志，All/Debug/Info/Warn/Error/Fatal，默认Info</summary>
        </member>
        <member name="P:NewLife.Setting.LogPath">
            <summary>文件日志目录</summary>
        </member>
        <member name="P:NewLife.Setting.NetworkLog">
            <summary>网络日志。本地子网日志广播255.255.255.255:514</summary>
        </member>
        <member name="P:NewLife.Setting.LogFileFormat">
            <summary>日志文件格式</summary>
        </member>
        <member name="P:NewLife.Setting.TempPath">
            <summary>临时目录</summary>
        </member>
        <member name="P:NewLife.Setting.PluginPath">
            <summary>插件目录</summary>
        </member>
        <member name="P:NewLife.Setting.PluginServer">
            <summary>插件服务器。将从该网页上根据关键字分析链接并下载插件</summary>
        </member>
        <member name="P:NewLife.Setting.PluginCache">
            <summary>插件缓存目录。默认位于系统盘的X\Cache</summary>
        </member>
        <member name="M:NewLife.Setting.OnLoaded">
            <summary>加载完成后</summary>
        </member>
        <member name="M:NewLife.Setting.GetPluginPath">
            <summary>获取插件目录</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Setting.GetPluginCache">
            <summary>获取插件缓存目录</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.EventArgs`1">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg"></typeparam>
        </member>
        <member name="P:NewLife.EventArgs`1.Arg">
            <summary>参数</summary>
        </member>
        <member name="M:NewLife.EventArgs`1.#ctor(`0)">
            <summary>使用参数初始化</summary>
            <param name="arg"></param>
        </member>
        <member name="M:NewLife.EventArgs`1.Pop(`0@)">
            <summary>弹出</summary>
            <param name="arg"></param>
        </member>
        <member name="T:NewLife.EventArgs`2">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
        </member>
        <member name="P:NewLife.EventArgs`2.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`2.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="M:NewLife.EventArgs`2.#ctor(`0,`1)">
            <summary>使用参数初始化</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:NewLife.EventArgs`2.Pop(`0@,`1@)">
            <summary>弹出</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
        </member>
        <member name="T:NewLife.EventArgs`3">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="P:NewLife.EventArgs`3.Arg3">
            <summary>参数3</summary>
        </member>
        <member name="M:NewLife.EventArgs`3.#ctor(`0,`1,`2)">
            <summary>使用参数初始化</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="M:NewLife.EventArgs`3.Pop(`0@,`1@,`2@)">
            <summary>弹出</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
        </member>
        <member name="T:NewLife.EventArgs`4">
            <summary>泛型事件参数</summary>
            <typeparam name="TArg1"></typeparam>
            <typeparam name="TArg2"></typeparam>
            <typeparam name="TArg3"></typeparam>
            <typeparam name="TArg4"></typeparam>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg1">
            <summary>参数</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg2">
            <summary>参数2</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg3">
            <summary>参数3</summary>
        </member>
        <member name="P:NewLife.EventArgs`4.Arg4">
            <summary>参数4</summary>
        </member>
        <member name="M:NewLife.EventArgs`4.#ctor(`0,`1,`2,`3)">
            <summary>使用参数初始化</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
        </member>
        <member name="M:NewLife.EventArgs`4.Pop(`0@,`1@,`2@,`3@)">
            <summary>弹出</summary>
            <param name="arg1"></param>
            <param name="arg2"></param>
            <param name="arg3"></param>
            <param name="arg4"></param>
        </member>
        <member name="T:NewLife.Threading.ThreadPoolX">
            <summary>轻量级线程池。无等待和调度逻辑，直接创建线程竞争处理器资源</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.Init">
            <summary>初始化线程池
            </summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueUserWorkItem(System.Action)">
            <summary>带异常处理的线程池任务调度，不允许异常抛出，以免造成应用程序退出</summary>
            <param name="callback"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueUserWorkItem``1(System.Action{``0},``0)">
            <summary>带异常处理的线程池任务调度，不允许异常抛出，以免造成应用程序退出</summary>
            <param name="callback"></param>
            <param name="state"></param>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Instance">
            <summary>静态实例</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadPoolX.Pool">
            <summary>内部池</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.MyThreadPool.OnCreate">
            <summary>创建实例</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueWorkItem(System.Action)">
            <summary>把委托放入线程池执行</summary>
            <param name="callback"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueTask(System.Action)">
            <summary>在线程池中异步执行任务</summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueTask``1(System.Func{``0})">
            <summary>在线程池中异步执行任务</summary>
            <typeparam name="TResult"></typeparam>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadPoolX.QueueTask``1(System.Func{System.Threading.CancellationToken,``0},System.Threading.CancellationToken)">
            <summary>在线程池中异步执行任务</summary>
            <typeparam name="TResult"></typeparam>
            <param name="function"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Threading.ThreadItem">
            <summary>线程任务项</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadItem.ID">
            <summary>编号</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadItem.Thread">
            <summary>线程</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadItem.Host">
            <summary>主机线程池</summary>
        </member>
        <member name="P:NewLife.Threading.ThreadItem.Active">
            <summary>活跃</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadItem.#ctor(NewLife.Threading.ThreadPoolX)">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Threading.ThreadItem.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Threading.ThreadItem.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.ThreadItem.Execute(System.Action)">
            <summary>执行委托</summary>
            <param name="callback"></param>
        </member>
        <member name="T:NewLife.Threading.TimerX">
            <summary>不可重入的定时器。</summary>
            <remarks>
            为了避免系统的Timer可重入的问题，差别在于本地调用完成后才开始计算时间间隔。这实际上也是经常用到的。
            
            因为挂载在静态列表上，必须从外部主动调用<see cref="M:System.IDisposable.Dispose"/>才能销毁定时器。
            
            该定时器不能放入太多任务，否则适得其反！
            
            TimerX必须维持对象，否则很容易被GC回收。
            </remarks>
        </member>
        <member name="P:NewLife.Threading.TimerX.Scheduler">
            <summary>所属调度器</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Callback">
            <summary>获取/设置 回调</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.State">
            <summary>获取/设置 用户数据</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.NextTime">
            <summary>获取/设置 下一次调用时间</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Timers">
            <summary>获取/设置 调用次数</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Period">
            <summary>获取/设置 间隔周期。毫秒，设为0或-1则只调用一次</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Async">
            <summary>获取/设置 异步执行任务。默认false</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Absolutely">
            <summary>获取/设置 绝对精确时间执行。默认false</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Calling">
            <summary>调用中</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Cost">
            <summary>平均耗时。毫秒</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.CanExecute">
            <summary>判断任务是否执行的委托。一般跟异步配合使用，避免频繁从线程池借出线程</summary>
        </member>
        <member name="P:NewLife.Threading.TimerX.Current">
            <summary>当前定时器</summary>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Threading.WaitCallback,System.Object,System.Int32,System.Int32,System.String)">
            <summary>实例化一个不可重入的定时器</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="dueTime">多久之后开始。毫秒</param>
            <param name="period">间隔周期。毫秒</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.#ctor(System.Threading.WaitCallback,System.Object,System.DateTime,System.Int32,System.String)">
            <summary>实例化一个绝对定时器</summary>
            <param name="callback">委托</param>
            <param name="state">用户数据</param>
            <param name="startTime">绝对开始时间</param>
            <param name="period">间隔周期。毫秒</param>
            <param name="scheduler">调度器</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.Dispose">
            <summary>销毁定时器</summary>
        </member>
        <member name="F:NewLife.Threading.TimerX.hasSetNext">
            <summary>是否已设置下一次时间</summary>
        </member>
        <member name="M:NewLife.Threading.TimerX.SetNext(System.Int32)">
            <summary>设置下一次运行时间</summary>
            <param name="ms">小于等于0表示马上调度</param>
        </member>
        <member name="M:NewLife.Threading.TimerX.Delay(System.Threading.WaitCallback,System.Int32)">
            <summary>延迟执行一个委托</summary>
            <param name="callback"></param>
            <param name="ms"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.TimerX.Now">
            <summary>当前时间。定时读取系统时间，避免频繁读取系统时间造成性能瓶颈</summary>
        </member>
        <member name="M:NewLife.Threading.TimerX.ToString">
            <summary>已重载</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Threading.TimerScheduler">
            <summary>定时器调度器</summary>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Create(System.String)">
            <summary>创建指定名称的调度器</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Default">
            <summary>默认调度器</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Current">
            <summary>当前调度器</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Count">
            <summary>定时器个数</summary>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.MaxCost">
            <summary>最大耗时。超过时报警告日志，默认500ms</summary>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Add(NewLife.Threading.TimerX)">
            <summary>把定时器加入队列</summary>
            <param name="timer"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Remove(NewLife.Threading.TimerX)">
            <summary>从队列删除定时器</summary>
            <param name="timer"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Wake">
            <summary>唤醒处理</summary>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Process(System.Object)">
            <summary>调度主程序</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.CheckTime(NewLife.Threading.TimerX,System.DateTime)">
            <summary>检查定时器是否到期</summary>
            <param name="timer"></param>
            <param name="now"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.Execute(System.Object)">
            <summary>处理每一个定时器</summary>
            <param name="state"></param>
        </member>
        <member name="M:NewLife.Threading.TimerScheduler.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Threading.TimerScheduler.Debug">
            <summary>是否开启调试，输出更多信息</summary>
        </member>
        <member name="T:NewLife.Web.OAuth.GithubClient">
            <summary>身份验证提供者</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.GithubClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.GithubClient.OnGetInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>从响应数据中获取信息</summary>
            <param name="dic"></param>
        </member>
        <member name="M:NewLife.Web.OAuth.GithubClient.Request(System.String)">
            <summary>创建客户端</summary>
            <param name="url">路径</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.OAuth.TaobaoClient">
            <summary>淘宝身份验证提供者</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.TaobaoClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.TaobaoClient.OnGetInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>从响应数据中获取信息</summary>
            <param name="dic"></param>
        </member>
        <member name="T:NewLife.Web.OAuth.WeixinClient">
            <summary>身份验证提供者</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.WeixinClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.WeixinClient.OnGetInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>从响应数据中获取信息</summary>
            <param name="dic"></param>
        </member>
        <member name="T:NewLife.Web.OAuth.BaiduClient">
            <summary>身份验证提供者</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.BaiduClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.BaiduClient.OnGetInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>从响应数据中获取信息</summary>
            <param name="dic"></param>
        </member>
        <member name="T:NewLife.Web.OAuth.QQClient">
            <summary>身份验证提供者</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.QQClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.OAuth.QQClient.OnGetInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>从响应数据中获取信息</summary>
            <param name="dic"></param>
        </member>
        <member name="T:NewLife.Web.OAuthServer">
            <summary>单点登录服务端</summary>
        </member>
        <member name="P:NewLife.Web.OAuthServer.Cache">
            <summary>缓存</summary>
        </member>
        <member name="P:NewLife.Web.OAuthServer.TokenProvider">
            <summary>令牌提供者</summary>
        </member>
        <member name="P:NewLife.Web.OAuthServer.Expire">
            <summary>令牌有效期。默认24小时</summary>
        </member>
        <member name="P:NewLife.Web.OAuthServer.Instance">
            <summary>实例</summary>
        </member>
        <member name="M:NewLife.Web.OAuthServer.Authorize(System.String,System.String,System.String,System.String,System.String)">
            <summary>验证用户身份</summary>
            <remarks>
            子系统需要验证访问者身份时，引导用户跳转到这里。
            用户登录完成后，得到一个独一无二的code，并跳转回去子系统。
            </remarks>
            <param name="client_id">应用标识</param>
            <param name="redirect_uri">回调地址</param>
            <param name="response_type">响应类型。默认code</param>
            <param name="scope">授权域</param>
            <param name="state">用户状态数据</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthServer.GetResult(System.Int32,NewLife.Model.IManageUser)">
            <summary>根据验证结果获取跳转回子系统的Url</summary>
            <param name="key"></param>
            <param name="user"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthServer.GetToken(System.String,System.String,System.String)">
            <summary>根据Code获取令牌</summary>
            <param name="client_id"></param>
            <param name="client_secret"></param>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthServer.Decode(System.String)">
            <summary>解码令牌</summary>
            <param name="token"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.OAuthServer.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Web.OAuthServer.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Web.OAuthConfig">
            <summary>配置</summary>
        </member>
        <member name="P:NewLife.Web.OAuthConfig.Debug">
            <summary>调试开关。默认true</summary>
        </member>
        <member name="P:NewLife.Web.OAuthConfig.AppUrl">
            <summary>应用地址。域名和端口，应用系统经过反向代理重定向时指定外部地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthConfig.Items">
            <summary>配置项</summary>
        </member>
        <member name="M:NewLife.Web.OAuthConfig.OnLoaded">
            <summary>已加载</summary>
        </member>
        <member name="M:NewLife.Web.OAuthConfig.Get(System.String)">
            <summary>获取</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthConfig.GetOrAdd(System.String)">
            <summary>获取或添加</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.OAuthItem">
            <summary>开放验证服务器配置项</summary>
        </member>
        <member name="P:NewLife.Web.OAuthItem.Name">
            <summary>服务地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthItem.Server">
            <summary>验证服务地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthItem.AccessServer">
            <summary>令牌服务地址。可以不同于验证地址的内网直达地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthItem.AppID">
            <summary>应用标识</summary>
        </member>
        <member name="P:NewLife.Web.OAuthItem.Secret">
            <summary>密钥</summary>
        </member>
        <member name="P:NewLife.Web.OAuthItem.Scope">
            <summary>授权范围</summary>
        </member>
        <member name="T:NewLife.Web.TokenProvider">
            <summary>令牌提供者</summary>
        </member>
        <member name="P:NewLife.Web.TokenProvider.Key">
            <summary>密钥。签发方用私钥，验证方用公钥</summary>
        </member>
        <member name="M:NewLife.Web.TokenProvider.ReadKey(System.String,System.Boolean)">
            <summary>读取密钥</summary>
            <param name="file">文件</param>
            <param name="generate">是否生成</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.TokenProvider.Encode(System.String,System.DateTime)">
            <summary>编码用户和有效期得到令牌</summary>
            <param name="user">用户</param>
            <param name="expire">有效期</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.TokenProvider.Decode(System.String,System.DateTime@)">
            <summary>令牌解码得到用户和有效期</summary>
            <param name="token">令牌</param>
            <param name="expire">有效期</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.Js">
            <summary>JavaScript脚本。提供Js的基本操作，同时也支持继承扩展</summary>
            <remarks>
            提供静态成员<see cref="P:NewLife.Web.Js.Current"/>，以及常用的<see cref="M:NewLife.Web.Js.WriteScript(System.String,System.Boolean)"/>和<see cref="M:NewLife.Web.Js.Alert(System.String,System.String,System.Int32,System.String)"/>
            </remarks>
        </member>
        <member name="P:NewLife.Web.Js.Current">
            <summary>当前实现</summary>
        </member>
        <member name="M:NewLife.Web.Js.Encode(System.String)">
            <summary>Js脚本编码</summary>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Js.WriteScript(System.String,System.Boolean)">
            <summary>输出脚本</summary>
            <param name="script"></param>
            <param name="addScriptTags"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Js.Alert(System.String,System.String,System.Int32,System.String)">
            <summary>弹出页面提示</summary>
            <param name="message">消息内容</param>
            <param name="title">标题</param>
            <param name="delaySecond">延迟指定秒数以后自动关闭，默认0表示不关闭</param>
            <param name="kind">种类，info/success/error等</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Js.NewLife#Web#IJs#WriteScript(System.String,System.Boolean)">
            <summary>输出脚本</summary>
            <param name="script"></param>
            <param name="addScriptTags"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Js.OnWriteScript(System.String,System.Boolean)">
            <summary>输出脚本</summary>
            <param name="script"></param>
            <param name="addScriptTags"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Js.NewLife#Web#IJs#Alert(System.String,System.String,System.Int32,System.String)">
            <summary>弹出页面提示</summary>
            <param name="message">消息内容</param>
            <param name="title">标题</param>
            <param name="msDelay">延迟指定毫秒数以后自动关闭，默认0表示不关闭</param>
            <param name="kind">种类，info/success/error等</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Js.OnAlert(System.String,System.String,System.Int32,System.String)">
            <summary>弹出页面提示</summary>
            <param name="message">消息内容</param>
            <param name="title">标题</param>
            <param name="msDelay">延迟指定毫秒数以后自动关闭，默认0表示不关闭</param>
            <param name="kind">种类，info/success/error等</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Js.End">
            <summary>停止输出</summary>
        </member>
        <member name="M:NewLife.Web.Js.Back">
            <summary>后退一步</summary>
        </member>
        <member name="M:NewLife.Web.Js.Refresh">
            <summary>刷新该页面</summary>
        </member>
        <member name="M:NewLife.Web.Js.Redirect(System.String)">
            <summary>重定向到另外的页面</summary>
            <param name="url"></param>
        </member>
        <member name="M:NewLife.Web.Js.Close">
            <summary>关闭当前页面</summary>
        </member>
        <member name="T:NewLife.Web.IJs">
            <summary>JavaScript脚本接口</summary>
        </member>
        <member name="M:NewLife.Web.IJs.WriteScript(System.String,System.Boolean)">
            <summary>输出脚本</summary>
            <param name="script"></param>
            <param name="addScriptTags"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.IJs.Alert(System.String,System.String,System.Int32,System.String)">
            <summary>弹出页面提示</summary>
            <param name="message">消息内容</param>
            <param name="title">标题</param>
            <param name="msDelay">延迟指定毫秒数以后自动关闭，默认0表示不关闭</param>
            <param name="kind">种类，info/success/error等</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.IJs.End">
            <summary>停止输出</summary>
        </member>
        <member name="M:NewLife.Web.IJs.Back">
            <summary>后退一步</summary>
        </member>
        <member name="M:NewLife.Web.IJs.Refresh">
            <summary>刷新该页面</summary>
        </member>
        <member name="M:NewLife.Web.IJs.Redirect(System.String)">
            <summary>重定向到另外的页面</summary>
            <param name="url"></param>
        </member>
        <member name="M:NewLife.Web.IJs.Close">
            <summary>关闭当前页面</summary>
        </member>
        <member name="T:NewLife.Web.Link">
            <summary>超链接</summary>
        </member>
        <member name="P:NewLife.Web.Link.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Web.Link.Url">
            <summary>超链接</summary>
        </member>
        <member name="P:NewLife.Web.Link.RawUrl">
            <summary>原始超链接</summary>
        </member>
        <member name="P:NewLife.Web.Link.Title">
            <summary>标题</summary>
        </member>
        <member name="P:NewLife.Web.Link.Version">
            <summary>版本</summary>
        </member>
        <member name="P:NewLife.Web.Link.Time">
            <summary>时间</summary>
        </member>
        <member name="P:NewLife.Web.Link.Html">
            <summary>原始Html</summary>
        </member>
        <member name="M:NewLife.Web.Link.Parse(System.String,System.String,System.Func{NewLife.Web.Link,System.Boolean})">
            <summary>分析HTML中的链接</summary>
            <param name="html">Html文本</param>
            <param name="baseurl">基础Url，用于生成超链接的完整Url</param>
            <param name="filter">用于基础过滤的过滤器</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Link.ToString">
            <summary>已重载。</summary>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.ErrorModule">
            <summary>全局错误处理模块</summary>
        </member>
        <member name="M:NewLife.Web.ErrorModule.System#Web#IHttpModule#Init(System.Web.HttpApplication)">
            <summary>初始化模块，准备拦截请求。</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Web.ErrorModule.NeedProcess(System.Web.HttpRequest,System.Exception)">
            <summary>是否需要处理</summary>
            <param name="req"></param>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.ErrorModule.OnError(System.Object,System.EventArgs)">
            <summary>错误处理方法</summary>
            <param name="sender"></param>
            <param name="e"></param>
        </member>
        <member name="T:NewLife.Web.IErrorInfoProvider">
            <summary>错误信息提供者。用于为错误处理模块提供扩展信息</summary>
        </member>
        <member name="M:NewLife.Web.IErrorInfoProvider.AddInfo(System.Exception,System.Text.StringBuilder)">
            <summary>为指定错误添加附加错误信息。需要自己格式化并加换行</summary>
            <param name="ex"></param>
            <param name="builder"></param>
        </member>
        <member name="T:NewLife.Web.CompressionModule">
            <summary>页面压缩模块</summary>
        </member>
        <member name="M:NewLife.Web.CompressionModule.System#Web#IHttpModule#Init(System.Web.HttpApplication)">
            <summary>初始化模块，准备拦截请求。</summary>
            <param name="context"></param>
        </member>
        <member name="P:NewLife.Web.CompressionModule.WebCompressFiles">
            <summary>网页压缩文件</summary>
        </member>
        <member name="M:NewLife.Web.CompressionModule.CanCompress(System.String)">
            <summary>是否可压缩文件</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.CompressionModule.IsEncodingAccepted(System.Web.HttpRequest,System.String)">
            <summary>检查请求头，确认客户端是否支持压缩编码</summary>
            <param name="req"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Web.CompressionModule.SetEncoding(System.Web.HttpResponse,System.String)">
            <summary>添加压缩编码到响应头</summary>
            <param name="res"></param>
            <param name="encoding"></param>
        </member>
        <member name="T:NewLife.Web.RunTimeModule">
            <summary>页面执行时间模块</summary>
        </member>
        <member name="M:NewLife.Web.RunTimeModule.System#Web#IHttpModule#Init(System.Web.HttpApplication)">
            <summary>初始化模块，准备拦截请求。</summary>
            <param name="context"></param>
        </member>
        <member name="M:NewLife.Web.RunTimeModule.OnInit(System.Web.HttpContext)">
            <summary>初始化</summary>
        </member>
        <member name="P:NewLife.Web.RunTimeModule.RunTimeFormat">
            <summary>执行时间字符串</summary>
        </member>
        <member name="M:NewLife.Web.RunTimeModule.WriteRunTime(System.Object,System.EventArgs)">
            <summary>输出运行时间</summary>
        </member>
        <member name="M:NewLife.Web.RunTimeModule.Render(System.Web.HttpContext)">
            <summary>输出</summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.OAuthClient">
            <summary>OAuth 2.0 客户端</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Name">
            <summary>名称</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Server">
            <summary>验证服务器地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.AccessServer">
            <summary>令牌服务地址。可以不同于验证地址的内网直达地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Key">
            <summary>应用Key</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Secret">
            <summary>安全码</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.AuthUrl">
            <summary>验证地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.AccessUrl">
            <summary>访问令牌地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.ResponseType">
            <summary>响应类型</summary>
            <remarks>
            验证服务器跳转回来子系统时的类型，默认code，此时还需要子系统服务端请求验证服务器换取AccessToken；
            可选token，此时验证服务器直接返回AccessToken，子系统不需要再次请求。
            </remarks>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Scope">
            <summary>作用域</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Code">
            <summary>授权码</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.AccessToken">
            <summary>访问令牌</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.RefreshToken">
            <summary>刷新令牌</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.OpenID">
            <summary>统一标识</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Expire">
            <summary>过期时间</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Items">
            <summary>访问项</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Create(System.String)">
            <summary>根据名称创建客户端</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Apply(System.String)">
            <summary>应用参数设置</summary>
            <param name="name"></param>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Apply(NewLife.Web.OAuthItem)">
            <summary>应用参数设置</summary>
            <param name="mi"></param>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Authorize(System.String,System.String,System.Uri)">
            <summary>构建跳转验证地址</summary>
            <param name="redirect">验证完成后调整的目标地址</param>
            <param name="state">用户状态数据</param>
            <param name="baseUri">相对地址的基地址</param>
        </member>
        <member name="M:NewLife.Web.OAuthClient.GetAccessToken(System.String)">
            <summary>根据授权码获取访问令牌</summary>
            <param name="code"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.OAuthClient.OpenIDUrl">
            <summary>OpenID地址</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.GetOpenID">
            <summary>根据授权码获取访问令牌</summary>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.OAuthClient.UserUrl">
            <summary>用户信息地址</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.UserID">
            <summary>用户ID</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.UserName">
            <summary>用户名</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.NickName">
            <summary>昵称</summary>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Avatar">
            <summary>头像</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.GetUserInfo">
            <summary>获取用户信息</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Fill(NewLife.Model.IManageUser)">
            <summary>填充用户，登录成功并获取用户信息之后</summary>
            <param name="user"></param>
        </member>
        <member name="P:NewLife.Web.OAuthClient.LogoutUrl">
            <summary>注销地址</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Logout(System.String,System.String,System.Uri)">
            <summary>注销</summary>
            <param name="redirect">完成后调整的目标地址</param>
            <param name="state">用户状态数据</param>
            <param name="baseUri">相对地址的基地址</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthClient.GetUrl(System.String)">
            <summary>替换地址模版参数</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthClient.GetNameValues(System.String)">
            <summary>获取名值字典</summary>
            <param name="html"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.OAuthClient.LastHtml">
            <summary>最后一次请求的响应内容</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.Request(System.String)">
            <summary>创建客户端</summary>
            <param name="url">路径</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.OAuthClient.OnGetInfo(System.Collections.Generic.IDictionary{System.String,System.String})">
            <summary>从响应数据中获取信息</summary>
            <param name="dic"></param>
        </member>
        <member name="P:NewLife.Web.OAuthClient.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Web.OAuthClient.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Web.Pager">
            <summary>分页器。包含分页排序参数，支持构造Url的功能</summary>
        </member>
        <member name="T:NewLife.Web.Pager.__">
            <summary>名称类。用户可根据需要修改Url参数名</summary>
        </member>
        <member name="F:NewLife.Web.Pager.__.Sort">
            <summary>排序字段</summary>
        </member>
        <member name="F:NewLife.Web.Pager.__.Desc">
            <summary>是否降序</summary>
        </member>
        <member name="F:NewLife.Web.Pager.__.PageIndex">
            <summary>页面索引</summary>
        </member>
        <member name="F:NewLife.Web.Pager.__.PageSize">
            <summary>页面大小</summary>
        </member>
        <member name="F:NewLife.Web.Pager._">
            <summary>名称类。用户可根据需要修改Url参数名</summary>
        </member>
        <member name="P:NewLife.Web.Pager.Params">
            <summary>参数集合</summary>
        </member>
        <member name="P:NewLife.Web.Pager.PageUrlTemplate">
            <summary>分页链接模版。内部将会替换{链接}和{名称}</summary>
        </member>
        <member name="P:NewLife.Web.Pager.Default">
            <summary>默认参数。如果分页参数为默认参数，则不参与构造Url</summary>
        </member>
        <member name="P:NewLife.Web.Pager.Item(System.String)">
            <summary>获取/设置 参数</summary>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Pager.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.Pager.#ctor(NewLife.Data.PageParameter)">
            <summary>用另一个分页参数实例化</summary>
            <param name="pm"></param>
        </member>
        <member name="M:NewLife.Web.Pager.GetBaseUrl(System.Boolean,System.Boolean,System.Boolean)">
            <summary>获取基础Url，用于附加参数</summary>
            <param name="where">查询条件，不包含排序和分页</param>
            <param name="order">排序</param>
            <param name="page">分页</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Pager.GetSortUrl(System.String)">
            <summary>获取排序的Url</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Pager.GetPageUrl(System.String,System.Int64)">
            <summary>获取分页Url</summary>
            <param name="name"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Pager.GetPage(System.String)">
            <summary>获取分页Url</summary>
            <param name="name"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.Pager.GetFormAction(System.String)">
            <summary>获取表单提交的Url</summary>
            <param name="action">动作</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.PluginHelper">
            <summary>插件助手</summary>
        </member>
        <member name="M:NewLife.Web.PluginHelper.LoadPlugin(System.String,System.String,System.String,System.String,System.String)">
            <summary>加载插件</summary>
            <param name="typeName"></param>
            <param name="disname"></param>
            <param name="dll"></param>
            <param name="linkName"></param>
            <param name="urls">提供下载地址的多个目标页面</param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Web.WebClientX">
            <summary>扩展的Web客户端</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Cookie">
            <summary>Cookie容器</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Accept">
            <summary>可接受类型</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.AcceptLanguage">
            <summary>可接受语言</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Referer">
            <summary>引用页面</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Timeout">
            <summary>超时，默认15000毫秒</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.AutomaticDecompression">
            <summary>自动解压缩模式。</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.UserAgent">
            <summary>User-Agent 标头，指定有关客户端代理的信息</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Encoding">
            <summary>编码。网络时代，绝大部分使用utf8编码</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.KeepAlive">
            <summary>保持连接</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.ProxyAddress">
            <summary>代理服务器地址</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Proxy">
            <summary>网页代理</summary>
        </member>
        <member name="M:NewLife.Web.WebClientX.#ctor">
            <summary>实例化</summary>
        </member>
        <member name="M:NewLife.Web.WebClientX.#ctor(System.Boolean,System.Boolean)">
            <summary>初始化常用的东西</summary>
            <param name="ie">是否模拟ie</param>
            <param name="iscompress">是否压缩</param>
        </member>
        <member name="M:NewLife.Web.WebClientX.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.Web.WebClientX.Request">
            <summary>请求</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Response">
            <summary>响应</summary>
        </member>
        <member name="M:NewLife.Web.WebClientX.EnsureCreate">
            <summary>创建客户端会话</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.SendAsync(System.String,System.Net.Http.HttpContent)">
            <summary>发送请求，获取响应</summary>
            <param name="address"></param>
            <param name="content"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadDataAsync(System.String)">
            <summary>下载数据</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadStringAsync(System.String)">
            <summary>下载字符串</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadFileAsync(System.String,System.String)">
            <summary>下载文件</summary>
            <param name="address"></param>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Web.WebClientX.UploadDataTaskAsync(System.String,System.Byte[])">
            <summary>异步上传数据</summary>
            <param name="address"></param>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.Web.WebClientX.UploadValuesAsync(System.String,System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>异步上传表单</summary>
            <param name="address"></param>
            <param name="collection"></param>
        </member>
        <member name="M:NewLife.Web.WebClientX.UploadStringAsync(System.String,System.String)">
            <summary>异步上传字符串</summary>
            <param name="address"></param>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.Web.WebClientX.UploadJsonAsync(System.String,System.Object)">
            <summary>异步上传Json对象</summary>
            <param name="address"></param>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.Web.WebClientX.GetHtml(System.String)">
            <summary>获取指定地址的Html，自动处理文本编码</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.GetLinks(System.String)">
            <summary>获取指定地址的Html，分析所有超链接</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadLink(System.String,System.String,System.String)">
            <summary>分析指定页面指定名称的链接，并下载到目标目录，返回目标文件</summary>
            <remarks>
            根据版本或时间降序排序选择
            </remarks>
            <param name="urls">指定页面</param>
            <param name="name">页面上指定名称的链接</param>
            <param name="destdir">要下载到的目标目录</param>
            <returns>返回已下载的文件，无效时返回空</returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.DownloadLinkAndExtract(System.String,System.String,System.String,System.Boolean)">
            <summary>分析指定页面指定名称的链接，并下载到目标目录，解压Zip后返回目标文件</summary>
            <param name="urls">提供下载地址的多个目标页面</param>
            <param name="name">页面上指定名称的链接</param>
            <param name="destdir">要下载到的目标目录</param>
            <param name="overwrite">是否覆盖目标同名文件</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.SetCookie">
            <summary>根据Http响应设置本地Cookie</summary>
        </member>
        <member name="M:NewLife.Web.WebClientX.GetCookie(System.Net.Http.HttpClient)">
            <summary>从本地获取Cookie并设置到Http请求头</summary>
        </member>
        <member name="P:NewLife.Web.WebClientX.Pool">
            <summary>默认连接池</summary>
        </member>
        <member name="M:NewLife.Web.WebClientX.GetStringAsync(System.String)">
            <summary>访问地址获取字符串</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebClientX.SetAllowUnsafeHeaderParsing(System.Boolean)">
            <summary>设置是否允许不安全头部</summary>
            <remarks>
            微软WebClient默认要求严格的Http头部，否则报错
            </remarks>
            <param name="useUnsafe"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Web.WebClientX.Log">
            <summary>日志</summary>
        </member>
        <member name="T:NewLife.Web.WebDownload">
            <summary>提供网页下载支持，在服务端把一个数据流作为附件传给浏览器，带有断点续传和限速的功能</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.Stream">
            <summary>数据流</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.FileName">
            <summary>文件名</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.ContentType">
            <summary>内容类型</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.Mode">
            <summary>附件配置模式，是在浏览器直接打开，还是提示另存为</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.Speed">
            <summary>速度，每秒传输字节数，根据包大小，每响应一个包后睡眠指定毫秒数，0表示不限制</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.BrowserCache">
            <summary>是否启用浏览器缓存 默认禁用</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.BrowserCacheMaxAge">
            <summary>浏览器最大缓存时间 默认30天。通过Cache-Control头控制max-age，直接使用浏览器缓存，不会发出Http请求，对F5无效</summary>
        </member>
        <member name="P:NewLife.Web.WebDownload.ModifyTime">
            <summary>文件数据最后修改时间，浏览器缓存时用</summary>
        </member>
        <member name="T:NewLife.Web.WebDownload.DispositionMode">
            <summary>附件配置模式</summary>
        </member>
        <member name="F:NewLife.Web.WebDownload.DispositionMode.None">
            <summary>不设置</summary>
        </member>
        <member name="F:NewLife.Web.WebDownload.DispositionMode.Inline">
            <summary>内联模式，在浏览器直接打开</summary>
        </member>
        <member name="F:NewLife.Web.WebDownload.DispositionMode.Attachment">
            <summary>附件模式，提示另存为</summary>
        </member>
        <member name="M:NewLife.Web.WebDownload.ParseMode(System.String)">
            <summary>分析模式</summary>
            <param name="mode"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebDownload.#ctor">
            <summary>构造函数</summary>
        </member>
        <member name="M:NewLife.Web.WebDownload.#ctor(System.IO.Stream)">
            <summary>构造函数</summary>
            <param name="stream"></param>
        </member>
        <member name="M:NewLife.Web.WebDownload.#ctor(System.String,System.Text.Encoding)">
            <summary>构造函数</summary>
            <param name="html"></param>
            <param name="encoding"></param>
        </member>
        <member name="M:NewLife.Web.WebDownload.CheckCache(System.Web.HttpContext)">
            <summary>检查浏览器缓存是否依然有效，如果有效则跳过Render</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebDownload.Render(System.Web.HttpContext)">
            <summary>输出数据流</summary>
        </member>
        <member name="T:NewLife.Web.WebHelper">
            <summary>网页工具类</summary>
        </member>
        <member name="M:NewLife.Web.WebHelper.WriteScript(System.String)">
            <summary>输出脚本</summary>
            <param name="script"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.Alert(System.String)">
            <summary>弹出页面提示</summary>
            <param name="msg"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.AlertAndEnd(System.String)">
            <summary>弹出页面提示并停止输出后退一步！</summary>
            <param name="msg"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.AlertAndRefresh(System.String)">
            <summary>弹出页面提示，并刷新该页面</summary>
            <param name="msg"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.AlertAndRedirect(System.String,System.String)">
            <summary>弹出页面提示并重定向到另外的页面</summary>
            <param name="msg"></param>
            <param name="url"></param>
        </member>
        <member name="M:NewLife.Web.WebHelper.AlertAndClose(System.String)">
            <summary>弹出页面提示并关闭当前页面</summary>
            <param name="msg"></param>
        </member>
        <member name="P:NewLife.Web.WebHelper.UserHost">
            <summary>用户主机。支持非Web</summary>
        </member>
        <member name="P:NewLife.Web.WebHelper.Params">
            <summary>返回请求字符串和表单的名值字段，过滤空值和ViewState，同名时优先表单</summary>
        </member>
        <member name="M:NewLife.Web.WebHelper.GetRawUrl(System.Web.HttpRequest)">
            <summary>获取原始请求Url，支持反向代理</summary>
            <param name="req"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.GetRawUrl(System.Web.HttpRequestBase)">
            <summary>获取原始请求Url，支持反向代理</summary>
            <param name="req"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.UrlParam(System.Text.StringBuilder,System.String)">
            <summary>追加Url参数，不为空时加与符号</summary>
            <param name="sb"></param>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.UrlParam(System.Text.StringBuilder,System.String,System.Object)">
            <summary>追加Url参数，不为空时加与符号</summary>
            <param name="sb">字符串构建</param>
            <param name="name"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.UrlParams(System.Text.StringBuilder,System.Collections.Generic.IDictionary{System.String,System.String},System.String[])">
            <summary>把一个参数字典追加Url参数，指定包含的参数</summary>
            <param name="sb">字符串构建</param>
            <param name="pms">参数字典</param>
            <param name="includes">包含的参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.UrlParamsExcept(System.Text.StringBuilder,System.Collections.Generic.IDictionary{System.String,System.String},System.String[])">
            <summary>把一个参数字典追加Url参数，排除一些参数</summary>
            <param name="sb">字符串构建</param>
            <param name="pms">参数字典</param>
            <param name="excludes">要排除的参数</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.AsUri(System.String,System.Uri)">
            <summary>相对路径转Uri</summary>
            <param name="url">相对路径</param>
            <param name="baseUri">基础</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.AppendReturn(System.Uri,System.String,System.String)">
            <summary>打包返回地址</summary>
            <param name="uri"></param>
            <param name="returnUrl"></param>
            <param name="returnKey"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Web.WebHelper.AppendReturn(System.String,System.String,System.String)">
            <summary>打包返回地址</summary>
            <param name="url"></param>
            <param name="returnUrl"></param>
            <param name="returnKey"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Yun.AMap">
            <summary>高德地图</summary>
            <remarks>
            参考地址 http://lbs.amap.com/api/webservice/guide/api/georegeo/#geo
            </remarks>
        </member>
        <member name="M:NewLife.Yun.AMap.#ctor">
            <summary>高德地图</summary>
        </member>
        <member name="M:NewLife.Yun.AMap.InvokeAsync``1(System.String,System.String)">
            <summary>远程调用</summary>
            <param name="url">目标Url</param>
            <param name="result">结果字段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.AMap.GetGeocoderAsync(System.String,System.String)">
            <summary>查询地址的经纬度坐标</summary>
            <param name="address"></param>
            <param name="city"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.AMap.GetGeoAsync(System.String,System.String,System.Boolean)">
            <summary>查询地址获取坐标</summary>
            <param name="address">地址</param>
            <param name="city">城市</param>
            <param name="formatAddress">是否格式化地址。高德地图默认已经格式化地址</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.AMap.GetGeocoderAsync(NewLife.Data.GeoPoint)">
            <summary>根据坐标获取地址</summary>
            <remarks>
            http://lbs.amap.com/api/webservice/guide/api/georegeo/#regeo
            </remarks>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.AMap.GetGeoAsync(NewLife.Data.GeoPoint)">
            <summary>根据坐标获取地址</summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.AMap.GetDistanceAsync(NewLife.Data.GeoPoint,NewLife.Data.GeoPoint,System.Int32)">
            <summary>计算距离和驾车时间</summary>
            <remarks>
            http://lbs.amap.com/api/webservice/guide/api/direction
            
            type:
            0：直线距离
            1：驾车导航距离（仅支持国内坐标）。
            必须指出，当为1时会考虑路况，故在不同时间请求返回结果可能不同。
            此策略和driving接口的 strategy = 4策略一致
            2：公交规划距离（仅支持同城坐标）
            3：步行规划距离（仅支持5km之间的距离）
            
            distance    路径距离，单位：米
            duration    预计行驶时间，单位：秒
            </remarks>
            <param name="origin"></param>
            <param name="destination"></param>
            <param name="type">路径计算的方式和方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.AMap.GetAreaAsync(System.String,System.Int32,System.Int32)">
            <summary>行政区划</summary>
            <remarks>
            http://lbs.amap.com/api/webservice/guide/api/district
            </remarks>
            <param name="keywords">查询关键字</param>
            <param name="subdistrict">设置显示下级行政区级数</param>
            <param name="code">按照指定行政区划进行过滤，填入后则只返回该省/直辖市信息</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.AMap.IsValidKey(System.String)">
            <summary>是否无效Key。可能禁用或超出限制</summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Yun.BaiduMap">
            <summary>百度地图</summary>
            <remarks>
            参考手册 http://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-geocoding
            </remarks>
        </member>
        <member name="M:NewLife.Yun.BaiduMap.#ctor">
            <summary>高德地图</summary>
        </member>
        <member name="M:NewLife.Yun.BaiduMap.InvokeAsync``1(System.String,System.String)">
            <summary>远程调用</summary>
            <param name="url">目标Url</param>
            <param name="result">结果字段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.BaiduMap.GetGeocoderAsync(System.String,System.String)">
            <summary>查询地址的经纬度坐标</summary>
            <param name="address"></param>
            <param name="city"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.BaiduMap.GetGeoAsync(System.String,System.String,System.Boolean)">
            <summary>查询地址获取坐标</summary>
            <param name="address">地址</param>
            <param name="city">城市</param>
            <param name="formatAddress">是否格式化地址</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.BaiduMap.GetGeocoderAsync(NewLife.Data.GeoPoint)">
            <summary>根据坐标获取地址</summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.BaiduMap.GetGeoAsync(NewLife.Data.GeoPoint)">
            <summary>根据坐标获取地址</summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.BaiduMap.GetDistanceAsync(NewLife.Data.GeoPoint,NewLife.Data.GeoPoint,System.Int32)">
            <summary>计算距离和驾车时间</summary>
            <remarks>
            http://lbsyun.baidu.com/index.php?title=webapi/route-matrix-api-v2
            </remarks>
            <param name="origin"></param>
            <param name="destination"></param>
            <param name="type">路径计算的方式和方法</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.BaiduMap.PlaceSearchAsync(System.String,System.String,System.String,System.Boolean)">
            <summary>行政区划区域检索</summary>
            <remarks>
            http://lbsyun.baidu.com/index.php?title=webapi/guide/webservice-placeapi
            </remarks>
            <param name="query"></param>
            <param name="tag"></param>
            <param name="region"></param>
            <param name="formatAddress"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.BaiduMap.IsValidKey(System.String)">
            <summary>是否无效Key。可能禁用或超出限制</summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:NewLife.Yun.Driving">
            <summary>驾车距离和时间</summary>
        </member>
        <member name="P:NewLife.Yun.Driving.Distance">
            <summary>距离。单位千米</summary>
        </member>
        <member name="P:NewLife.Yun.Driving.Duration">
            <summary>路线耗时。单位秒</summary>
        </member>
        <member name="T:NewLife.Yun.IMap">
            <summary>地图提供者接口</summary>
        </member>
        <member name="P:NewLife.Yun.IMap.AppKey">
            <summary>应用密钥</summary>
        </member>
        <member name="M:NewLife.Yun.IMap.GetStringAsync(System.String)">
            <summary>异步获取字符串</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.IMap.GetGeocoderAsync(System.String,System.String)">
            <summary>查询地址的经纬度坐标</summary>
            <param name="address"></param>
            <param name="city"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.IMap.GetGeoAsync(System.String,System.String,System.Boolean)">
            <summary>查询地址获取坐标</summary>
            <param name="address">地址</param>
            <param name="city">城市</param>
            <param name="formatAddress">是否格式化地址</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.IMap.GetGeocoderAsync(NewLife.Data.GeoPoint)">
            <summary>根据坐标获取地址</summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.IMap.GetGeoAsync(NewLife.Data.GeoPoint)">
            <summary>根据坐标获取地址</summary>
            <param name="point"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.IMap.GetDistanceAsync(NewLife.Data.GeoPoint,NewLife.Data.GeoPoint,System.Int32)">
            <summary>计算距离和驾车时间</summary>
            <param name="origin"></param>
            <param name="destination"></param>
            <param name="type">路径计算的方式和方法</param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Yun.IMap.Log">
            <summary>日志</summary>
        </member>
        <member name="T:NewLife.Yun.Map">
            <summary>地图提供者</summary>
        </member>
        <member name="P:NewLife.Yun.Map.AppKey">
            <summary>应用密钥。多个key逗号分隔</summary>
        </member>
        <member name="P:NewLife.Yun.Map.KeyName">
            <summary>应用密码参数名</summary>
        </member>
        <member name="P:NewLife.Yun.Map.LastKey">
            <summary>最后密钥</summary>
        </member>
        <member name="P:NewLife.Yun.Map.CoordType">
            <summary>坐标系</summary>
        </member>
        <member name="P:NewLife.Yun.Map.LastUrl">
            <summary>最后网址</summary>
        </member>
        <member name="P:NewLife.Yun.Map.LastString">
            <summary>最后响应</summary>
        </member>
        <member name="P:NewLife.Yun.Map.LastResult">
            <summary>最后结果</summary>
        </member>
        <member name="P:NewLife.Yun.Map.ThrowException">
            <summary>收到异常响应时是否抛出异常</summary>
        </member>
        <member name="M:NewLife.Yun.Map.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Yun.Map.GetStringAsync(System.String)">
            <summary>异步获取字符串</summary>
            <param name="url"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.Map.InvokeAsync``1(System.String,System.String)">
            <summary>远程调用</summary>
            <param name="url">目标Url</param>
            <param name="result">结果字段</param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.Map.AcquireKey">
            <summary>申请密钥</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Yun.Map.RemoveKey(System.String)">
            <summary>移除不可用密钥</summary>
            <param name="key"></param>
        </member>
        <member name="M:NewLife.Yun.Map.IsValidKey(System.String)">
            <summary>是否无效Key。可能禁用或超出限制</summary>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="P:NewLife.Yun.Map.Log">
            <summary>日志</summary>
        </member>
        <member name="M:NewLife.Yun.Map.WriteLog(System.String,System.Object[])">
            <summary>写日志</summary>
            <param name="format"></param>
            <param name="args"></param>
        </member>
        <member name="T:NewLife.Windows.SerialPortList">
            <summary>串口列表控件</summary>
        </member>
        <member name="P:NewLife.Windows.SerialPortList.Port">
            <summary>端口</summary>
        </member>
        <member name="P:NewLife.Windows.SerialPortList.SelectedPort">
            <summary>选择的端口</summary>
        </member>
        <member name="P:NewLife.Windows.SerialPortList.BytesOfReceived">
            <summary>收到的字节数</summary>
        </member>
        <member name="P:NewLife.Windows.SerialPortList.BytesOfSent">
            <summary>发送的字节数</summary>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.#ctor">
            <summary></summary>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.LoadInfo">
            <summary>加载配置信息</summary>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.SaveInfo">
            <summary>保存配置信息</summary>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.ShowPorts">
            <summary>下拉框显示串口</summary>
        </member>
        <member name="P:NewLife.Windows.SerialPortList.Menu">
            <summary>右键菜单</summary>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.Connect">
            <summary>连接串口</summary>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.Disconnect">
            <summary>断开串口连接</summary>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.SelectMenu(System.Object,System.Windows.Forms.ToolStripMenuItem[])">
            <summary>在一个菜单列表中点击某一个菜单，改变菜单选择并返回选中的菜单索引</summary>
            <param name="sender"></param>
            <param name="ms"></param>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.SelectMenu(System.Object,System.Windows.Forms.ToolStripItem)">
            <summary>在同级菜单中选择</summary>
            <param name="sender"></param>
            <param name="tsi"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.Send(System.Byte[])">
            <summary>发送字节数组</summary>
            <param name="data"></param>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.Send(System.String)">
            <summary>发送字符串。根据配置进行十六进制编码</summary>
            <param name="str"></param>
            <returns>发送字节数</returns>
        </member>
        <member name="E:NewLife.Windows.SerialPortList.Received">
            <summary>收到数据时触发。第一个参数是数据，第二个参数返回是否继续往下传递数据</summary>
        </member>
        <member name="E:NewLife.Windows.SerialPortList.ReceivedString">
            <summary>收到数据时转为字符串后触发该事件。注意字符串编码和十六进制编码。</summary>
            <remarks>如果需要收到的数据，可直接在<seealso cref="P:NewLife.Windows.SerialPortList.Port"/>上挂载事件</remarks>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.ClearSend">
            <summary>清空发送</summary>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.ClearReceive">
            <summary>清空接收</summary>
        </member>
        <member name="F:NewLife.Windows.SerialPortList.components">
            <summary> 
            必需的设计器变量。
            </summary>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.Dispose(System.Boolean)">
            <summary> 
            清理所有正在使用的资源。
            </summary>
            <param name="disposing">如果应释放托管资源，为 true；否则为 false。</param>
        </member>
        <member name="M:NewLife.Windows.SerialPortList.InitializeComponent">
            <summary> 
            设计器支持所需的方法 - 不要
            使用代码编辑器修改此方法的内容。
            </summary>
        </member>
        <member name="T:NewLife.Windows.StringEventArgs">
            <summary>字符串事件参数</summary>
        </member>
        <member name="P:NewLife.Windows.StringEventArgs.Value">
            <summary>字符串值</summary>
        </member>
        <member name="T:NewLife.Windows.BufferEventArgs">
            <summary>缓冲区事件参数</summary>
        </member>
        <member name="P:NewLife.Windows.BufferEventArgs.Value">
            <summary>缓冲区数据</summary>
        </member>
        <member name="T:NewLife.Windows.SpeechRecognition">
            <summary>语音识别</summary>
        </member>
        <member name="P:NewLife.Windows.SpeechRecognition.Name">
            <summary>系统名称。用于引导前缀</summary>
        </member>
        <member name="F:NewLife.Windows.SpeechRecognition._Tip">
            <summary>最后一次进入引导前缀的时间。</summary>
        </member>
        <member name="P:NewLife.Windows.SpeechRecognition.Enable">
            <summary>是否可用</summary>
        </member>
        <member name="M:NewLife.Windows.SpeechRecognition.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="P:NewLife.Windows.SpeechRecognition.Current">
            <summary>当前实例</summary>
        </member>
        <member name="M:NewLife.Windows.SpeechRecognition.GetAllKeys">
            <summary>获取已注册的所有键值</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Windows.SpeechRecognition.Register(System.String,System.Action)">
            <summary>注册要语音识别的关键字到委托</summary>
            <param name="text"></param>
            <param name="callback"></param>
        </member>
        <member name="T:NewLife.Windows.ISpeech">
            <summary>语音接口</summary>
        </member>
        <member name="E:NewLife.Windows.ISpeech.SpeechRecognized">
            <summary>语音识别事件</summary>
        </member>
        <member name="M:NewLife.Windows.ISpeech.Init">
            <summary>初始化</summary>
            <returns></returns>
        </member>
        <member name="M:NewLife.Windows.ISpeech.SetChoices(System.Collections.Generic.IEnumerable{System.String})">
            <summary>设置识别短语</summary>
            <param name="phrases"></param>
        </member>
        <member name="T:NewLife.Windows.RecognitionEventArgs">
            <summary>识别事件参数</summary>
        </member>
        <member name="P:NewLife.Windows.RecognitionEventArgs.Confidence">
            <summary>获取识别器分配的值，此值表示与给定输入匹配的可能性</summary>
        </member>
        <member name="P:NewLife.Windows.RecognitionEventArgs.Text">
            <summary>获取语音识别器从识别的输入生成的规范化文本</summary>
        </member>
        <member name="M:NewLife.Windows.RecognitionEventArgs.#ctor(System.Single,System.String)">
            <summary>实例化</summary>
            <param name="conf"></param>
            <param name="text"></param>
        </member>
        <member name="T:NewLife.Xml.SerializableDictionary`2">
            <summary>支持Xml序列化的泛型字典类 </summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.#ctor">
            <summary></summary>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.#ctor(System.Collections.Generic.IDictionary{`0,`1})">
            <summary></summary>
            <param name="dictionary"></param>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.ReadXml(System.Xml.XmlReader)">
            <summary>读取Xml</summary>
            <param name="reader">Xml读取器</param>
        </member>
        <member name="M:NewLife.Xml.SerializableDictionary`2.WriteXml(System.Xml.XmlWriter)">
            <summary>写入Xml</summary>
            <param name="writer">Xml写入器</param>
        </member>
        <member name="T:NewLife.Xml.XmlConfig`1">
            <summary>Xml配置文件基类</summary>
            <remarks>
            标准用法：TConfig.Current
            
            配置实体类通过<see cref="T:NewLife.Xml.XmlConfigFileAttribute"/>特性指定配置文件路径以及自动更新时间。
            Current将加载配置文件，如果文件不存在或者加载失败，将实例化一个对象返回。
            
            考虑到自动刷新，不提供LoadFile和SaveFile等方法，可通过扩展方法ToXmlFileEntity和ToXmlFile实现。
            
            用户也可以通过配置实体类的静态构造函数修改基类的<see cref="P:NewLife.Xml.XmlConfig`1._.ConfigFile"/>和<see cref="P:NewLife.Xml.XmlConfig`1._.ReloadTime"/>来动态配置加载信息。
            </remarks>
            <typeparam name="TConfig"></typeparam>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.Current">
            <summary>当前实例。通过置空可以使其重新加载。</summary>
        </member>
        <member name="T:NewLife.Xml.XmlConfig`1._">
            <summary>一些设置。派生类可以在自己的静态构造函数中指定</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.Debug">
            <summary>是否调试</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.ConfigFile">
            <summary>配置文件路径</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.ReloadTime">
            <summary>重新加载时间。单位：毫秒</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1._.SaveNew">
            <summary>没有配置文件时是否保存新配置。默认true</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.ConfigFile">
            <summary>配置文件</summary>
        </member>
        <member name="F:NewLife.Xml.XmlConfig`1.lastWrite">
            <summary>最后写入时间</summary>
        </member>
        <member name="F:NewLife.Xml.XmlConfig`1.expire">
            <summary>过期时间。如果在这个时间之后再次访问，将检查文件修改时间</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.IsUpdated">
            <summary>是否已更新。通过文件写入时间判断</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.SetExpire">
            <summary>设置过期重新加载配置的时间</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfig`1.IsNew">
            <summary>是否新的配置文件</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.OnDispose(System.Boolean)">
            <summary>销毁</summary>
            <param name="disposing"></param>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.Load(System.String)">
            <summary>加载指定配置文件</summary>
            <param name="filename"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.OnLoaded">
            <summary>从配置文件中读取完成后触发</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.Save(System.String)">
            <summary>保存到配置文件中去</summary>
            <param name="filename"></param>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.Save">
            <summary>保存到配置文件中去</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.SaveAsync">
            <summary>异步保存</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfig`1.OnNew">
            <summary>新创建配置文件时执行</summary>
        </member>
        <member name="T:NewLife.Xml.XmlConfigFileAttribute">
            <summary>Xml配置文件特性</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfigFileAttribute.FileName">
            <summary>配置文件名</summary>
        </member>
        <member name="P:NewLife.Xml.XmlConfigFileAttribute.ReloadTime">
            <summary>重新加载时间。单位：毫秒</summary>
        </member>
        <member name="M:NewLife.Xml.XmlConfigFileAttribute.#ctor(System.String)">
            <summary>指定配置文件名</summary>
            <param name="fileName"></param>
        </member>
        <member name="M:NewLife.Xml.XmlConfigFileAttribute.#ctor(System.String,System.Int32)">
            <summary>指定配置文件名和重新加载时间（毫秒）</summary>
            <param name="fileName"></param>
            <param name="reloadTime"></param>
        </member>
        <member name="T:NewLife.Xml.XmlHelper">
            <summary>Xml辅助类</summary>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Object,System.Text.Encoding,System.Boolean)">
            <summary>序列化为Xml字符串</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="encoding">编码</param>
            <param name="attachComment">是否附加注释，附加成员的Description和DisplayName注释</param>
            <returns>Xml字符串</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Object,System.IO.Stream,System.Text.Encoding,System.Boolean)">
            <summary>序列化为Xml数据流</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="stream">目标数据流</param>
            <param name="encoding">编码</param>
            <param name="attachComment">是否附加注释，附加成员的Description和DisplayName注释</param>
            <returns>Xml字符串</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlFile(System.Object,System.String,System.Text.Encoding,System.Boolean)">
            <summary>序列化为Xml文件</summary>
            <param name="obj">要序列化为Xml的对象</param>
            <param name="file">目标Xml文件</param>
            <param name="encoding">编码</param>
            <param name="attachComment">是否附加注释，附加成员的Description和DisplayName注释</param>
            <returns>Xml字符串</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity``1(System.String)">
            <summary>字符串转为Xml实体对象</summary>
            <typeparam name="TEntity">实体类型</typeparam>
            <param name="xml">Xml字符串</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity(System.String,System.Type)">
            <summary>字符串转为Xml实体对象</summary>
            <param name="xml">Xml字符串</param>
            <param name="type">实体类型</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity``1(System.IO.Stream,System.Text.Encoding)">
            <summary>数据流转为Xml实体对象</summary>
            <typeparam name="TEntity">实体类型</typeparam>
            <param name="stream">数据流</param>
            <param name="encoding">编码</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlEntity(System.IO.Stream,System.Type,System.Text.Encoding)">
            <summary>数据流转为Xml实体对象</summary>
            <param name="stream">数据流</param>
            <param name="type">实体类型</param>
            <param name="encoding">编码</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlFileEntity``1(System.String,System.Text.Encoding)">
            <summary>Xml文件转为Xml实体对象</summary>
            <typeparam name="TEntity">实体类型</typeparam>
            <param name="file">Xml文件</param>
            <param name="encoding">编码</param>
            <returns>Xml实体对象</returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXmlDictionary(System.String)">
            <summary>简单Xml转为字符串字典</summary>
            <param name="xml"></param>
            <returns></returns>
        </member>
        <member name="M:NewLife.Xml.XmlHelper.ToXml(System.Collections.Generic.IDictionary{System.String,System.String},System.String)">
            <summary>字符串字典转为Xml</summary>
            <param name="dic"></param>
            <param name="rootName"></param>
            <returns></returns>
        </member>
        <member name="T:System.Collections.Generic.CollectionHelper">
            <summary>集合扩展</summary>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToArray``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>集合转为数组</summary>
            <typeparam name="T"></typeparam>
            <param name="collection"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToKeyArray``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32)">
            <summary>集合转为数组</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="collection"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToValueArray``2(System.Collections.Generic.IDictionary{``0,``1},System.Int32)">
            <summary>集合转为数组</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="collection"></param>
            <param name="index"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToDictionary(System.Object)">
            <summary>目标匿名参数对象转为字典</summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.Merge(System.Collections.Generic.IDictionary{System.String,System.Object},System.Object,System.Boolean,System.String[])">
            <summary>合并字典参数</summary>
            <param name="dic">字典</param>
            <param name="target">目标对象</param>
            <param name="overwrite">是否覆盖同名参数</param>
            <param name="excludes">排除项</param>
            <returns></returns>
        </member>
        <member name="M:System.Collections.Generic.CollectionHelper.ToNullable``2(System.Collections.Generic.IDictionary{``0,``1},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>转为可空字典</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="collection"></param>
            <param name="comparer"></param>
            <returns></returns>
        </member>
        <member name="T:System.Utility">
            <summary>工具类</summary>
            <remarks>
            采用静态架构，允许外部重载工具类的各种实现<seealso cref="T:System.DefaultConvert"/>。
            所有类型转换均支持默认值，默认值为该default(T)，在转换失败时返回默认值。
            </remarks>
        </member>
        <member name="P:System.Utility.Convert">
            <summary>类型转换提供者</summary>
            <remarks>重载默认提供者<seealso cref="T:System.DefaultConvert"/>并赋值给<see cref="P:System.Utility.Convert"/>可改变所有类型转换的行为</remarks>
        </member>
        <member name="M:System.Utility.ToInt(System.Object,System.Int32)">
            <summary>转为整数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）、时间（Unix秒）</summary>
            <remarks>Int16/UInt32/Int64等，可以先转为最常用的Int32后再二次处理</remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToLong(System.Object,System.Int64)">
            <summary>转为长整数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）</summary>
            <remarks></remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDouble(System.Object,System.Double)">
            <summary>转为浮点数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）</summary>
            <remarks>Single可以先转为最常用的Double后再二次处理</remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToBoolean(System.Object,System.Boolean)">
            <summary>转为布尔型，转换失败时返回默认值。支持大小写True/False、0和非零</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDateTime(System.Object)">
            <summary>转为时间日期，转换失败时返回最小时间。支持字符串、整数（Unix秒）</summary>
            <param name="value">待转换对象</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToDateTime(System.Object,System.DateTime)">
            <summary>转为时间日期，转换失败时返回默认值</summary>
            <remarks><see cref="F:System.DateTime.MinValue"/>不是常量无法做默认值</remarks>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToFullString(System.DateTime)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss完整字符串</summary>
            <remarks>最常用的时间日期格式，可以无视各平台以及系统自定义的时间格式</remarks>
            <param name="value">待转换对象</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToFullString(System.DateTime,System.String)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss完整字符串，支持指定最小时间的字符串</summary>
            <remarks>最常用的时间日期格式，可以无视各平台以及系统自定义的时间格式</remarks>
            <param name="value">待转换对象</param>
            <param name="emptyValue">字符串空值时（DateTime.MinValue）显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.ToString(System.DateTime,System.String,System.String)">
            <summary>时间日期转为指定格式字符串</summary>
            <param name="value">待转换对象</param>
            <param name="format">格式化字符串</param>
            <param name="emptyValue">字符串空值时显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.GetTrue(System.Exception)">
            <summary>获取内部真实异常</summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:System.Utility.GetMessage(System.Exception)">
            <summary>获取异常消息</summary>
            <param name="ex">异常</param>
            <returns></returns>
        </member>
        <member name="T:System.DefaultConvert">
            <summary>默认转换</summary>
        </member>
        <member name="M:System.DefaultConvert.ToInt(System.Object,System.Int32)">
            <summary>转为整数，转换失败时返回默认值。支持字符串、全角、字节数组（小端）、时间（Unix秒）</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToLong(System.Object,System.Int64)">
            <summary>转为长整数</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToDouble(System.Object,System.Double)">
            <summary>转为浮点数</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToBoolean(System.Object,System.Boolean)">
            <summary>转为布尔型。支持大小写True/False、0和非零</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToDateTime(System.Object,System.DateTime)">
            <summary>转为时间日期，转换失败时返回最小时间。支持字符串、整数（Unix秒）</summary>
            <param name="value">待转换对象</param>
            <param name="defaultValue">默认值。待转换对象无效时使用</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToDBC(System.String)">
            <summary>全角为半角</summary>
            <remarks>全角半角的关系是相差0xFEE0</remarks>
            <param name="str"></param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToFullString(System.DateTime,System.String)">
            <summary>时间日期转为yyyy-MM-dd HH:mm:ss完整字符串</summary>
            <param name="value">待转换对象</param>
            <param name="emptyValue">字符串空值时显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToString(System.DateTime,System.String,System.String)">
            <summary>时间日期转为指定格式字符串</summary>
            <param name="value">待转换对象</param>
            <param name="format">格式化字符串</param>
            <param name="emptyValue">字符串空值时显示的字符串，null表示原样显示最小时间，String.Empty表示不显示</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.GetTrue(System.Exception)">
            <summary>获取内部真实异常</summary>
            <param name="ex"></param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.GetMessage(System.Exception)">
            <summary>获取异常消息</summary>
            <param name="ex">异常</param>
            <returns></returns>
        </member>
        <member name="M:System.DefaultConvert.ToGMK(System.Int64,System.String)">
            <summary>字节单位字符串</summary>
            <param name="value">数值</param>
            <param name="format">格式化字符串</param>
            <returns></returns>
        </member>
        <member name="T:System.BitHelper">
            <summary>数据位助手</summary>
        </member>
        <member name="M:System.BitHelper.SetBit(System.UInt16,System.Int32,System.Boolean)">
            <summary>设置数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:System.BitHelper.SetBits(System.UInt16,System.Int32,System.Int32,System.UInt16)">
            <summary>设置数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <param name="length"></param>
            <param name="bits"></param>
            <returns></returns>
        </member>
        <member name="M:System.BitHelper.SetBit(System.Byte,System.Int32,System.Boolean)">
            <summary>设置数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <param name="flag"></param>
            <returns></returns>
        </member>
        <member name="M:System.BitHelper.GetBit(System.UInt16,System.Int32)">
            <summary>获取数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:System.BitHelper.GetBits(System.UInt16,System.Int32,System.Int32)">
            <summary>获取数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:System.BitHelper.GetBit(System.Byte,System.Int32)">
            <summary>获取数据位</summary>
            <param name="value">数值</param>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="T:System.ConcurrentDictionaryExtensions">
            <summary>并行字典扩展</summary>
        </member>
        <member name="M:System.ConcurrentDictionaryExtensions.Remove``2(System.Collections.Concurrent.ConcurrentDictionary{``0,``1},``0)">
            <summary>从并行字典中删除</summary>
            <typeparam name="TKey"></typeparam>
            <typeparam name="TValue"></typeparam>
            <param name="dict"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="T:System.ListExtension">
            <summary>扩展List，支持遍历中修改元素</summary>
        </member>
        <member name="M:System.ListExtension.Find``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>线程安全，搜索并返回第一个，支持遍历中修改元素</summary>
            <param name="list">实体列表</param>
            <param name="match">条件</param>
            <returns></returns>
        </member>
        <member name="M:System.ListExtension.FindAll``1(System.Collections.Generic.IList{``0},System.Predicate{``0})">
            <summary>线程安全，搜索并返回第一个，支持遍历中修改元素</summary>
            <param name="list">实体列表</param>
            <param name="match">条件</param>
            <returns></returns>
        </member>
        <member name="T:System.IO.PathHelper">
            <summary>路径操作帮助</summary>
        </member>
        <member name="P:System.IO.PathHelper.BaseDirectory">
            <summary>基础目录。GetFullPath依赖于此，默认为当前应用程序域基础目录</summary>
        </member>
        <member name="M:System.IO.PathHelper.GetFullPath(System.String)">
            <summary>获取文件或目录的全路径，过滤相对目录</summary>
            <remarks>不确保目录后面一定有分隔符，是否有分隔符由原始路径末尾决定</remarks>
            <param name="path">文件或目录</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.GetBasePath(System.String)">
            <summary>获取文件或目录基于应用程序域基目录的全路径，过滤相对目录</summary>
            <remarks>不确保目录后面一定有分隔符，是否有分隔符由原始路径末尾决定</remarks>
            <param name="path">文件或目录</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.GetCurrentPath(System.String)">
            <summary>获取文件或目录基于当前目录的全路径，过滤相对目录</summary>
            <remarks>不确保目录后面一定有分隔符，是否有分隔符由原始路径末尾决定</remarks>
            <param name="path">文件或目录</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.EnsureDirectory(System.String,System.Boolean)">
            <summary>确保目录存在，若不存在则创建</summary>
            <remarks>
            斜杠结尾的路径一定是目录，无视第二参数；
            默认是文件，这样子只需要确保上一层目录存在即可，否则如果把文件当成了目录，目录的创建会导致文件无法创建。
            </remarks>
            <param name="path">文件路径或目录路径，斜杠结尾的路径一定是目录，无视第二参数</param>
            <param name="isfile">该路径是否是否文件路径。文件路径需要取目录部分</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CombinePath(System.String,System.String[])">
            <summary>合并多段路径</summary>
            <param name="path"></param>
            <param name="ps"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.AsFile(System.String)">
            <summary>文件路径作为文件信息</summary>
            <param name="file"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.ReadBytes(System.IO.FileInfo,System.Int32,System.Int32)">
            <summary>从文件中读取数据</summary>
            <param name="file"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.WriteBytes(System.IO.FileInfo,System.Byte[],System.Int32)">
            <summary>把数据写入文件指定位置</summary>
            <param name="file"></param>
            <param name="data"></param>
            <param name="offset"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.ReadText(System.IO.FileInfo,System.Text.Encoding)">
            <summary>读取所有文本，自动检测编码</summary>
            <remarks>性能较File.ReadAllText略慢，可通过提前检测BOM编码来优化</remarks>
            <param name="file"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.WriteText(System.IO.FileInfo,System.String,System.Text.Encoding)">
            <summary>把文本写入文件，自动检测编码</summary>
            <param name="file"></param>
            <param name="text"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CopyToIfNewer(System.IO.FileInfo,System.String)">
            <summary>复制到目标文件，目标文件必须已存在，且源文件较新</summary>
            <param name="fi">源文件</param>
            <param name="destFileName">目标文件</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.Extract(System.IO.FileInfo,System.String,System.Boolean)">
            <summary>解压缩</summary>
            <param name="fi"></param>
            <param name="destDir"></param>
            <param name="overwrite">是否覆盖目标同名文件</param>
        </member>
        <member name="M:System.IO.PathHelper.Compress(System.IO.FileInfo,System.String)">
            <summary>压缩文件</summary>
            <param name="fi"></param>
            <param name="destFile"></param>
        </member>
        <member name="M:System.IO.PathHelper.AsDirectory(System.String)">
            <summary>路径作为目录信息</summary>
            <param name="dir"></param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.GetAllFiles(System.IO.DirectoryInfo,System.String,System.Boolean)">
            <summary>获取目录内所有符合条件的文件，支持多文件扩展匹配</summary>
            <param name="di">目录</param>
            <param name="exts">文件扩展列表。比如*.exe;*.dll;*.config</param>
            <param name="allSub">是否包含所有子孙目录文件</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CopyTo(System.IO.DirectoryInfo,System.String,System.String,System.Boolean,System.Action{System.String})">
            <summary>复制目录中的文件</summary>
            <param name="di">源目录</param>
            <param name="destDirName">目标目录</param>
            <param name="exts">文件扩展列表。比如*.exe;*.dll;*.config</param>
            <param name="allSub">是否包含所有子孙目录文件</param>
            <param name="callback">复制每一个文件之前的回调</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CopyToIfNewer(System.IO.DirectoryInfo,System.String,System.String,System.Boolean,System.Action{System.String})">
            <summary>对比源目录和目标目录，复制双方都存在且源目录较新的文件</summary>
            <param name="di">源目录</param>
            <param name="destDirName">目标目录</param>
            <param name="exts">文件扩展列表。比如*.exe;*.dll;*.config</param>
            <param name="allSub">是否包含所有子孙目录文件</param>
            <param name="callback">复制每一个文件之前的回调</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.CopyIfNewer(System.IO.DirectoryInfo,System.String[],System.String,System.Boolean)">
            <summary>从多个目标目录复制较新文件到当前目录</summary>
            <param name="di">当前目录</param>
            <param name="source">多个目标目录</param>
            <param name="exts">文件扩展列表。比如*.exe;*.dll;*.config</param>
            <param name="allSub">是否包含所有子孙目录文件</param>
            <returns></returns>
        </member>
        <member name="M:System.IO.PathHelper.Compress(System.IO.DirectoryInfo,System.String)">
            <summary>压缩</summary>
            <param name="di"></param>
            <param name="destFile"></param>
        </member>
        <member name="T:System.ModelExtension">
            <summary>模型扩展</summary>
        </member>
        <member name="M:System.ModelExtension.GetService``1(System.IServiceProvider)">
            <summary>获取指定类型的服务对象</summary>
            <typeparam name="T"></typeparam>
            <param name="provider"></param>
            <returns></returns>
        </member>
        <member name="T:System.ObjectContainerHelper">
            <summary>对象容器助手。扩展方法专用</summary>
        </member>
        <member name="M:System.ObjectContainerHelper.Register``2(NewLife.Model.IObjectContainer,System.Object,System.Int32)">
            <summary>注册类型和名称</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <typeparam name="TImplement">实现类型</typeparam>
            <param name="container">对象容器</param>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:System.ObjectContainerHelper.Register``1(NewLife.Model.IObjectContainer,System.Object,System.Object,System.Int32)">
            <summary>注册类型指定名称的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="container">对象容器</param>
            <param name="instance">实例</param>
            <param name="id">标识</param>
            <param name="priority">优先级</param>
            <returns></returns>
        </member>
        <member name="M:System.ObjectContainerHelper.Resolve``1(NewLife.Model.IObjectContainer,System.Object)">
            <summary>解析类型指定名称的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="container">对象容器</param>
            <param name="id">标识</param>
            <returns></returns>
        </member>
        <member name="M:System.ObjectContainerHelper.ResolveInstance``1(NewLife.Model.IObjectContainer,System.Object)">
            <summary>解析类型指定名称的实例</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="container">对象容器</param>
            <param name="id">标识</param>
            <returns></returns>
        </member>
        <member name="M:System.ObjectContainerHelper.AutoRegister``2(NewLife.Model.IObjectContainer)">
            <summary>遍历所有程序集的所有类型，自动注册实现了指定接口或基类的类型。如果没有注册任何实现，则默认注册第一个排除类型</summary>
            <remarks>自动注册一般用于单实例功能扩展型接口</remarks>
            <typeparam name="TInterface">接口类型</typeparam>
            <typeparam name="TImplement">要排除的类型，一般是内部默认实现</typeparam>
            <param name="container">对象容器</param>
            <returns></returns>
        </member>
        <member name="M:System.ObjectContainerHelper.ResolveType``1(NewLife.Model.IObjectContainer,System.Object)">
            <summary>解析接口指定名称的实现类型</summary>
            <typeparam name="TInterface">接口类型</typeparam>
            <param name="container">对象容器</param>
            <param name="id">标识</param>
            <returns></returns>
        </member>
        <member name="T:System.NetHelper">
            <summary>网络工具类</summary>
        </member>
        <member name="M:System.NetHelper.SetTcpKeepAlive(System.Net.Sockets.Socket,System.Boolean,System.Int32,System.Int32)">
            <summary>设置超时检测时间和检测间隔</summary>
            <param name="socket">要设置的Socket对象</param>
            <param name="iskeepalive">是否启用Keep-Alive</param>
            <param name="starttime">多长时间后开始第一次探测（单位：毫秒）</param>
            <param name="interval">探测时间间隔（单位：毫秒）</param>
        </member>
        <member name="M:System.NetHelper.ParseAddress(System.String)">
            <summary>分析地址，根据IP或者域名得到IP地址，缓存60秒，异步更新</summary>
            <param name="hostname"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.ParseEndPoint(System.String,System.Int32)">
            <summary>分析网络终结点</summary>
            <param name="address">地址，可以不带端口</param>
            <param name="defaultPort">地址不带端口时指定的默认端口</param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.GetRightAny(System.Net.IPAddress,System.Net.Sockets.AddressFamily)">
            <summary>针对IPv4和IPv6获取合适的Any地址</summary>
            <remarks>除了Any地址以为，其它地址不具备等效性</remarks>
            <param name="address"></param>
            <param name="family"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.IsAny(System.Net.IPAddress)">
            <summary>是否Any地址，同时处理IPv4和IPv6</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.IsAny(System.Net.EndPoint)">
            <summary>是否Any结点</summary>
            <param name="endpoint"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.IsIPv4(System.Net.IPAddress)">
            <summary>是否IPv4地址</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.IsLocal(System.Net.IPAddress)">
            <summary>是否本地地址</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.GetRelativeAddress(System.Net.IPAddress,System.Net.IPAddress)">
            <summary>获取相对于指定远程地址的本地地址</summary>
            <param name="address"></param>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.GetRelativeEndPoint(System.Net.IPEndPoint,System.Net.IPAddress)">
            <summary>获取相对于指定远程地址的本地地址</summary>
            <param name="local"></param>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.CheckPort(System.Net.IPAddress,NewLife.Net.NetType,System.Int32)">
            <summary>指定地址的指定端口是否已被使用，似乎没办法判断IPv6地址</summary>
            <param name="protocol"></param>
            <param name="address"></param>
            <param name="port"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.CheckPort(NewLife.Net.NetUri)">
            <summary>检查该协议的地址端口是否已经呗使用</summary>
            <param name="uri"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.GetActiveInterfaces">
            <summary>获取活动的接口信息</summary>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.GetDhcps">
            <summary>获取可用的DHCP地址</summary>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.GetDns">
            <summary>获取可用的DNS地址</summary>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.GetGateways">
            <summary>获取可用的网关地址</summary>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.GetIPs">
            <summary>获取可用的IP地址</summary>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.GetIPsWithCache">
            <summary>获取本机可用IP地址，缓存60秒，异步更新</summary>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.GetMulticasts">
            <summary>获取可用的多播地址</summary>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.GetMacs">
            <summary>获取以太网MAC地址</summary>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.MyIP">
            <summary>获取本地第一个IPv4地址</summary>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.MyIPv6">
            <summary>获取本地第一个IPv6地址</summary>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.SetIP(System.String,System.String)">
            <summary>设置IP，默认掩码255.255.255.0</summary>
            <param name="ip"></param>
            <param name="mask"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.SetGateway(System.String)">
            <summary>设置默认网关</summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.StartDHCP">
            <summary>启动DHCP</summary>
        </member>
        <member name="M:System.NetHelper.Wake(System.String[])">
            <summary>唤醒指定MAC地址的计算机</summary>
            <param name="macs"></param>
        </member>
        <member name="M:System.NetHelper.GetMac(System.Net.IPAddress)">
            <summary>根据IP地址获取MAC地址</summary>
            <param name="ip"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.GetAddress(System.Net.IPAddress)">
            <summary>获取IP地址的物理地址位置</summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.IPToAddress(System.String)">
            <summary>根据字符串形式IP地址转为物理地址</summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="T:System.NetHelper.IPProvider">
            <summary>IP地址提供者接口</summary>
        </member>
        <member name="M:System.NetHelper.IPProvider.GetAddress(System.Net.IPAddress)">
            <summary>获取IP地址的物理地址位置</summary>
            <param name="addr"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.SetTcpMax">
            <summary>设置最大Tcp连接数</summary>
        </member>
        <member name="M:System.NetHelper.ShowTcpParameters">
            <summary>显示Tcp参数</summary>
        </member>
        <member name="P:System.NetHelper.TcpNumConnections">
            <summary>最大TCP连接数。默认16M</summary>
        </member>
        <member name="P:System.NetHelper.MaxUserPort">
            <summary>最大用户端口数。默认5000</summary>
            <remarks>
            TCP客户端和服务器连接时，客户端必须分配一个动态端口，默认情况下这个动态端口的分配范围为 1024-5000 ，也就是说默认情况下，客户端最多可以同时发起3977 个Socket 连接
            </remarks>
        </member>
        <member name="P:System.NetHelper.MaxFreeTcbs">
            <summary>最大TCB 数量。默认2000</summary>
            <remarks>
            系统为每个TCP 连接分配一个TCP 控制块(TCP control block or TCB)，这个控制块用于缓存TCP连接的一些参数，每个TCB需要分配 0.5 KB的pagepool 和 0.5KB 的Non-pagepool，也就说，每个TCP连接会占用 1KB 的系统内存
            </remarks>
        </member>
        <member name="P:System.NetHelper.MaxHashTableSize">
            <summary>最大TCP连接数。默认16M</summary>
            <remarks>
            这个值指明分配 pagepool 内存的数量，也就是说，如果MaxFreeTcbs = 1000 , 则 pagepool 的内存数量为 500KB
            那么 MaxHashTableSize 应大于 500 才行。这个数量越大，则Hash table 的冗余度就越高，每次分配和查找 TCP  连接用时就越少。这个值必须是2的幂，且最大为65536.
            </remarks>
        </member>
        <member name="P:System.NetHelper.TcpTimedWaitDelay">
            <summary>系统释放已关闭的TCP连接并复用其资源之前，必须等待的时间。默认240</summary>
            <remarks>
            这段时间间隔就是TIME_WAIT状态（2MSL，数据包最长生命周期的两倍状态）。
            如果系统显示大量连接处于TIME_WAIT状态，则会导致并发量与吞吐量的严重下降，通过减小该项的值，系统可以更快地释放已关闭的连接，
            从而为新连接提供更多的资源，特别是对于高并发短连接的Server具有积极的意义。
            </remarks>
        </member>
        <member name="P:System.NetHelper.KeepAliveTime">
            <summary>控制系统尝试验证空闲连接是否仍然完好的频率。默认2小时</summary>
            <remarks>
            如果该连接在一段时间内没有活动，那么系统会发送保持连接的信号，如果网络正常并且接收方是活动的，它就会响应。如果需要对丢失接收方的情况敏感，也就是说需要更快地发现是否丢失了接收方，请考虑减小该值。而如果长期不活动的空闲连接的出现次数较多，但丢失接收方的情况出现较少，那么可能需要增大该值以减少开销。
            </remarks>
        </member>
        <member name="P:System.NetHelper.EnableConnectionRateLimiting">
            <summary>半开连接数限制。默认0</summary>
        </member>
        <member name="M:System.NetHelper.CreateClient(NewLife.Net.NetUri)">
            <summary>根据本地网络标识创建客户端</summary>
            <param name="local"></param>
            <returns></returns>
        </member>
        <member name="M:System.NetHelper.CreateRemote(NewLife.Net.NetUri)">
            <summary>根据远程网络标识创建客户端</summary>
            <param name="remote"></param>
            <returns></returns>
        </member>
        <member name="T:System.EnumHelper">
            <summary>枚举类型助手类</summary>
        </member>
        <member name="M:System.EnumHelper.Has(System.Enum,System.Enum)">
            <summary>枚举变量是否包含指定标识</summary>
            <param name="value">枚举变量</param>
            <param name="flag">要判断的标识</param>
            <returns></returns>
        </member>
        <member name="M:System.EnumHelper.Set``1(System.Enum,``0,System.Boolean)">
            <summary>设置标识位</summary>
            <typeparam name="T"></typeparam>
            <param name="source"></param>
            <param name="flag"></param>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:System.EnumHelper.GetDescription(System.Enum)">
            <summary>获取枚举字段的注释</summary>
            <param name="value">数值</param>
            <returns></returns>
        </member>
        <member name="M:System.EnumHelper.GetDescriptions``1">
            <summary>获取枚举类型的所有字段注释</summary>
            <typeparam name="TEnum"></typeparam>
            <returns></returns>
        </member>
        <member name="M:System.EnumHelper.GetDescriptions(System.Type)">
            <summary>获取枚举类型的所有字段注释</summary>
            <param name="enumType"></param>
            <returns></returns>
        </member>
        <member name="T:System.StringHelper">
            <summary>字符串助手类</summary>
        </member>
        <member name="M:System.StringHelper.EqualIgnoreCase(System.String,System.String[])">
            <summary>忽略大小写的字符串相等比较，判断是否以任意一个待比较字符串相等</summary>
            <param name="value">字符串</param>
            <param name="strs">待比较字符串数组</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.StartsWithIgnoreCase(System.String,System.String[])">
            <summary>忽略大小写的字符串开始比较，判断是否以任意一个待比较字符串开始</summary>
            <param name="value">字符串</param>
            <param name="strs">待比较字符串数组</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.EndsWithIgnoreCase(System.String,System.String[])">
            <summary>忽略大小写的字符串结束比较，判断是否以任意一个待比较字符串结束</summary>
            <param name="value">字符串</param>
            <param name="strs">待比较字符串数组</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.IsNullOrEmpty(System.String)">
            <summary>指示指定的字符串是 null 还是 String.Empty 字符串</summary>
            <param name="value">字符串</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.IsNullOrWhiteSpace(System.String)">
            <summary>是否空或者空白字符串</summary>
            <param name="value">字符串</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.Split(System.String,System.String[])">
            <summary>拆分字符串，过滤空格，无效时返回空数组</summary>
            <param name="value">字符串</param>
            <param name="separators">分组分隔符，默认逗号分号</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.SplitAsInt(System.String,System.String[])">
            <summary>拆分字符串成为整型数组，默认逗号分号分隔，无效时返回空数组</summary>
            <remarks>过滤空格、过滤无效、不过滤重复</remarks>
            <param name="value">字符串</param>
            <param name="separators">分组分隔符，默认逗号分号</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.SplitAsDictionary(System.String,System.String,System.String[])">
            <summary>拆分字符串成为不区分大小写的可空名值字典。逗号分号分组，等号分隔</summary>
            <param name="value">字符串</param>
            <param name="nameValueSeparator">名值分隔符，默认等于号</param>
            <param name="separators">分组分隔符，默认逗号分号</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.SplitAsDictionary(System.String,System.String,System.String,System.Boolean)">
            <summary>拆分字符串成为不区分大小写的可空名值字典。逗号分组，等号分隔</summary>
            <param name="value">字符串</param>
            <param name="nameValueSeparator">名值分隔符，默认等于号</param>
            <param name="separator">分组分隔符，默认分号</param>
            <param name="trimQuotation">去掉括号</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.Join(System.Collections.IEnumerable,System.String)">
            <summary>把一个列表组合成为一个字符串，默认逗号分隔</summary>
            <param name="value"></param>
            <param name="separator">组合分隔符，默认逗号</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.Join``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String})">
            <summary>把一个列表组合成为一个字符串，默认逗号分隔</summary>
            <param name="value"></param>
            <param name="separator">组合分隔符，默认逗号</param>
            <param name="func">把对象转为字符串的委托</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.Join``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.Object})">
            <summary>把一个列表组合成为一个字符串，默认逗号分隔</summary>
            <param name="value"></param>
            <param name="separator">组合分隔符，默认逗号</param>
            <param name="func">把对象转为字符串的委托</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.Separate(System.Text.StringBuilder,System.String)">
            <summary>追加分隔符字符串，忽略开头，常用于拼接</summary>
            <param name="sb">字符串构造者</param>
            <param name="separator">分隔符</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.GetBytes(System.String,System.Text.Encoding)">
            <summary>字符串转数组</summary>
            <param name="value">字符串</param>
            <param name="encoding">编码，默认utf-8无BOM</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.F(System.String,System.Object[])">
            <summary>格式化字符串。特别支持无格式化字符串的时间参数</summary>
            <param name="value">格式字符串</param>
            <param name="args">参数</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.EnsureStart(System.String,System.String)">
            <summary>确保字符串以指定的另一字符串开始，不区分大小写</summary>
            <param name="str">字符串</param>
            <param name="start"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.EnsureEnd(System.String,System.String)">
            <summary>确保字符串以指定的另一字符串结束，不区分大小写</summary>
            <param name="str">字符串</param>
            <param name="end"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.TrimStart(System.String,System.String[])">
            <summary>从当前字符串开头移除另一字符串，不区分大小写，循环多次匹配前缀</summary>
            <param name="str">当前字符串</param>
            <param name="starts">另一字符串</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.TrimEnd(System.String,System.String[])">
            <summary>从当前字符串结尾移除另一字符串，不区分大小写，循环多次匹配后缀</summary>
            <param name="str">当前字符串</param>
            <param name="ends">另一字符串</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.Substring(System.String,System.String,System.String,System.Int32,System.Int32[])">
            <summary>从字符串中检索子字符串，在指定头部字符串之后，指定尾部字符串之前</summary>
            <remarks>常用于截取xml某一个元素等操作</remarks>
            <param name="str">目标字符串</param>
            <param name="after">头部字符串，在它之后</param>
            <param name="before">尾部字符串，在它之前</param>
            <param name="startIndex">搜索的开始位置</param>
            <param name="positions">位置数组，两个元素分别记录头尾位置</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.Cut(System.String,System.Int32,System.String)">
            <summary>根据最大长度截取字符串，并允许以指定空白填充末尾</summary>
            <param name="str">字符串</param>
            <param name="maxLength">截取后字符串的最大允许长度，包含后面填充</param>
            <param name="pad">需要填充在后面的字符串，比如几个圆点</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.CutStart(System.String,System.String[])">
            <summary>从当前字符串开头移除另一字符串以及之前的部分</summary>
            <param name="str">当前字符串</param>
            <param name="starts">另一字符串</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.CutEnd(System.String,System.String[])">
            <summary>从当前字符串结尾移除另一字符串以及之后的部分</summary>
            <param name="str">当前字符串</param>
            <param name="ends">另一字符串</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.LevenshteinSearch(System.String,System.String[])">
            <summary>编辑距离搜索，从词组中找到最接近关键字的若干匹配项</summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="key">关键字</param>
            <param name="words">词组</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.LevenshteinDistance(System.String,System.String)">
            <summary>编辑距离</summary>
            <remarks>
            又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。
            许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="str1"></param>
            <param name="str2"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.LCSSearch(System.String,System.String[])">
            <summary>最长公共子序列搜索，从词组中找到最接近关键字的若干匹配项</summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="key"></param>
            <param name="words"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.LCSDistance(System.String,System.String[])">
            <summary>
            最长公共子序列问题是寻找两个或多个已知数列最长的子序列。
            一个数列 S，如果分别是两个或多个已知数列的子序列，且是所有符合此条件序列中最长的，则 S 称为已知序列的最长公共子序列。
            The longest common subsequence (LCS) problem is to find the longest subsequence common to all sequences in a set of sequences (often just two). Note that subsequence is different from a substring, see substring vs. subsequence. It is a classic computer science problem, the basis of diff (a file comparison program that outputs the differences between two files), and has applications in bioinformatics.
            </summary>
            <remarks>
            算法代码由@Aimeast 独立完成。http://www.cnblogs.com/Aimeast/archive/2011/09/05/2167844.html
            </remarks>
            <param name="word"></param>
            <param name="keys">多个关键字。长度必须大于0，必须按照字符串长度升序排列。</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.LCS``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String})">
            <summary>根据列表项成员计算距离</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="keys"></param>
            <param name="keySelector"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.LCSSearch``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String},System.Int32)">
            <summary>在列表项中进行模糊搜索</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="keys"></param>
            <param name="keySelector"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.Match``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String})">
            <summary>模糊匹配</summary>
            <typeparam name="T"></typeparam>
            <param name="list"></param>
            <param name="keys"></param>
            <param name="keySelector"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.Match(System.String,System.String,System.Int32)">
            <summary>模糊匹配</summary>
            <param name="str"></param>
            <param name="key"></param>
            <param name="maxError"></param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.Match``1(System.Collections.Generic.IEnumerable{``0},System.String,System.Func{``0,System.String},System.Int32,System.Double)">
            <summary>模糊匹配</summary>
            <typeparam name="T"></typeparam>
            <param name="list">列表项</param>
            <param name="keys">关键字</param>
            <param name="keySelector">匹配字符串选择</param>
            <param name="count">获取个数</param>
            <param name="confidence">权重阀值</param>
            <returns></returns>
        </member>
        <member name="M:System.StringHelper.Speak(System.String)">
            <summary>调用语音引擎说出指定话</summary>
            <param name="value"></param>
        </member>
        <member name="M:System.StringHelper.SpeakAsync(System.String)">
            <summary>异步调用语音引擎说出指定话。可能导致后来的调用打断前面的语音</summary>
            <param name="value"></param>
        </member>
        <member name="P:System.StringHelper.EnableSpeechTip">
            <summary>启用语音提示</summary>
        </member>
        <member name="M:System.StringHelper.SpeechTip(System.String)">
            <summary>语音提示操作</summary>
            <param name="value"></param>
        </member>
        <member name="M:System.StringHelper.Run(System.String,System.String,System.Int32,System.Action{System.String},System.Action{System.Diagnostics.Process})">
            <summary>以隐藏窗口执行命令行</summary>
            <param name="cmd">文件名</param>
            <param name="arguments">命令参数</param>
            <param name="msWait">等待毫秒数</param>
            <param name="output">进程输出内容。默认为空时输出到日志</param>
            <param name="onExit">进程退出时执行</param>
            <returns>进程退出代码</returns>
        </member>
        <member name="T:System.IOHelper">
            <summary>IO工具类</summary>
        </member>
        <member name="M:System.IOHelper.Compress(System.IO.Stream,System.IO.Stream)">
            <summary>压缩数据流</summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流。如果不指定，则内部实例化一个内存流</param>
            <remarks>返回输出流，注意此时指针位于末端</remarks>
        </member>
        <member name="M:System.IOHelper.Decompress(System.IO.Stream,System.IO.Stream)">
            <summary>解压缩数据流</summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流。如果不指定，则内部实例化一个内存流</param>
            <remarks>返回输出流，注意此时指针位于末端</remarks>
        </member>
        <member name="M:System.IOHelper.Compress(System.Byte[])">
            <summary>压缩字节数组</summary>
            <param name="data">字节数组</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.Decompress(System.Byte[])">
            <summary>解压缩字节数组</summary>
            <param name="data">字节数组</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.CompressGZip(System.IO.Stream,System.IO.Stream)">
            <summary>压缩数据流</summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流。如果不指定，则内部实例化一个内存流</param>
            <remarks>返回输出流，注意此时指针位于末端</remarks>
        </member>
        <member name="M:System.IOHelper.DecompressGZip(System.IO.Stream,System.IO.Stream)">
            <summary>解压缩数据流</summary>
            <param name="inStream">输入流</param>
            <param name="outStream">输出流。如果不指定，则内部实例化一个内存流</param>
            <remarks>返回输出流，注意此时指针位于末端</remarks>
        </member>
        <member name="M:System.IOHelper.CopyTo(System.IO.Stream,System.IO.Stream,System.Int32,System.Int32)">
            <summary>复制数据流</summary>
            <param name="src">源数据流</param>
            <param name="des">目的数据流</param>
            <param name="bufferSize">缓冲区大小，也就是每次复制的大小</param>
            <param name="max">最大复制字节数</param>
            <returns>返回复制的总字节数</returns>
        </member>
        <member name="M:System.IOHelper.Write(System.IO.Stream,System.IO.Stream,System.Int32,System.Int32)">
            <summary>把一个数据流写入到另一个数据流</summary>
            <param name="des">目的数据流</param>
            <param name="src">源数据流</param>
            <param name="bufferSize">缓冲区大小，也就是每次复制的大小</param>
            <param name="max">最大复制字节数</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.Write(System.IO.Stream,System.Byte[])">
            <summary>把一个字节数组写入到一个数据流</summary>
            <param name="des">目的数据流</param>
            <param name="src">源数据流</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.WriteArray(System.IO.Stream,System.Byte[])">
            <summary>写入字节数组，先写入压缩整数表示的长度</summary>
            <param name="des"></param>
            <param name="src"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ReadArray(System.IO.Stream)">
            <summary>读取字节数组，先读取压缩整数表示的长度</summary>
            <param name="des"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.WriteDateTime(System.IO.Stream,System.DateTime)">
            <summary>写入Unix格式时间，1970年以来秒数，绝对时间，非UTC</summary>
            <param name="stream"></param>
            <param name="dt"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ReadDateTime(System.IO.Stream)">
            <summary>读取Unix格式时间，1970年以来秒数，绝对时间，非UTC</summary>
            <param name="stream"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ReadBytes(System.Byte[],System.Int32,System.Int32)">
            <summary>复制数组</summary>
            <param name="src">源数组</param>
            <param name="offset">起始位置</param>
            <param name="count">复制字节数</param>
            <returns>返回复制的总字节数</returns>
        </member>
        <member name="M:System.IOHelper.Write(System.Byte[],System.Int32,System.Byte[],System.Int32,System.Int32)">
            <summary>向字节数组写入一片数据</summary>
            <param name="dst">目标数组</param>
            <param name="dstOffset">目标偏移</param>
            <param name="src">源数组</param>
            <param name="srcOffset">源数组偏移</param>
            <param name="count">数量</param>
            <returns>返回实际写入的字节个数</returns>
        </member>
        <member name="M:System.IOHelper.Combine(System.Byte[],System.Byte[],System.Int32,System.Int32)">
            <summary>合并两个数组</summary>
            <param name="src">源数组</param>
            <param name="des">目标数组</param>
            <param name="offset">起始位置</param>
            <param name="count">字节数</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ReadBytes(System.IO.Stream,System.Int64)">
            <summary>数据流转为字节数组</summary>
            <remarks>
            针对MemoryStream进行优化。内存流的Read实现是一个个字节复制，而ToArray是调用内部内存复制方法
            如果要读完数据，又不支持定位，则采用内存流搬运
            如果指定长度超过数据流长度，就让其报错，因为那是调用者所期望的值
            </remarks>
            <param name="stream">数据流</param>
            <param name="length">长度，0表示读到结束</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ToArray(System.IO.Stream)">
            <summary>数据流转为字节数组，从0开始，无视数据流的当前位置</summary>
            <param name="stream">数据流</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ReadTo(System.IO.Stream,System.Byte[],System.Int64,System.Int64)">
            <summary>从数据流中读取字节数组，直到遇到指定字节数组</summary>
            <param name="stream">数据流</param>
            <param name="buffer">字节数组</param>
            <param name="offset">字节数组中的偏移</param>
            <param name="length">字节数组中的查找长度</param>
            <returns>未找到时返回空，0位置范围大小为0的字节数组</returns>
        </member>
        <member name="M:System.IOHelper.ReadTo(System.IO.Stream,System.String,System.Text.Encoding)">
            <summary>从数据流中读取字节数组，直到遇到指定字节数组</summary>
            <param name="stream">数据流</param>
            <param name="str"></param>
            <param name="encoding"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ReadLine(System.IO.Stream,System.Text.Encoding)">
            <summary>从数据流中读取一行，直到遇到换行</summary>
            <param name="stream">数据流</param>
            <param name="encoding"></param>
            <returns>未找到返回null，0位置返回String.Empty</returns>
        </member>
        <member name="M:System.IOHelper.ToStr(System.IO.Stream,System.Text.Encoding)">
            <summary>流转换为字符串</summary>
            <param name="stream">目标流</param>
            <param name="encoding">编码格式</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ToStr(System.Byte[],System.Text.Encoding,System.Int32,System.Int32)">
            <summary>字节数组转换为字符串</summary>
            <param name="buf">字节数组</param>
            <param name="encoding">编码格式</param>
            <param name="offset">字节数组中的偏移</param>
            <param name="count">字节数组中的查找长度</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ToUInt16(System.Byte[],System.Int32,System.Boolean)">
            <summary>从字节数据指定位置读取一个无符号16位整数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ToUInt32(System.Byte[],System.Int32,System.Boolean)">
            <summary>从字节数据指定位置读取一个无符号32位整数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ToUInt64(System.Byte[],System.Int32,System.Boolean)">
            <summary>从字节数据指定位置读取一个无符号64位整数</summary>
            <param name="data"></param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.Write(System.Byte[],System.UInt16,System.Int32,System.Boolean)">
            <summary>向字节数组的指定位置写入一个无符号16位整数</summary>
            <param name="data"></param>
            <param name="n">数字</param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.Write(System.Byte[],System.UInt32,System.Int32,System.Boolean)">
            <summary>向字节数组的指定位置写入一个无符号32位整数</summary>
            <param name="data"></param>
            <param name="n">数字</param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.Write(System.Byte[],System.UInt64,System.Int32,System.Boolean)">
            <summary>向字节数组的指定位置写入一个无符号64位整数</summary>
            <param name="data"></param>
            <param name="n">数字</param>
            <param name="offset">偏移</param>
            <param name="isLittleEndian">是否小端字节序</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.GetBytes(System.UInt16,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.GetBytes(System.Int16,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.GetBytes(System.UInt32,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.GetBytes(System.Int32,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.GetBytes(System.UInt64,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.GetBytes(System.Int64,System.Boolean)">
            <summary>整数转为字节数组，注意大小端字节序</summary>
            <param name="value"></param>
            <param name="isLittleEndian"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ReadEncodedInt(System.IO.Stream)">
            <summary>以压缩格式读取32位整数</summary>
            <param name="stream">数据流</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ReadEncodedInt64(System.IO.Stream)">
            <summary>以压缩格式读取32位整数</summary>
            <param name="stream">数据流</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.TryReadEncodedInt(System.IO.Stream,System.UInt32@)">
            <summary>尝试读取压缩编码整数</summary>
            <param name="stream"></param>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.WriteEncodedInt(System.IO.Stream,System.Int64)">
            <summary>
            以7位压缩格式写入32位整数，小于7位用1个字节，小于14位用2个字节。
            由每次写入的一个字节的第一位标记后面的字节是否还是当前数据，所以每个字节实际可利用存储空间只有后7位。
            </summary>
            <param name="stream">数据流</param>
            <param name="value">数值</param>
            <returns>实际写入字节数</returns>
        </member>
        <member name="M:System.IOHelper.GetEncodedInt(System.Int64)">
            <summary>获取压缩编码整数</summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.IndexOf(System.IO.Stream,System.Byte[],System.Int64,System.Int64)">
            <summary>在数据流中查找字节数组的位置，流指针会移动到结尾</summary>
            <param name="stream">数据流</param>
            <param name="buffer">字节数组</param>
            <param name="offset">字节数组中的偏移</param>
            <param name="length">字节数组中的查找长度</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.IndexOf(System.Byte[],System.Byte[],System.Int64,System.Int64)">
            <summary>在字节数组中查找另一个字节数组的位置，不存在则返回-1</summary>
            <param name="source">字节数组</param>
            <param name="buffer">另一个字节数组</param>
            <param name="offset">偏移</param>
            <param name="length">查找长度</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.IndexOf(System.Byte[],System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>在字节数组中查找另一个字节数组的位置，不存在则返回-1</summary>
            <param name="source">字节数组</param>
            <param name="start">源数组起始位置</param>
            <param name="count">查找长度</param>
            <param name="buffer">另一个字节数组</param>
            <param name="offset">偏移</param>
            <param name="length">查找长度</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.CompareTo(System.Byte[],System.Byte[])">
            <summary>比较两个字节数组大小。相等返回0，不等则返回不等的位置，如果位置为0，则返回1。</summary>
            <param name="source"></param>
            <param name="buffer">缓冲区</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.CompareTo(System.Byte[],System.Int64,System.Int64,System.Byte[],System.Int64,System.Int64)">
            <summary>比较两个字节数组大小。相等返回0，不等则返回不等的位置，如果位置为0，则返回1。</summary>
            <param name="source"></param>
            <param name="start"></param>
            <param name="count">数量</param>
            <param name="buffer">缓冲区</param>
            <param name="offset">偏移</param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.Split(System.Byte[],System.Byte[])">
            <summary>字节数组分割</summary>
            <param name="buf"></param>
            <param name="sps"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.StartsWith(System.IO.Stream,System.Byte[])">
            <summary>一个数据流是否以另一个数组开头。如果成功，指针移到目标之后，否则保持指针位置不变。</summary>
            <param name="source"></param>
            <param name="buffer">缓冲区</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.EndsWith(System.IO.Stream,System.Byte[])">
            <summary>一个数据流是否以另一个数组结尾。如果成功，指针移到目标之后，否则保持指针位置不变。</summary>
            <param name="source"></param>
            <param name="buffer">缓冲区</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.StartsWith(System.Byte[],System.Byte[])">
            <summary>一个数组是否以另一个数组开头</summary>
            <param name="source"></param>
            <param name="buffer">缓冲区</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.EndsWith(System.Byte[],System.Byte[])">
            <summary>一个数组是否以另一个数组结尾</summary>
            <param name="source"></param>
            <param name="buffer">缓冲区</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.Reverse(System.Byte[])">
            <summary>倒序、更换字节序</summary>
            <param name="buf">字节数组</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ToHex(System.Byte[],System.Int32,System.Int32)">
            <summary>把字节数组编码为十六进制字符串</summary>
            <param name="data">字节数组</param>
            <param name="offset">偏移</param>
            <param name="count">数量。超过实际数量时，使用实际数量</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ToHex(System.Byte[],System.String,System.Int32,System.Int32)">
            <summary>把字节数组编码为十六进制字符串，带有分隔符和分组功能</summary>
            <param name="data">字节数组</param>
            <param name="separate">分隔符</param>
            <param name="groupSize">分组大小，为0时对每个字节应用分隔符，否则对每个分组使用</param>
            <param name="maxLength">最大显示多少个字节。默认-1显示全部</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ToHex(System.String,System.Int32,System.Int32)">
            <summary>解密</summary>
            <param name="data">Hex编码的字符串</param>
            <param name="startIndex">起始位置</param>
            <param name="length">长度</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ToBase64(System.Byte[],System.Int32,System.Int32,System.Boolean)">
            <summary>字节数组转为Base64编码</summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <param name="lineBreak">是否换行显示</param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ToUrlBase64(System.Byte[],System.Int32,System.Int32)">
            <summary>字节数组转为Url改进型Base64编码</summary>
            <param name="data"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:System.IOHelper.ToBase64(System.String)">
            <summary>Base64字符串转为字节数组</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="T:System.SecurityHelper">
            <summary>安全算法</summary>
        </member>
        <member name="M:System.SecurityHelper.MD5(System.Byte[])">
            <summary>MD5散列</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.MD5(System.String,System.Text.Encoding)">
            <summary>MD5散列</summary>
            <param name="data"></param>
            <param name="encoding">字符串编码，默认Default</param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.MD5_16(System.String,System.Text.Encoding)">
            <summary>MD5散列</summary>
            <param name="data"></param>
            <param name="encoding">字符串编码，默认Default</param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.Crc(System.Byte[])">
            <summary>Crc散列</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.Crc16(System.Byte[])">
            <summary>Crc16散列</summary>
            <param name="data"></param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.SHA1(System.Byte[],System.Byte[])">
            <summary>SHA128</summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.SHA256(System.Byte[],System.Byte[])">
            <summary>SHA256</summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.SHA384(System.Byte[],System.Byte[])">
            <summary>SHA384</summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.SHA512(System.Byte[],System.Byte[])">
            <summary>SHA512</summary>
            <param name="data"></param>
            <param name="key"></param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.Encrypt(System.Security.Cryptography.SymmetricAlgorithm,System.IO.Stream,System.IO.Stream)">
            <summary>对称加密算法扩展</summary>
            <remarks>注意：CryptoStream会把 outstream 数据流关闭</remarks>
            <param name="sa"></param>
            <param name="instream"></param>
            <param name="outstream"></param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.Encrypt(System.Security.Cryptography.SymmetricAlgorithm,System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode)">
            <summary>对称加密算法扩展</summary>
            <param name="sa">算法</param>
            <param name="data">数据</param>
            <param name="pass">密码</param>
            <param name="mode">模式。.Net默认CBC，Java默认ECB</param>
            <param name="padding">填充算法。默认PKCS7，等同Java的PKCS5</param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.Descrypt(System.Security.Cryptography.SymmetricAlgorithm,System.IO.Stream,System.IO.Stream)">
            <summary>对称解密算法扩展
            <para>注意：CryptoStream会把 instream 数据流关闭</para>
            </summary>
            <param name="sa"></param>
            <param name="instream"></param>
            <param name="outstream"></param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.Descrypt(System.Security.Cryptography.SymmetricAlgorithm,System.Byte[],System.Byte[],System.Security.Cryptography.CipherMode,System.Security.Cryptography.PaddingMode)">
            <summary>对称解密算法扩展</summary>
            <param name="sa">算法</param>
            <param name="data">数据</param>
            <param name="pass">密码</param>
            <param name="mode">模式。.Net默认CBC，Java默认ECB</param>
            <param name="padding">填充算法。默认PKCS7，等同Java的PKCS5</param>
            <returns></returns>
        </member>
        <member name="M:System.SecurityHelper.RC4(System.Byte[],System.Byte[])">
            <summary>RC4对称加密算法</summary>
            <param name="data"></param>
            <param name="pass"></param>
            <returns></returns>
        </member>
        <member name="T:System.AttributeX">
            <summary>特性辅助类</summary>
        </member>
        <member name="M:System.AttributeX.GetCustomAttributes``1(System.Reflection.Assembly)">
            <summary>获取自定义属性，带有缓存功能，避免因.Net内部GetCustomAttributes没有缓存而带来的损耗</summary>
            <typeparam name="TAttribute"></typeparam>
            <param name="assembly"></param>
            <returns></returns>
        </member>
        <member name="M:System.AttributeX.GetDisplayName(System.Reflection.MemberInfo,System.Boolean)">
            <summary>获取成员绑定的显示名，优先DisplayName，然后Description</summary>
            <param name="member"></param>
            <param name="inherit"></param>
            <returns></returns>
        </member>
        <member name="M:System.AttributeX.GetDescription(System.Reflection.MemberInfo,System.Boolean)">
            <summary>获取成员绑定的显示名，优先DisplayName，然后Description</summary>
            <param name="member"></param>
            <param name="inherit"></param>
            <returns></returns>
        </member>
        <member name="M:System.AttributeX.GetCustomAttributeValue``2(System.Reflection.Assembly)">
            <summary>获取自定义属性的值。可用于ReflectionOnly加载的程序集</summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <returns></returns>
        </member>
        <member name="M:System.AttributeX.GetCustomAttributeValue``2(System.Reflection.MemberInfo,System.Boolean)">
            <summary>获取自定义属性的值。可用于ReflectionOnly加载的程序集</summary>
            <typeparam name="TAttribute"></typeparam>
            <typeparam name="TResult"></typeparam>
            <param name="target">目标对象</param>
            <param name="inherit">是否递归</param>
            <returns></returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskEx">
            <summary>任务扩展</summary>
        </member>
        <member name="P:System.Threading.Tasks.TaskEx.Factory">
            <summary>公平调度的工厂</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Run(System.Action)">
            <summary>异步执行</summary>
            <param name="action"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Run(System.Action,System.Threading.CancellationToken)">
            <summary>异步执行</summary>
            <param name="action"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Run``1(System.Func{``0})">
            <summary>异步执行</summary>
            <typeparam name="TResult"></typeparam>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Run``1(System.Func{``0},System.Threading.CancellationToken)">
            <summary>异步执行</summary>
            <typeparam name="TResult"></typeparam>
            <param name="function"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Run(System.Func{System.Threading.Tasks.Task})">
            <summary>异步执行</summary>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Run(System.Func{System.Threading.Tasks.Task},System.Threading.CancellationToken)">
            <summary>异步执行</summary>
            <param name="function"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Run``1(System.Func{System.Threading.Tasks.Task{``0}})">
            <summary>异步执行</summary>
            <typeparam name="TResult"></typeparam>
            <param name="function"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskEx.Run``1(System.Func{System.Threading.Tasks.Task{``0}},System.Threading.CancellationToken)">
            <summary>异步执行</summary>
            <typeparam name="TResult"></typeparam>
            <param name="function"></param>
            <param name="cancellationToken"></param>
            <returns></returns>
        </member>
        <member name="T:System.Threading.Tasks.TaskEx`1">
            <summary>任务扩展</summary>
            <typeparam name="TResult"></typeparam>
        </member>
        <member name="P:System.Threading.Tasks.TaskEx`1.Factory">
            <summary>公平调度的工厂</summary>
        </member>
        <member name="T:System.Threading.Tasks.TaskHelper">
            <summary>任务助手</summary>
        </member>
        <member name="M:System.Threading.Tasks.TaskHelper.IsOK(System.Threading.Tasks.Task)">
            <summary>是否正确完成</summary>
            <param name="task"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskHelper.LogException(System.Threading.Tasks.Task,NewLife.Log.ILog)">
            <summary>捕获异常并输出日志</summary>
            <param name="task"></param>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskHelper.LogException``1(System.Threading.Tasks.Task{``0},NewLife.Log.ILog)">
            <summary>捕获异常并输出日志</summary>
            <param name="task"></param>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskHelper.LogException(System.Threading.Tasks.Task,System.Action{System.Exception})">
            <summary>捕获异常并输出日志</summary>
            <param name="task"></param>
            <param name="errCallback"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskHelper.LogTime(System.Threading.Tasks.Task,System.String,NewLife.Log.ILog)">
            <summary>统计时间并输出日志</summary>
            <param name="task"></param>
            <param name="name"></param>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskHelper.LogTime``1(System.Threading.Tasks.Task{``0},System.String,NewLife.Log.ILog)">
            <summary>统计时间并输出日志</summary>
            <param name="task"></param>
            <param name="name"></param>
            <param name="log"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskHelper.ReadAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>异步读取数据流</summary>
            <param name="stream"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskHelper.ReadAsync(System.IO.Stream,System.Int32)">
            <summary>异步读取数据</summary>
            <param name="stream"></param>
            <param name="length"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskHelper.WriteAsync(System.IO.Stream,System.Byte[],System.Int32,System.Int32)">
            <summary>异步写入数据流</summary>
            <param name="stream"></param>
            <param name="buffer"></param>
            <param name="offset"></param>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="M:System.Threading.Tasks.TaskHelper.ToTask``1(System.Threading.Tasks.Task,System.Threading.CancellationToken,``0)">
            <summary>任务转换</summary>
            <typeparam name="TResult"></typeparam>
            <param name="task"></param>
            <param name="cancellationToken"></param>
            <param name="result"></param>
            <returns></returns>
        </member>
        <member name="T:System.Windows.Forms.ControlHelper">
            <summary>控件助手</summary>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Invoke(System.Windows.Forms.Control,System.Action)">
            <summary>执行无参委托</summary>
            <param name="control"></param>
            <param name="method"></param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Invoke``1(System.Windows.Forms.Control,System.Action{``0},``0)">
            <summary>执行单一参数无返回值的委托</summary>
            <typeparam name="T"></typeparam>
            <param name="control"></param>
            <param name="method"></param>
            <param name="arg"></param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Invoke``2(System.Windows.Forms.Control,System.Action{``0,``1},``0,``1)">
            <summary>执行二参数无返回值的委托</summary>
            <typeparam name="T"></typeparam>
            <typeparam name="T2"></typeparam>
            <param name="control"></param>
            <param name="method"></param>
            <param name="arg"></param>
            <param name="arg2"></param>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Append(System.Windows.Forms.TextBoxBase,System.String,System.Int32)">
            <summary>附加文本到文本控件末尾。主要解决非UI线程以及滚动控件等问题</summary>
            <param name="txt">控件</param>
            <param name="msg">消息</param>
            <param name="maxLines">最大行数。超过该行数讲清空控件</param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Scroll(System.Windows.Forms.TextBoxBase,System.Boolean)">
            <summary>滚动控件的滚动条</summary>
            <param name="txt">指定控件</param>
            <param name="bottom">是否底端，或者顶端</param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.ProcessReturn(System.Windows.Forms.TextBoxBase,System.String@)">
            <summary>处理回车，移到行首</summary>
            <param name="txt"></param>
            <param name="m"></param>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.SetDefaultStyle(System.Windows.Forms.Control,System.Int32)">
            <summary>设置默认样式，包括字体、前景色、背景色</summary>
            <param name="control">控件</param>
            <param name="size">字体大小</param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.SetFontSize(System.Windows.Forms.Control,System.Int32)">
            <summary>设置字体大小</summary>
            <param name="control"></param>
            <param name="size"></param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.ColourDefault(System.Windows.Forms.RichTextBox,System.Int32)">
            <summary>采用默认着色方案进行着色</summary>
            <param name="rtb">文本控件</param>
            <param name="start">开始位置</param>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.ChangeCppColor(System.Windows.Forms.RichTextBox,System.Int32)">
            <summary>改变C++类名方法名颜色</summary>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Colour(System.Windows.Forms.RichTextBox,System.Text.RegularExpressions.Regex,System.Int32,System.Drawing.Color[])">
            <summary>着色文本控件的内容</summary>
            <param name="rtb">文本控件</param>
            <param name="reg">正则表达式</param>
            <param name="start">开始位置</param>
            <param name="colors">颜色数组</param>
            <returns></returns>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.Colour(System.Windows.Forms.RichTextBox,System.String,System.Int32,System.Drawing.Color[])">
            <summary>着色文本控件的内容</summary>
            <param name="rtb">文本控件</param>
            <param name="reg">正则表达式</param>
            <param name="start">开始位置</param>
            <param name="colors">颜色数组</param>
            <returns></returns>
        </member>
        <member name="P:System.Windows.Forms.ControlHelper.Dpi">
            <summary>当前Dpi</summary>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.FixDpi(System.Windows.Forms.ListView)">
            <summary>修正ListView的Dpi</summary>
            <param name="lv"></param>
        </member>
        <member name="M:System.Windows.Forms.ControlHelper.FixDpi(System.Windows.Forms.Form)">
            <summary>修正窗体的Dpi</summary>
            <param name="frm"></param>
        </member>
        <member name="T:System.EndPointExtensions">
            <summary>网络结点扩展</summary>
        </member>
        <member name="M:System.EndPointExtensions.ToAddress(System.Net.EndPoint)">
            <summary>
            
            </summary>
            <param name="endpoint"></param>
            <returns></returns>
        </member>
        <member name="M:System.EndPointExtensions.ToAddress(System.Net.IPEndPoint)">
            <summary>
            
            </summary>
            <param name="endpoint"></param>
            <returns></returns>
        </member>
        <member name="M:System.EndPointExtensions.ToEndPoint(System.String)">
            <summary>
            
            </summary>
            <param name="address"></param>
            <returns></returns>
        </member>
        <member name="M:System.EndPointExtensions.ToEndPoints(System.String)">
            <summary>
            
            </summary>
            <param name="addresses"></param>
            <returns></returns>
        </member>
    </members>
</doc>
